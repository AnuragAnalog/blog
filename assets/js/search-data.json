{
  
    
        "post0": {
            "title": "Tabular Playground Series Mar 2022",
            "content": "!pip3 install kaggle !pip3 install prophet !pip3 install pystan==2.19.1.1 . Requirement already satisfied: kaggle in /usr/local/lib/python3.7/dist-packages (1.5.12) Requirement already satisfied: six&gt;=1.10 in /usr/local/lib/python3.7/dist-packages (from kaggle) (1.15.0) Requirement already satisfied: requests in /usr/local/lib/python3.7/dist-packages (from kaggle) (2.23.0) Requirement already satisfied: python-slugify in /usr/local/lib/python3.7/dist-packages (from kaggle) (6.1.1) Requirement already satisfied: urllib3 in /usr/local/lib/python3.7/dist-packages (from kaggle) (1.24.3) Requirement already satisfied: tqdm in /usr/local/lib/python3.7/dist-packages (from kaggle) (4.63.0) Requirement already satisfied: python-dateutil in /usr/local/lib/python3.7/dist-packages (from kaggle) (2.8.2) Requirement already satisfied: certifi in /usr/local/lib/python3.7/dist-packages (from kaggle) (2021.10.8) Requirement already satisfied: text-unidecode&gt;=1.3 in /usr/local/lib/python3.7/dist-packages (from python-slugify-&gt;kaggle) (1.3) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.7/dist-packages (from requests-&gt;kaggle) (2.10) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.7/dist-packages (from requests-&gt;kaggle) (3.0.4) Requirement already satisfied: prophet in /usr/local/lib/python3.7/dist-packages (1.0.1) Requirement already satisfied: pystan~=2.19.1.1 in /usr/local/lib/python3.7/dist-packages (from prophet) (2.19.1.1) Requirement already satisfied: numpy&gt;=1.15.4 in /usr/local/lib/python3.7/dist-packages (from prophet) (1.21.5) Requirement already satisfied: holidays&gt;=0.10.2 in /usr/local/lib/python3.7/dist-packages (from prophet) (0.10.5.2) Requirement already satisfied: pandas&gt;=1.0.4 in /usr/local/lib/python3.7/dist-packages (from prophet) (1.3.5) Requirement already satisfied: convertdate&gt;=2.1.2 in /usr/local/lib/python3.7/dist-packages (from prophet) (2.4.0) Requirement already satisfied: python-dateutil&gt;=2.8.0 in /usr/local/lib/python3.7/dist-packages (from prophet) (2.8.2) Requirement already satisfied: tqdm&gt;=4.36.1 in /usr/local/lib/python3.7/dist-packages (from prophet) (4.63.0) Requirement already satisfied: matplotlib&gt;=2.0.0 in /usr/local/lib/python3.7/dist-packages (from prophet) (3.2.2) Requirement already satisfied: cmdstanpy==0.9.68 in /usr/local/lib/python3.7/dist-packages (from prophet) (0.9.68) Requirement already satisfied: setuptools-git&gt;=1.2 in /usr/local/lib/python3.7/dist-packages (from prophet) (1.2) Requirement already satisfied: LunarCalendar&gt;=0.0.9 in /usr/local/lib/python3.7/dist-packages (from prophet) (0.0.9) Requirement already satisfied: Cython&gt;=0.22 in /usr/local/lib/python3.7/dist-packages (from prophet) (0.29.28) Requirement already satisfied: ujson in /usr/local/lib/python3.7/dist-packages (from cmdstanpy==0.9.68-&gt;prophet) (5.1.0) Requirement already satisfied: pymeeus&lt;=1,&gt;=0.3.13 in /usr/local/lib/python3.7/dist-packages (from convertdate&gt;=2.1.2-&gt;prophet) (0.5.11) Requirement already satisfied: korean-lunar-calendar in /usr/local/lib/python3.7/dist-packages (from holidays&gt;=0.10.2-&gt;prophet) (0.2.1) Requirement already satisfied: six in /usr/local/lib/python3.7/dist-packages (from holidays&gt;=0.10.2-&gt;prophet) (1.15.0) Requirement already satisfied: hijri-converter in /usr/local/lib/python3.7/dist-packages (from holidays&gt;=0.10.2-&gt;prophet) (2.2.3) Requirement already satisfied: pytz in /usr/local/lib/python3.7/dist-packages (from LunarCalendar&gt;=0.0.9-&gt;prophet) (2018.9) Requirement already satisfied: ephem&gt;=3.7.5.3 in /usr/local/lib/python3.7/dist-packages (from LunarCalendar&gt;=0.0.9-&gt;prophet) (4.1.3) Requirement already satisfied: kiwisolver&gt;=1.0.1 in /usr/local/lib/python3.7/dist-packages (from matplotlib&gt;=2.0.0-&gt;prophet) (1.4.0) Requirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,&gt;=2.0.1 in /usr/local/lib/python3.7/dist-packages (from matplotlib&gt;=2.0.0-&gt;prophet) (3.0.7) Requirement already satisfied: cycler&gt;=0.10 in /usr/local/lib/python3.7/dist-packages (from matplotlib&gt;=2.0.0-&gt;prophet) (0.11.0) Requirement already satisfied: typing-extensions in /usr/local/lib/python3.7/dist-packages (from kiwisolver&gt;=1.0.1-&gt;matplotlib&gt;=2.0.0-&gt;prophet) (3.10.0.2) Requirement already satisfied: pystan==2.19.1.1 in /usr/local/lib/python3.7/dist-packages (2.19.1.1) Requirement already satisfied: Cython!=0.25.1,&gt;=0.22 in /usr/local/lib/python3.7/dist-packages (from pystan==2.19.1.1) (0.29.28) Requirement already satisfied: numpy&gt;=1.7 in /usr/local/lib/python3.7/dist-packages (from pystan==2.19.1.1) (1.21.5) . import tqdm import numpy as np import pandas as pd import seaborn as sns from zipfile import ZipFile from prophet import Prophet from matplotlib import pyplot as plt . %matplotlib inline plt.rcParams[&#39;figure.figsize&#39;] = (12, 12) . Before running the below cell, upload your kaggle token, to make sure an error doesn&#39;t popup. . !mkdir ~/.kaggle !cp kaggle.json ~/.kaggle/ !chmod 600 ~/.kaggle/kaggle.json . mkdir: cannot create directory ‘/root/.kaggle’: File exists . !kaggle competitions download -c tabular-playground-series-mar-2022 . tabular-playground-series-mar-2022.zip: Skipping, found more recently modified local copy (use --force to force download) . with ZipFile(&#39;/content/tabular-playground-series-mar-2022.zip&#39;, &#39;r&#39;) as zf: zf.extractall(&#39;./&#39;) . Loading the data . train = pd.read_csv(&#39;train.csv&#39;, index_col=&#39;row_id&#39;, parse_dates=[&#39;time&#39;]) train.head() . time x y direction congestion . row_id . 0 1991-04-01 | 0 | 0 | EB | 70 | . 1 1991-04-01 | 0 | 0 | NB | 49 | . 2 1991-04-01 | 0 | 0 | SB | 24 | . 3 1991-04-01 | 0 | 1 | EB | 18 | . 4 1991-04-01 | 0 | 1 | NB | 60 | . &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;24px&quot;viewBox=&quot;0 0 24 24&quot; width=&quot;24px&quot;&gt; &lt;/svg&gt; train.info() train.describe() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 848835 entries, 0 to 848834 Data columns (total 5 columns): # Column Non-Null Count Dtype -- -- 0 time 848835 non-null datetime64[ns] 1 x 848835 non-null int64 2 y 848835 non-null int64 3 direction 848835 non-null object 4 congestion 848835 non-null int64 dtypes: datetime64[ns](1), int64(3), object(1) memory usage: 38.9+ MB . x y congestion . count 848835.000000 | 848835.000000 | 848835.000000 | . mean 1.138462 | 1.630769 | 47.815305 | . std 0.801478 | 1.089379 | 16.799392 | . min 0.000000 | 0.000000 | 0.000000 | . 25% 0.000000 | 1.000000 | 35.000000 | . 50% 1.000000 | 2.000000 | 47.000000 | . 75% 2.000000 | 3.000000 | 60.000000 | . max 2.000000 | 3.000000 | 100.000000 | . &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;24px&quot;viewBox=&quot;0 0 24 24&quot; width=&quot;24px&quot;&gt; &lt;/svg&gt; sns.heatmap(train.corr(), annot=True, vmin=-1, vmax=1, cmap=&#39;RdYlGn&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fa74ad97410&gt; . test = pd.read_csv(&#39;test.csv&#39;, index_col=&#39;row_id&#39;, parse_dates=[&#39;time&#39;]) test.head() . time x y direction . row_id . 848835 1991-09-30 12:00:00 | 0 | 0 | EB | . 848836 1991-09-30 12:00:00 | 0 | 0 | NB | . 848837 1991-09-30 12:00:00 | 0 | 0 | SB | . 848838 1991-09-30 12:00:00 | 0 | 1 | EB | . 848839 1991-09-30 12:00:00 | 0 | 1 | NB | . &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;24px&quot;viewBox=&quot;0 0 24 24&quot; width=&quot;24px&quot;&gt; &lt;/svg&gt; There are no missing values, in the data. . if train.isna().any().any(): print(train.isna().sum()/train.shape[0]) else: print(&quot;No Missing values&quot;) . No Missing values . Preparation . test[&#39;congestion&#39;] = 0.0 . grouped_train_data = train.groupby([&#39;time&#39;, &#39;x&#39;, &#39;y&#39;, &#39;direction&#39;]) grouped_test_data = test.groupby([&#39;time&#39;, &#39;x&#39;, &#39;y&#39;, &#39;direction&#39;]) . train_dict = dict() test_dict = dict() for g in grouped_train_data: if (g[0][1], g[0][2], g[0][3]) in train_dict.keys(): train_dict[(g[0][1], g[0][2], g[0][3])].append((g[0][0], g[1][&#39;congestion&#39;].values[0])) else: train_dict[(g[0][1], g[0][2], g[0][3])] = [(g[0][0], g[1][&#39;congestion&#39;].values[0])] for g in grouped_test_data: if (g[0][1], g[0][2], g[0][3]) in test_dict.keys(): test_dict[(g[0][1], g[0][2], g[0][3])].append((g[0][0], g[1][&#39;congestion&#39;].values[0])) else: test_dict[(g[0][1], g[0][2], g[0][3])] = [(g[0][0], g[1][&#39;congestion&#39;].values[0])] . for idx, li in train_dict.items(): train_dict[idx] = pd.DataFrame(columns=[&#39;ds&#39;, &#39;y&#39;], data=li) for idx, li in test_dict.items(): test_dict[idx] = pd.DataFrame(columns=[&#39;ds&#39;, &#39;y&#39;], data=li).drop([&#39;y&#39;], axis=1) . Modelling . Approach-1 . In this method, I have grouped the data into a number of instances and made the predictions on that instances. . An instance is uniquely identifiable by its a key which is a combination of its cordinates and the direction. . for idx, train_data in tqdm.tqdm(train_dict.items()): model = Prophet() model.fit(train_data) forecast = model.predict(test_dict[idx]) test_dict[idx][&#39;congestion&#39;] = np.round(forecast[&#39;yhat&#39;]) test_dict[idx][&#39;x&#39;] = idx[0] test_dict[idx][&#39;y&#39;] = idx[1] test_dict[idx][&#39;direction&#39;] = idx[2] . 0%| | 0/65 [00:00&lt;?, ?it/s]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 2%|▏ | 1/65 [00:08&lt;08:55, 8.36s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 3%|▎ | 2/65 [00:12&lt;06:23, 6.09s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 5%|▍ | 3/65 [00:20&lt;06:55, 6.70s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 6%|▌ | 4/65 [00:29&lt;07:53, 7.76s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 8%|▊ | 5/65 [00:36&lt;07:21, 7.37s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 9%|▉ | 6/65 [00:41&lt;06:39, 6.77s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 11%|█ | 7/65 [00:48&lt;06:37, 6.85s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 12%|█▏ | 8/65 [00:55&lt;06:24, 6.75s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 14%|█▍ | 9/65 [01:00&lt;05:49, 6.24s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 15%|█▌ | 10/65 [01:06&lt;05:35, 6.10s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 17%|█▋ | 11/65 [01:11&lt;05:08, 5.71s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 18%|█▊ | 12/65 [01:16&lt;04:56, 5.60s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 20%|██ | 13/65 [01:24&lt;05:25, 6.25s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 22%|██▏ | 14/65 [01:28&lt;04:46, 5.63s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 23%|██▎ | 15/65 [01:34&lt;04:46, 5.72s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 25%|██▍ | 16/65 [01:39&lt;04:31, 5.55s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 26%|██▌ | 17/65 [01:45&lt;04:26, 5.55s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 28%|██▊ | 18/65 [01:51&lt;04:29, 5.74s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 29%|██▉ | 19/65 [01:57&lt;04:23, 5.72s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 31%|███ | 20/65 [02:02&lt;04:14, 5.65s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 32%|███▏ | 21/65 [02:06&lt;03:41, 5.03s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 34%|███▍ | 22/65 [02:11&lt;03:46, 5.26s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 35%|███▌ | 23/65 [02:18&lt;03:52, 5.54s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 37%|███▋ | 24/65 [02:21&lt;03:24, 4.99s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 38%|███▊ | 25/65 [02:28&lt;03:43, 5.58s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 40%|████ | 26/65 [02:37&lt;04:09, 6.40s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 42%|████▏ | 27/65 [02:44&lt;04:15, 6.72s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 43%|████▎ | 28/65 [02:51&lt;04:10, 6.78s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 45%|████▍ | 29/65 [02:56&lt;03:44, 6.24s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 46%|████▌ | 30/65 [03:02&lt;03:34, 6.14s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 48%|████▊ | 31/65 [03:08&lt;03:34, 6.29s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 49%|████▉ | 32/65 [03:14&lt;03:17, 5.99s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 51%|█████ | 33/65 [03:19&lt;03:07, 5.85s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 52%|█████▏ | 34/65 [03:23&lt;02:43, 5.28s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 54%|█████▍ | 35/65 [03:29&lt;02:39, 5.33s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 55%|█████▌ | 36/65 [03:35&lt;02:47, 5.76s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 57%|█████▋ | 37/65 [03:41&lt;02:41, 5.77s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 58%|█████▊ | 38/65 [03:46&lt;02:30, 5.57s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 60%|██████ | 39/65 [03:49&lt;02:04, 4.78s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 62%|██████▏ | 40/65 [03:55&lt;02:07, 5.12s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 63%|██████▎ | 41/65 [04:03&lt;02:24, 6.03s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 65%|██████▍ | 42/65 [04:10&lt;02:20, 6.10s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 66%|██████▌ | 43/65 [04:14&lt;02:03, 5.62s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 68%|██████▊ | 44/65 [04:21&lt;02:06, 6.01s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 69%|██████▉ | 45/65 [04:27&lt;02:01, 6.08s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 71%|███████ | 46/65 [04:32&lt;01:48, 5.70s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 72%|███████▏ | 47/65 [04:37&lt;01:39, 5.54s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 74%|███████▍ | 48/65 [04:42&lt;01:29, 5.29s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 75%|███████▌ | 49/65 [04:49&lt;01:34, 5.92s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 77%|███████▋ | 50/65 [04:55&lt;01:25, 5.69s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 78%|███████▊ | 51/65 [05:00&lt;01:17, 5.51s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 80%|████████ | 52/65 [05:04&lt;01:07, 5.20s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 82%|████████▏ | 53/65 [05:11&lt;01:08, 5.74s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 83%|████████▎ | 54/65 [05:17&lt;01:05, 5.93s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 85%|████████▍ | 55/65 [05:23&lt;00:57, 5.77s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 86%|████████▌ | 56/65 [05:28&lt;00:51, 5.73s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 88%|████████▊ | 57/65 [05:35&lt;00:48, 6.03s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 89%|████████▉ | 58/65 [05:40&lt;00:40, 5.78s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 91%|█████████ | 59/65 [05:46&lt;00:33, 5.58s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 92%|█████████▏| 60/65 [05:51&lt;00:28, 5.67s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 94%|█████████▍| 61/65 [05:55&lt;00:20, 5.05s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 95%|█████████▌| 62/65 [05:59&lt;00:14, 4.68s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 97%|█████████▋| 63/65 [06:04&lt;00:09, 4.79s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 98%|█████████▊| 64/65 [06:08&lt;00:04, 4.56s/it]INFO:prophet:Disabling yearly seasonality. Run prophet with yearly_seasonality=True to override this. 100%|██████████| 65/65 [06:11&lt;00:00, 5.72s/it] . preds_semi_final = pd.concat(test_dict.values(), ignore_index=True) preds_final = test.reset_index().merge(preds_semi_final, left_on=[&#39;time&#39;, &#39;x&#39;, &#39;y&#39;, &#39;direction&#39;], right_on=[&#39;ds&#39;, &#39;x&#39;, &#39;y&#39;, &#39;direction&#39;])[[&#39;row_id&#39;, &#39;congestion_y&#39;]] . submission = pd.read_csv(&#39;/content/sample_submission.csv&#39;) submission = submission.merge(preds_final, on=&#39;row_id&#39;)[[&#39;row_id&#39;, &#39;congestion_y&#39;]].rename(columns={&#39;congestion_y&#39;: &#39;congestion&#39;}) submission.to_csv(&#39;output.csv&#39;, index=False) . !kaggle competitions submit -c tabular-playground-series-mar-2022 -f output.csv -m &quot;FB Prophet correct 2 with round&quot; . 100% 27.4k/27.4k [00:00&lt;00:00, 150kB/s] Successfully submitted to Tabular Playground Series - Mar 2022 .",
            "url": "https://anuraganalog.github.io/blog/kaggle/fbprophet/jupyter/tps/2022/03/24/Tabular-Playground-Series-Mar-2022-FB-Prophet.html",
            "relUrl": "/kaggle/fbprophet/jupyter/tps/2022/03/24/Tabular-Playground-Series-Mar-2022-FB-Prophet.html",
            "date": " • Mar 24, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Analyze Your Runkeeper Fitness Data",
            "content": "1. Obtain and review raw data . One day, my old running friend and I were chatting about our running styles, training habits, and achievements, when I suddenly realized that I could take an in-depth analytical look at my training. I have been using a popular GPS fitness tracker called Runkeeper for years and decided it was time to analyze my running data to see how I was doing. . Since 2012, I&#39;ve been using the Runkeeper app, and it&#39;s great. One key feature: its excellent data export. Anyone who has a smartphone can download the app and analyze their data like we will in this notebook. . . After logging your run, the first step is to export the data from Runkeeper (which I&#39;ve done already). Then import the data and start exploring to find potential problems. After that, create data cleaning strategies to fix the issues. Finally, analyze and visualize the clean time-series data. . I exported seven years worth of my training data, from 2012 through 2018. The data is a CSV file where each row is a single training activity. Let&#39;s load and inspect it. . # ... YOUR CODE FOR TASK 1 ... import numpy as np import pandas as pd # Define file containing dataset runkeeper_file = &#39;datasets/cardioActivities.csv&#39; # Create DataFrame with parse_dates and index_col parameters df_activities = pd.read_csv(runkeeper_file, parse_dates=[&#39;Date&#39;], index_col=[&#39;Date&#39;]) # First look at exported data: select sample of 3 random rows display(df_activities.sample(3)) # Print DataFrame summary # ... YOUR CODE FOR TASK 1 ... df_activities.info() . Activity Id Type Route Name Distance (km) Duration Average Pace Average Speed (km/h) Calories Burned Climb (m) Average Heart Rate (bpm) Friend&#39;s Tagged Notes GPX File . Date . 2016-11-21 18:57:32 dcb51374-c574-4fac-8f30-d2f2080368eb | Running | NaN | 10.05 | 56:45 | 5:39 | 10.63 | 704.0 | 96 | 146.0 | NaN | TomTom MySports Watch | 2016-11-21-185732.gpx | . 2015-06-21 17:53:46 ee566558-df2c-4874-8470-4c96bc16e11b | Cycling | NaN | 34.49 | 1:35:39 | 2:46 | 21.63 | 751.0 | 318 | NaN | NaN | NaN | 2015-06-21-175346.gpx | . 2017-05-30 18:19:20 58569994-61c8-400c-a647-114e161ff8df | Running | NaN | 8.42 | 42:48 | 5:05 | 11.80 | 584.0 | 85 | 154.0 | NaN | TomTom MySports Watch | 2017-05-30-181920.gpx | . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; DatetimeIndex: 508 entries, 2018-11-11 14:05:12 to 2012-08-22 18:53:54 Data columns (total 13 columns): Activity Id 508 non-null object Type 508 non-null object Route Name 1 non-null object Distance (km) 508 non-null float64 Duration 508 non-null object Average Pace 508 non-null object Average Speed (km/h) 508 non-null float64 Calories Burned 508 non-null float64 Climb (m) 508 non-null int64 Average Heart Rate (bpm) 294 non-null float64 Friend&#39;s Tagged 0 non-null float64 Notes 231 non-null object GPX File 504 non-null object dtypes: float64(5), int64(1), object(7) memory usage: 55.6+ KB . 2. Data preprocessing . Lucky for us, the column names Runkeeper provides are informative, and we don&#39;t need to rename any columns. . But, we do notice missing values using the info() method. What are the reasons for these missing values? It depends. Some heart rate information is missing because I didn&#39;t always use a cardio sensor. In the case of the Notes column, it is an optional field that I sometimes left blank. Also, I only used the Route Name column once, and never used the Friend&#39;s Tagged column. . We&#39;ll fill in missing values in the heart rate column to avoid misleading results later, but right now, our first data preprocessing steps will be to: . Remove columns not useful for our analysis. | Replace the &quot;Other&quot; activity type to &quot;Unicycling&quot; because that was always the &quot;Other&quot; activity. | Count missing values. | . cols_to_drop = [&#39;Friend &#39;s Tagged&#39;,&#39;Route Name&#39;,&#39;GPX File&#39;,&#39;Activity Id&#39;,&#39;Calories Burned&#39;, &#39;Notes&#39;] # Delete unnecessary columns # ... YOUR CODE FOR TASK 2 ... df_activities.drop(cols_to_drop, axis=1, inplace=True) # Count types of training activities display(df_activities[&#39;Type&#39;].value_counts()) # Rename &#39;Other&#39; type to &#39;Unicycling&#39; df_activities[&#39;Type&#39;] = df_activities[&#39;Type&#39;].str.replace(&#39;Other&#39;, &#39;Unicycling&#39;) # Count missing values for each column # ... YOUR CODE FOR TASK 2 ... df_activities.isnull().sum() . Running 459 Cycling 29 Walking 18 Other 2 Name: Type, dtype: int64 . Type 0 Distance (km) 0 Duration 0 Average Pace 0 Average Speed (km/h) 0 Climb (m) 0 Average Heart Rate (bpm) 214 dtype: int64 . 3. Dealing with missing values . As we can see from the last output, there are 214 missing entries for my average heart rate. . We can&#39;t go back in time to get those data, but we can fill in the missing values with an average value. This process is called mean imputation. When imputing the mean to fill in missing data, we need to consider that the average heart rate varies for different activities (e.g., walking vs. running). We&#39;ll filter the DataFrames by activity type (Type) and calculate each activity&#39;s mean heart rate, then fill in the missing values with those means. . avg_hr_run = df_activities[df_activities[&#39;Type&#39;] == &#39;Running&#39;][&#39;Average Heart Rate (bpm)&#39;].mean() avg_hr_cycle = df_activities[df_activities[&#39;Type&#39;] == &#39;Cycling&#39;][&#39;Average Heart Rate (bpm)&#39;].mean() # Split whole DataFrame into several, specific for different activities df_run = df_activities[df_activities[&#39;Type&#39;] == &#39;Running&#39;].copy() df_walk = df_activities[df_activities[&#39;Type&#39;] == &#39;Walking&#39;].copy() df_cycle = df_activities[df_activities[&#39;Type&#39;] == &#39;Cycling&#39;].copy() # Filling missing values with counted means df_walk[&#39;Average Heart Rate (bpm)&#39;].fillna(110, inplace=True) df_run[&#39;Average Heart Rate (bpm)&#39;].fillna(int(avg_hr_run), inplace=True) df_cycle[&#39;Average Heart Rate (bpm)&#39;].fillna(int(avg_hr_cycle), inplace=True) # ... YOUR CODE FOR TASK 3 ... # Count missing values for each column in running data # ... YOUR CODE FOR TASK 3 ... df_run.isnull().sum() . Type 0 Distance (km) 0 Duration 0 Average Pace 0 Average Speed (km/h) 0 Climb (m) 0 Average Heart Rate (bpm) 0 dtype: int64 . 4. Plot running data . Now we can create our first plot! As we found earlier, most of the activities in my data were running (459 of them to be exact). There are only 29, 18, and two instances for cycling, walking, and unicycling, respectively. So for now, let&#39;s focus on plotting the different running metrics. . An excellent first visualization is a figure with four subplots, one for each running metric (each numerical column). Each subplot will have a different y-axis, which is explained in each legend. The x-axis, Date, is shared among all subplots. . %matplotlib inline # Import matplotlib, set style and ignore warning import matplotlib.pyplot as plt %matplotlib inline import warnings plt.style.use(&#39;ggplot&#39;) warnings.filterwarnings( action=&#39;ignore&#39;, module=&#39;matplotlib.figure&#39;, category=UserWarning, message=(&#39;This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.&#39;) ) # Prepare data subsetting period from 2013 till 2018 runs_subset_2013_2018 = df_run[&#39;2018&#39;:&#39;2013&#39;] # Create, plot and customize in one step runs_subset_2013_2018.plot(subplots=True, sharex=False, figsize=(12,16), linestyle=&#39;none&#39;, marker=&#39;o&#39;, markersize=3, ) # Show plot # ... YOUR CODE FOR TASK 4 ... plt.show() . 5. Running statistics . No doubt, running helps people stay mentally and physically healthy and productive at any age. And it is great fun! When runners talk to each other about their hobby, we not only discuss our results, but we also discuss different training strategies. . You&#39;ll know you&#39;re with a group of runners if you commonly hear questions like: . What is your average distance? | How fast do you run? | Do you measure your heart rate? | How often do you train? | . Let&#39;s find the answers to these questions in my data. If you look back at plots in Task 4, you can see the answer to, Do you measure your heart rate? Before 2015: no. To look at the averages, let&#39;s only use the data from 2015 through 2018. . In pandas, the resample() method is similar to the groupby() method - with resample() you group by a specific time span. We&#39;ll use resample() to group the time series data by a sampling period and apply several methods to each sampling period. In our case, we&#39;ll resample annually and weekly. . runs_subset_2015_2018 = df_run[&#39;2018&#39;:&#39;2015&#39;] # Calculate annual statistics print(&#39;How my average run looks in last 4 years:&#39;) display(runs_subset_2015_2018.resample(&#39;A&#39;).mean()) # Calculate weekly statistics print(&#39;Weekly averages of last 4 years:&#39;) display(runs_subset_2015_2018.resample(&#39;W&#39;).mean().mean()) # Mean weekly counts weekly_counts_average = runs_subset_2015_2018[&#39;Distance (km)&#39;].resample(&#39;W&#39;).count().mean() print(&#39;How many trainings per week I had on average:&#39;, weekly_counts_average) . How my average run looks in last 4 years: . Distance (km) Average Speed (km/h) Climb (m) Average Heart Rate (bpm) . Date . 2015-12-31 13.602805 | 10.998902 | 160.170732 | 143.353659 | . 2016-12-31 11.411667 | 10.837778 | 133.194444 | 143.388889 | . 2017-12-31 12.935176 | 10.959059 | 169.376471 | 145.247059 | . 2018-12-31 13.339063 | 10.777969 | 191.218750 | 148.125000 | . Weekly averages of last 4 years: . Distance (km) 12.518176 Average Speed (km/h) 10.835473 Climb (m) 158.325444 Average Heart Rate (bpm) 144.801775 dtype: float64 . How many trainings per week I had on average: 1.5 . 6. Visualization with averages . Let&#39;s plot the long term averages of my distance run and my heart rate with their raw data to visually compare the averages to each training session. Again, we&#39;ll use the data from 2015 through 2018. . In this task, we will use matplotlib functionality for plot creation and customization. . runs_subset_2015_2018 = df_run[&#39;2018&#39;:&#39;2015&#39;] runs_distance = runs_subset_2015_2018[&#39;Distance (km)&#39;] runs_hr = runs_subset_2015_2018[&#39;Average Heart Rate (bpm)&#39;] # Create plot fig, (ax1, ax2) = plt.subplots(2, sharex=True, figsize=(12, 8)) # Plot and customize first subplot # ... YOUR CODE FOR TASK 6 ... runs_distance.plot(ax=ax1) ax1.set(ylabel=&#39;Distance (km)&#39;, title=&#39;Historical data with averages&#39;) ax1.axhline(runs_distance.mean(), color=&#39;blue&#39;, linewidth=1, linestyle=&#39;-.&#39;) # Plot and customize second subplot runs_hr.plot(ax=ax2, color=&#39;gray&#39;) ax2.set(xlabel=&#39;Date&#39;, ylabel=&#39;Average Heart Rate (bpm)&#39;) ax2.axhline(runs_hr.mean(), color=&#39;blue&#39;, linewidth=1, linestyle=&#39;-.&#39;) # ... YOUR CODE FOR TASK 6 ... # Show plot plt.show() . 7. Did I reach my goals? . To motivate myself to run regularly, I set a target goal of running 1000 km per year. Let&#39;s visualize my annual running distance (km) from 2013 through 2018 to see if I reached my goal each year. Only stars in the green region indicate success. . df_run_dist_annual = df_run[&#39;2018&#39;:&#39;2013&#39;][&#39;Distance (km)&#39;].resample(&#39;A&#39;).sum() # Create plot fig = plt.figure(figsize=(8, 5)) # Plot and customize ax = df_run_dist_annual.plot(marker=&#39;*&#39;, markersize=14, linewidth=0, color=&#39;blue&#39;) ax.set(ylim=[0, 1210], xlim=[&#39;2012&#39;,&#39;2019&#39;], ylabel=&#39;Distance (km)&#39;, xlabel=&#39;Years&#39;, title=&#39;Annual totals for distance&#39;) ax.axhspan(1000, 1210, color=&#39;green&#39;, alpha=0.4) ax.axhspan(800, 1000, color=&#39;yellow&#39;, alpha=0.3) ax.axhspan(0, 800, color=&#39;red&#39;, alpha=0.3) # ... YOUR CODE FOR TASK 7 ... # Show plot # ... YOUR CODE FOR TASK 7 ... plt.show() . 8. Am I progressing? . Let&#39;s dive a little deeper into the data to answer a tricky question: am I progressing in terms of my running skills? . To answer this question, we&#39;ll decompose my weekly distance run and visually compare it to the raw data. A red trend line will represent the weekly distance run. . We are going to use statsmodels library to decompose the weekly trend. . # ... YOUR CODE FOR TASK 8 ... import statsmodels.api as sm # Prepare data df_run_dist_wkly = df_run[&#39;2018&#39;:&#39;2013&#39;][&#39;Distance (km)&#39;].resample(&#39;W&#39;).bfill() decomposed = sm.tsa.seasonal_decompose(df_run_dist_wkly, extrapolate_trend=1, freq=52) # Create plot fig = plt.figure(figsize=(12, 5)) # Plot and customize ax = decomposed.trend.plot(label=&#39;Trend&#39;, linewidth=2) ax = decomposed.observed.plot(label=&#39;Observed&#39;, linewidth=0.5) ax.legend() ax.set_title(&#39;Running distance trend&#39;) # Show plot plt.show() . /usr/local/lib/python3.6/dist-packages/matplotlib/figure.py:2369: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect. warnings.warn(&#34;This figure includes Axes that are not compatible &#34; . 9. Training intensity . Heart rate is a popular metric used to measure training intensity. Depending on age and fitness level, heart rates are grouped into different zones that people can target depending on training goals. A target heart rate during moderate-intensity activities is about 50-70% of maximum heart rate, while during vigorous physical activity it’s about 70-85% of maximum. . We&#39;ll create a distribution plot of my heart rate data by training intensity. It will be a visual presentation for the number of activities from predefined training zones. . hr_zones = [100, 125, 133, 142, 151, 173] zone_names = [&#39;Easy&#39;, &#39;Moderate&#39;, &#39;Hard&#39;, &#39;Very hard&#39;, &#39;Maximal&#39;] zone_colors = [&#39;green&#39;, &#39;yellow&#39;, &#39;orange&#39;, &#39;tomato&#39;, &#39;red&#39;] df_run_hr_all = df_run[df_run.index &gt;= &#39;2015-03-01&#39;][&#39;Average Heart Rate (bpm)&#39;] # Create plot fig, ax = plt.subplots(figsize=(8, 5)) # Plot and customize n, bins, patches = ax.hist(df_run_hr_all, bins=hr_zones, alpha=0.5) for i in range(0, len(patches)): patches[i].set_facecolor(zone_colors[i]) ax.set(title=&#39;Distribution of HR&#39;, ylabel=&#39;Number of runs&#39;) ax.xaxis.set(ticks=hr_zones) # ... YOUR CODE FOR TASK 9 ... ax.set_xticklabels(labels=zone_names, rotation=-30, ha=&#39;left&#39;) # Show plot # ... YOUR CODE FOR TASK 8 ... plt.show() . /usr/local/lib/python3.6/dist-packages/matplotlib/figure.py:2369: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect. warnings.warn(&#34;This figure includes Axes that are not compatible &#34; . 10. Detailed summary report . With all this data cleaning, analysis, and visualization, let&#39;s create detailed summary tables of my training. . To do this, we&#39;ll create two tables. The first table will be a summary of the distance (km) and climb (m) variables for each training activity. The second table will list the summary statistics for the average speed (km/hr), climb (m), and distance (km) variables for each training activity. . df_run_walk_cycle = df_run.append([df_walk, df_cycle]).sort_index(ascending=False) dist_climb_cols, speed_col = [&#39;Distance (km)&#39;, &#39;Climb (m)&#39;], [&#39;Average Speed (km/h)&#39;] # Calculating total distance and climb in each type of activities df_totals = df_run_walk_cycle.groupby(&#39;Type&#39;)[dist_climb_cols].sum() print(&#39;Totals for different training types:&#39;) display(df_totals) # Calculating summary statistics for each type of activities df_summary = df_run_walk_cycle.groupby(&#39;Type&#39;)[dist_climb_cols + speed_col].describe() # Combine totals with summary for i in dist_climb_cols: df_summary[i, &#39;total&#39;] = df_totals[i] print(&#39;Summary statistics for different training types:&#39;) # ... YOUR CODE FOR TASK 10 ... df_summary.stack() . Totals for different training types: . Distance (km) Climb (m) . Type . Cycling 680.58 | 6976 | . Running 5224.50 | 57278 | . Walking 33.45 | 349 | . Summary statistics for different training types: . Average Speed (km/h) Climb (m) Distance (km) . Type . Cycling 25% 16.980000 | 139.000000 | 15.530000 | . 50% 19.500000 | 199.000000 | 20.300000 | . 75% 21.490000 | 318.000000 | 29.400000 | . count 29.000000 | 29.000000 | 29.000000 | . max 24.330000 | 553.000000 | 49.180000 | . mean 19.125172 | 240.551724 | 23.468276 | . min 11.380000 | 58.000000 | 11.410000 | . std 3.257100 | 128.960289 | 9.451040 | . total NaN | 6976.000000 | 680.580000 | . Running 25% 10.495000 | 54.000000 | 7.415000 | . 50% 10.980000 | 91.000000 | 10.810000 | . 75% 11.520000 | 171.000000 | 13.190000 | . count 459.000000 | 459.000000 | 459.000000 | . max 20.720000 | 982.000000 | 38.320000 | . mean 11.056296 | 124.788671 | 11.382353 | . min 5.770000 | 0.000000 | 0.760000 | . std 0.953273 | 103.382177 | 4.937853 | . total NaN | 57278.000000 | 5224.500000 | . Walking 25% 5.555000 | 7.000000 | 1.385000 | . 50% 5.970000 | 10.000000 | 1.485000 | . 75% 6.512500 | 15.500000 | 1.787500 | . count 18.000000 | 18.000000 | 18.000000 | . max 6.910000 | 112.000000 | 4.290000 | . mean 5.549444 | 19.388889 | 1.858333 | . min 1.040000 | 5.000000 | 1.220000 | . std 1.459309 | 27.110100 | 0.880055 | . total NaN | 349.000000 | 33.450000 | . 11. Fun facts . To wrap up, let’s pick some fun facts out of the summary tables and solve the last exercise. . These data (my running history) represent 6 years, 2 months and 21 days. And I remember how many running shoes I went through–7. . FUN FACTS - Average distance: 11.38 km - Longest distance: 38.32 km - Highest climb: 982 m - Total climb: 57,278 m - Total number of km run: 5,224 km - Total runs: 459 - Number of running shoes gone through: 7 pairs . The story of Forrest Gump is well known–the man, who for no particular reason decided to go for a &quot;little run.&quot; His epic run duration was 3 years, 2 months and 14 days (1169 days). In the picture you can see Forrest’s route of 24,700 km. . FORREST RUN FACTS - Average distance: 21.13 km - Total number of km run: 24,700 km - Total runs: 1169 - Number of running shoes gone through: ... . Assuming Forest and I go through running shoes at the same rate, figure out how many pairs of shoes Forrest needed for his run. . . average_shoes_lifetime = 5224 # Count number of shoes for Forrest&#39;s run distance shoes_for_forrest_run = 24700/average_shoes_lifetime print(&#39;Forrest Gump would need {} pairs of shoes!&#39;.format(shoes_for_forrest_run)) . Forrest Gump would need 4.728177641653905 pairs of shoes! .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2022/03/21/Analyze-Your-Runkeeper-Fitness-Data.html",
            "relUrl": "/datacamp/projects/python/2022/03/21/Analyze-Your-Runkeeper-Fitness-Data.html",
            "date": " • Mar 21, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Writing Functions for Product Analysis",
            "content": "1. DRY: Don&#39;t repeat yourself . Have you ever started your data analysis and ended up with repetitive code? Our colleague Brenda who works as a Product Analyst, has found herself in this situation and has asked us for some help. She&#39;s written a script to pull Net Promotor Score (NPS) data from various sources. NPS works by asking How likely is it that you would recommend our product to a friend or colleague? with a rating scale of 0 to 10. Brenda has set up this NPS survey in various ways, including emails and pop-ups on the mobile app and website. To compile the data from the different sources, she&#39;s written the following code: . # Read the NPS email responses into a DataFrame email = pd.read_csv(&quot;datasets/2020Q4_nps_email.csv&quot;) # Add a column to record the source email[&#39;source&#39;] = &#39;email&#39; # Repeat for NPS mobile and web responses mobile = pd.read_csv(&quot;datasets/2020Q4_nps_mobile.csv&quot;) mobile[&#39;source&#39;] = &#39;mobile&#39; web = pd.read_csv(&quot;datasets/2020Q4_nps_web.csv&quot;) web[&#39;source&#39;] = &#39;web&#39; # Combine the DataFrames q4_nps = pd.concat([email,mobile,web]) . This results in the DataFrame q4_nps that looks like this: . response_date user_id nps_rating source . 0 | 2020-10-29 | 36742 | 2 | email | . 1 | 2020-11-26 | 31851 | 10 | email | . 2 | 2020-10-27 | 44299 | 10 | email | . … | … | … | … | … | . This code works, but it violates the Don&#39;t Repeat Yourself (DRY) programming principle. Brenda repeats the same code for email, mobile, and web, except with different variable names and file names. While it&#39;s often quicker to copy and paste, it makes it easier to introduce errors. For example, if you need to edit one of those lines, you have to do it in multiple places. Enter functions! Repeated code is a sign that we need functions. Let&#39;s write a function for Brenda. . import pandas as pd # Write a function that matches the docstring def convert_csv_to_df(csv_name, source_type): &quot;&quot;&quot; Converts an NPS CSV into a DataFrame with a column for the source. Args: csv_name (str): The name of the NPS CSV file. source_type (str): The source of the NPS responses. Returns: A DataFrame with the CSV data and a column, source. &quot;&quot;&quot; df = pd.read_csv(csv_name) df[&#39;source&#39;] = source_type return df # Test the function on the mobile data convert_csv_to_df(&quot;datasets/2020Q4_nps_mobile.csv&quot;, &quot;mobile&quot;) . response_date user_id nps_rating source . 0 2020-12-29 | 14178 | 3 | mobile | . 1 2020-10-29 | 33221 | 1 | mobile | . 2 2020-11-01 | 21127 | 10 | mobile | . 3 2020-12-07 | 42894 | 3 | mobile | . 4 2020-11-26 | 30501 | 5 | mobile | . ... ... | ... | ... | ... | . 1796 2020-12-29 | 49529 | 3 | mobile | . 1797 2020-12-24 | 23671 | 7 | mobile | . 1798 2020-11-28 | 39954 | 7 | mobile | . 1799 2020-12-19 | 21098 | 7 | mobile | . 1800 2020-12-23 | 14919 | 7 | mobile | . 1801 rows × 4 columns . 2. Verifying the files with the &quot;with&quot; keyword . Excellent, we have a function that reads and cleans Brenda&#39;s CSVs precisely the way she needs! She can call this function in the future for as many different sources as she wants. Before we combine the NPS DataFrames, we want to add a function that verifies that the files inputted are valid. Each of these NPS dataset files should have three columns: response_date, user_id, nps_rating. Previously, Brenda would check this manually by opening each file. . Let&#39;s write a function that uses the context manager with open() so that we properly close the files we open, even if an exception is raised. If we don&#39;t use the with keyword with open() , we would need to call close() after we&#39;re done with the file. Even then, it&#39;s risky because an error might be raised before the close() functions are called. . The function will return True if the file contains the right columns. Otherwise, it will return False. To test the function, we&#39;ll use datasets/corrupted.csv to simulate a corrupted invalid NPS file. . def check_csv(csv_name): &quot;&quot;&quot; Checks if a CSV has three columns: response_date, user_id, nps_rating Args: csv_name (str): The name of the CSV file. Returns: Boolean: True if the CSV is valid, False otherwise &quot;&quot;&quot; # Open csv_name as f using with open with open(csv_name, &#39;r&#39;) as f: first_line = f.readline() # Return true if the CSV has the three specified columns if first_line == &quot;response_date,user_id,nps_rating n&quot;: return True # Otherwise, return false else: return False # Test the function on a corrupted NPS file check_csv(&#39;datasets/corrupted.csv&#39;) . False . 3. Putting it together with nested functions . Alright, we now have one function that verifies that the CSVs are valid and another that converts them into the DataFrame format needed by Brenda. What&#39;s left? Looking at the script, this is the last line we haven&#39;t covered: q4_nps = pd.concat([email,mobile,web]). We could use this line of code, but we&#39;ll see more code repetition if we get CSVs from other sources or time periods. . To make sure our code is scalable, we&#39;re going to write a function called combine_nps_csvs() that takes in a dictionary. Python dictionaries have key:value pairs. In our case, the CSV&#39;s name and source type will be the key and value, respectively. That way, we can define a dictionary with as many NPS files as we have and run it through combine_nps_csvs(). For each file, we&#39;ll check that it&#39;s valid using check_csv(), and if it is, we&#39;ll use convert_csv_to_df() to convert it into a DataFrame. At the start of the function, we&#39;ll define an empty DataFrame called combined and everytime a CSV is succesfully converted, we&#39;ll concatenate it to combined. . def combine_nps_csvs(csvs_dict): # Define combine as an empty DataFrame combined = pd.DataFrame() # Iterate over csvs_dict to get the name and source of the CSVs for fname, source in csvs_dict.items(): # Check if the csv is valid using check_csv() if check_csv(fname): # Convert the CSV using convert_csv_to_df() and assign it to temp temp = convert_csv_to_df(fname, source) # Concatenate combined and temp and assign it to combined combined = combined.append(temp) # If the file is not valid, print a message with the CSV&#39;s name else: print(fname + &quot; is not a valid file and will not be added.&quot;) # Return the combined DataFrame return combined my_files = { &quot;datasets/2020Q4_nps_email.csv&quot;: &quot;email&quot;, &quot;datasets/2020Q4_nps_mobile.csv&quot;: &quot;mobile&quot;, &quot;datasets/2020Q4_nps_web.csv&quot;: &quot;web&quot;, &quot;datasets/corrupted.csv&quot;: &quot;social_media&quot; } # Test the function on the my_files dictionary combine_nps_csvs(my_files) . datasets/corrupted.csv is not a valid file and will not be added. . response_date user_id nps_rating source . 0 2020-11-06 | 11037 | 7 | email | . 1 2020-12-24 | 34434 | 9 | email | . 2 2020-12-03 | 49547 | 8 | email | . 3 2020-10-04 | 13821 | 7 | email | . 4 2020-10-23 | 29407 | 9 | email | . ... ... | ... | ... | ... | . 2285 2020-12-25 | 10656 | 8 | web | . 2286 2020-11-07 | 32918 | 10 | web | . 2287 2020-10-16 | 15667 | 10 | web | . 2288 2020-11-20 | 47153 | 7 | web | . 2289 2020-10-17 | 47071 | 5 | web | . 6043 rows × 4 columns . 4. Detractors, Passives, and Promoters . We&#39;ve summarized our colleague&#39;s script into one function: combine_nps_csvs()! Let&#39;s move on to analyzing the NPS data, such as actually calculating NPS. As a reminder, NPS works by asking How likely is it that you would recommend our product to a friend or colleague? with a rating scale of 0 to 10. . NPS ratings are categorized into three groups. Ratings between 0 to 6 are detractors, ratings between 7 to 8 are passives, and finally, ratings 9 to 10 are promoters. There&#39;s more to analyzing NPS, but remember, functions should be small in scope and should just &quot;do one thing&quot;. So before we get ahead of ourselves, let&#39;s write a simple function that takes an NPS rating and categorizes it into the appropriate group. . def categorize_nps(x): &quot;&quot;&quot; Takes a NPS rating and outputs whether it is a &quot;promoter&quot;, &quot;passive&quot;, &quot;detractor&quot;, or &quot;invalid&quot; rating. &quot;invalid&quot; is returned when the rating is not between 0-10. Args: x: The NPS rating Returns: String: the NPS category or &quot;invalid&quot;. &quot;&quot;&quot; # Write the rest of the function to match the docstring if x &gt;= 0 and x &lt; 7: return &quot;detractor&quot; elif x &gt;= 7 and x &lt; 9: return &quot;passive&quot; elif x &gt;= 9 and x &lt; 11: return &quot;promoter&quot; else: return &quot;invalid&quot; # Test the function categorize_nps(8) . &#39;passive&#39; . 5. Applying our function to a DataFrame . So we have a function that takes a score and outputs which NPS response group it belongs to. It would be great to have this as a column in our NPS DataFrames, similar to the source column we added. Since we&#39;ve modularized our code with functions, all we need to do is edit our convert_cvs_to_df() function and nest categorize_nps() into it. However, the way we&#39;ll nest categorize_nps() will be different than previous times. The pandas library has a handy function called apply(), which lets us apply a function to each column or row of a DataFrame. . def convert_csv_to_df(csv_name, source_type): &quot;&quot;&quot; Convert an NPS CSV into a DataFrame with columns for the source and NPS group. Args: csv_name (str): The name of the NPS CSV file. source_type (str): The source of the NPS responses. Returns: A DataFrame with the CSV data and columns: source and nps_group. &quot;&quot;&quot; df = pd.read_csv(csv_name) df[&#39;source&#39;] = source_type # Define a new column nps_group which applies categorize_nps to nps_rating df[&#39;nps_group&#39;] = df[&#39;nps_rating&#39;].apply(categorize_nps) return df # Test the updated function with mobile data convert_csv_to_df(&quot;datasets/2020Q4_nps_mobile.csv&quot;, &quot;mobile&quot;) . response_date user_id nps_rating source nps_group . 0 2020-12-29 | 14178 | 3 | mobile | detractor | . 1 2020-10-29 | 33221 | 1 | mobile | detractor | . 2 2020-11-01 | 21127 | 10 | mobile | promoter | . 3 2020-12-07 | 42894 | 3 | mobile | detractor | . 4 2020-11-26 | 30501 | 5 | mobile | detractor | . ... ... | ... | ... | ... | ... | . 1796 2020-12-29 | 49529 | 3 | mobile | detractor | . 1797 2020-12-24 | 23671 | 7 | mobile | passive | . 1798 2020-11-28 | 39954 | 7 | mobile | passive | . 1799 2020-12-19 | 21098 | 7 | mobile | passive | . 1800 2020-12-23 | 14919 | 7 | mobile | passive | . 1801 rows × 5 columns . 6. Calculating the Net Promoter Score . If we hadn&#39;t broken down our code into functions earlier, we would&#39;ve had to edit our code in multiple places to add a nps_group column, increasing the chance of introducing errors. It also helps that our functions have one responsibility keeping our code flexible and easier to edit and debug. . Now we&#39;re in a good place to calculate the Net Promoter Score! This is calculated by subtracting the percentage of detractor ratings from the percentage of promoter ratings, in other words: . $ NPS = frac{ text{# of Promoter Rating - # of Detractor Ratings}}{ text{Total # of Respondents}} * 100 $ . We want to calculate the NPS across all sources, so we&#39;ll use combine_nps_csvs() from Task 3 to consolidate the source files. As expected, that will output a DataFrame which we&#39;ll use as an input for a new function we&#39;re going to write, calculate_nps(). . def calculate_nps(df): # Calculate the NPS score using the nps_group column ratings = df[&#39;nps_group&#39;].value_counts() nps = (ratings[&#39;promoter&#39;] - ratings[&#39;detractor&#39;]) / df.shape[0] * 100 # Return the NPS Score return nps my_files = { &quot;datasets/2020Q4_nps_email.csv&quot;: &quot;email&quot;, &quot;datasets/2020Q4_nps_web.csv&quot;: &quot;web&quot;, &quot;datasets/2020Q4_nps_mobile.csv&quot;: &quot;mobile&quot;, } # Test the function on the my_files dictionary q4_nps = combine_nps_csvs(my_files) calculate_nps(q4_nps) . 9.995035578355122 . 7. Breaking down NPS by source . Is it good to have an NPS score around 10? The worst NPS score you can get is -100 when all respondents are detractors, and the best is 100 when all respondents are promoters. Depending on the industry of your service or product, average NPS scores vary a lot. However, a negative score is a bad sign because it means you have more unhappy customers than happy customers. Typically, a score over 50 is considered excellent, and above 75 is considered best in class. . Although our score is above 0, it&#39;s still on the lower end of the spectrum. The product team concludes that majorly increasing NPS across our customer base is a priority. Luckily, we have this NPS data that we can analyze more so we can find data-driven solutions. A good start would be breaking down the NPS score by the source type. For instance, if people are rating lower on the web than mobile, that&#39;s some evidence we need to improve the browser experience. . def calculate_nps_by_source(nps_df): # Group the DataFrame by source and apply calculate_nps() x = nps_df.groupby([&#39;source&#39;]).apply(calculate_nps) # Return a series with the NPS scores broken by source return x my_files = { &quot;datasets/2020Q4_nps_email.csv&quot;: &quot;email&quot;, &quot;datasets/2020Q4_nps_web.csv&quot;: &quot;web&quot;, &quot;datasets/2020Q4_nps_mobile.csv&quot;: &quot;mobile&quot;, } # Test the function on the my_files dictionary q4_nps = combine_nps_csvs(my_files) calculate_nps_by_source(q4_nps) . source email 18.596311 mobile -14.714048 web 22.096070 dtype: float64 . 8. Adding docstrings . Interesting! The mobile responses have an NPS score of about -15, which is noticeably lower than the other two sources. There are few ways we could continue our analysis from here. We could use the column user_id to reach out to users who rated poorly on the mobile app for user interviews. We could also breakdown NPS by source and date to see if there was a date where NPS started clearly decreasing - perhaps the same time there was a bug or feature realeased. With the functions we created, Brenda is in a good place to continue this work! . The last thing we&#39;ll discuss is docstrings. In Task 1, 2, 4 and 5, we included docstrings for convert_csv_to_df(), check_csv(), and categorize_nps(). However, we should include docstrings for all the functions we write so that others can better re-use and maintain our code. Docstrings tell readers what a function does, its arguments, its return value(s) if any, and any other useful information you want to include, like error handling. There are several standards for writing docstrings in Python, including: Numpydoc, Google-style (chosen style in this notebook), and reStructuredText. . To make sure Brenda and other colleagues can follow our work, we are going to add docstrings to the remaining undocumented functions: combine_nps_csvs(), calculate_nps(), and calculate_nps_by_source. It&#39;s up to you how you want to write the docstrings - we&#39;ll only check that a docstring exists for each of these functions. . def combine_nps_csvs(csvs_dict): # Add docstring &quot;&quot;&quot; Takes a dictonary of csvs and concatenates it. Parameters - csvs_dict : dict dictionary of csv filenames Returns - combined : DataFrame combined Dataframe &quot;&quot;&quot; # Define combine as an empty DataFrame combined = pd.DataFrame() # Iterate over csvs_dict to get the name and source of the CSVs for fname, source in csvs_dict.items(): # Check if the csv is valid using check_csv() if check_csv(fname): # Convert the CSV using convert_csv_to_df() and assign it to temp temp = convert_csv_to_df(fname, source) # Concatenate combined and temp and assign it to combined combined = combined.append(temp) # If the file is not valid, print a message with the CSV&#39;s name else: print(fname + &quot; is not a valid file and will not be added.&quot;) # Return the combined DataFrame return combined # Copy and paste your code for the function from Task 6 def calculate_nps(df): # Add Docstring &quot;&quot;&quot; Calculates the net promotor score Parameters - df : DataFrame The Dataframe which contains all the values Returns - score : float Net Promotor score value &quot;&quot;&quot; # Calculate the NPS score using the nps_group column score = ((df[&#39;nps_group&#39;] == &#39;promoters&#39;).sum() - (df[&#39;nps_group&#39;] == &#39;detractors&#39;).sum()) / len(df) # Return the NPS Score return score # Copy and paste your code for the function from Task 7 def calculate_nps_by_source(df): # Add Docstring &quot;&quot;&quot; Calculates the nps score by grouping Parameters - df : DataFrame Dataframe which contains all the values Returns - nps_scores : DataFrame Grouped NPS Score &quot;&quot;&quot; # Group the DataFrame by source and apply calculate_nps() nps_scores = df.groupby(&#39;source&#39;).apply(calculate_nps) # Return a Series with the NPS scores broken by source return nps_scores .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2022/03/14/Writing-Functions-for-Product-Analysis.html",
            "relUrl": "/datacamp/projects/python/2022/03/14/Writing-Functions-for-Product-Analysis.html",
            "date": " • Mar 14, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Reporting on sales data",
            "content": "Reporting on sales data . Now let&#39;s now move on to the competition and challenge. . &#128214; Background . You work in the accounting department of a company that sells motorcycle parts. The company operates three warehouses in a large metropolitan area. . You’ve recently learned data manipulation and plotting, and suggest helping your colleague analyze past sales data. Your colleague wants to capture sales by payment method. She also needs to know the average unit price for each product line. . &#128190; The data . The sales data has the following fields: . &quot;date&quot; - The date, from June to August 2021. | &quot;warehouse&quot; - The company operates three warehouses: North, Central, and West. | &quot;client_type&quot; - There are two types of customers: Retail and Wholesale. | &quot;product_line&quot; - Type of products purchased. | &quot;quantity&quot; - How many items were purchased. | &quot;unit_price&quot; - Price per item sold. | &quot;total&quot; - Total sale = quantity * unit_price. | &quot;payment&quot; - How the client paid: Cash, Credit card, Transfer. | . &#128170; Challenge . Create a report to answer your colleague&#39;s questions. Include: . What are the total sales for each payment method? | What is the average unit price for each product line? | Create plots to visualize findings for questions 1 and 2. | [Optional] Investigate further (e.g., average purchase value by client type, total purchase value by product line, etc.) | Summarize your findings. | Using the techniques of data analysis, preprocessing, and visualizations. . &#128218; LOAD PACKAGES . we will be loading all the packages which are required to our analysis . import numpy as np import pandas as pd import seaborn as sns import plotly.express as px from matplotlib import pyplot as plt . %matplotlib inline plt.rcParams[&#39;figure.figsize&#39;] = (12, 7) . &#128193; Load the Dataframe . The sales data is present at the location data/sales_data.csv, the columns attributes are described above. . sales = pd.read_csv(&#39;./data/sales_data.csv&#39;, parse_dates=[&#39;date&#39;]) sales.head() . date warehouse client_type product_line quantity unit_price total payment . 0 2021-06-01 | Central | Retail | Miscellaneous | 8 | 16.85 | 134.83 | Credit card | . 1 2021-06-01 | North | Retail | Breaking system | 9 | 19.29 | 173.61 | Cash | . 2 2021-06-01 | North | Retail | Suspension &amp; traction | 8 | 32.93 | 263.45 | Credit card | . 3 2021-06-01 | North | Wholesale | Frame &amp; body | 16 | 37.84 | 605.44 | Transfer | . 4 2021-06-01 | Central | Retail | Engine | 2 | 60.48 | 120.96 | Credit card | . As, we can see that there are about 8 columns, with names which are self-explanatory . &#128202; Exploratory Data Analysis . sales.info() sales.describe() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 1000 entries, 0 to 999 Data columns (total 8 columns): # Column Non-Null Count Dtype -- -- 0 date 1000 non-null object 1 warehouse 1000 non-null object 2 client_type 1000 non-null object 3 product_line 1000 non-null object 4 quantity 1000 non-null int64 5 unit_price 1000 non-null float64 6 total 1000 non-null float64 7 payment 1000 non-null object dtypes: float64(2), int64(1), object(5) memory usage: 62.6+ KB . quantity unit_price total . count 1000.000000 | 1000.000000 | 1000.000000 | . mean 9.395000 | 30.322040 | 289.113000 | . std 9.659207 | 12.256488 | 345.227596 | . min 1.000000 | 10.030000 | 10.350000 | . 25% 4.000000 | 21.085000 | 93.687500 | . 50% 6.500000 | 28.570000 | 178.360000 | . 75% 10.000000 | 37.917500 | 321.690000 | . max 40.000000 | 66.620000 | 2546.330000 | . There are a total of 1000 entries of the sales data, with no missing values in any of the columns . Now, Let&#39;s check about the duplicate values in the data . dups = sales[sales.duplicated()] print(f&quot;Number of duplicate values in the data are: {len(dups)}&quot;) . Number of duplicate values in the data are: 0 . Let&#39;s make the histogram of the numeric variables, to understand it&#39;s distribution much better . num_cols = [col for col in sales.columns if sales[col].dtype in [&#39;float64&#39;, &#39;int64&#39;]] fig, ax = plt.subplots(1, 3) fig.suptitle(&quot;Distribution of Numeric variables&quot;) for i, col in enumerate(num_cols): ax[i].set_xlabel(col.capitalize()) sns.histplot(x=col, data=sales, ax=ax[i], kde=True) . Looks like, the distributions of all numeric values are left skewed, log transformation will make it much better and suitable as a feature for machine learning modelling, if needed after the analysis. . &#10067; Question 1: Sales based on Payments? . The first question is: What are the total sales for each payment method? In this, I will be using the viz to see how the sales vary on the mode of payments. . &#128221; Answer 1 . sales_on_payments = sales.groupby(&#39;payment&#39;).agg({&#39;total&#39;: &#39;sum&#39;}).reset_index() sns.barplot(x=&#39;payment&#39;, y=&#39;total&#39;, data=sales_on_payments) plt.xlabel(&quot;Mode of Payment&quot;, fontdict={&#39;fontsize&#39;: 15}) plt.ylabel(&quot;Sales Amount&quot;, fontdict={&#39;fontsize&#39;: 15}) plt.title(&quot;Sales based on Type of Payments&quot;, fontdict={&#39;fontsize&#39;: 20}) . Text(0.5, 1.0, &#39;Sales based on Type of Payments&#39;) . total_sales = sales_on_payments[&#39;total&#39;].sum() print(&quot;Sales in individual payments&quot;) print(sales_on_payments) (sales_on_payments.set_index(&#39;payment&#39;, drop=True) / total_sales) * 100 . Sales in individual payments payment total 0 Cash 19199.10 1 Credit card 110271.57 2 Transfer 159642.33 . total . payment . Cash 6.640691 | . Credit card 38.141339 | . Transfer 55.217970 | . It&#39;s seems quite obvious, from the numbers that most of the payments are in the form of Transfer&#39;s(either Bank Trnsfers or Wallets Transfers), which is a little more than 50% followed by Credit Card(38%), and the least mode of payments is the Cash, approx 7% . &#10067; Question 2: Average Price of Product lines? . The second question is: What is the average unit price for each product line? In this, I will be using the viz to see average unit price of various product lines. . &#128221; Answer 2 . price_on_product_line = sales.groupby(&#39;product_line&#39;).agg({&#39;unit_price&#39;: &#39;mean&#39;}).reset_index() sns.barplot(x=&#39;product_line&#39;, y=&#39;unit_price&#39;, data=price_on_product_line) plt.xlabel(&quot;Type of Product Line&quot;, fontdict={&#39;fontsize&#39;: 15}) plt.ylabel(&quot;Avg. Unit Price&quot;, fontdict={&#39;fontsize&#39;: 15}) plt.title(&quot;Average Price per Product line&quot;, fontdict={&#39;fontsize&#39;: 20}) . Text(0.5, 1.0, &#39;Average Price per Product line&#39;) . price_on_product_line.sort_values([&#39;unit_price&#39;], ascending=False) . product_line unit_price . 2 Engine | 60.091803 | . 3 Frame &amp; body | 42.832229 | . 5 Suspension &amp; traction | 33.969868 | . 1 Electrical system | 25.585130 | . 4 Miscellaneous | 22.810738 | . 0 Breaking system | 17.740522 | . The Product Line with the highest Unit Price is the Engine followed by Frame &amp; Body, Suspension &amp; Traction, and with the least Price is the Breaking System. . My intution is that, the product which is most repaired/most sold will be at lower price as the demand is huge and vice versa. . May or May not be true, which can be found from some extra analysis . &#10067; Question 3: Average Price of Product lines? . The third question is: Create plots to visualize findings for questions 1 and 2 I have already done these in the previous task. . &#128221; Answer 3 . &#10067; Question 4: eXtend your investigation . The fourth question is: Investigate further (e.g., average purchase value by client type, total purchase value by product line, etc.) . This is an Optional Question . def plot_columns(cat_col, num_col, agg_func): cat_on_num = sales.groupby(cat_col).agg({num_col: agg_func}).reset_index() sns.barplot(x=cat_col, y=num_col, data=cat_on_num) plt.xlabel(cat_col.capitalize(), fontdict={&#39;fontsize&#39;: 15}) plt.ylabel(f&quot;{agg_func.capitalize()} of {num_col.capitalize()}&quot;, fontdict={&#39;fontsize&#39;: 15}) plt.title(f&quot;{cat_col.capitalize()} vs {num_col.capitalize()}({agg_func.capitalize()})&quot;, fontdict={&#39;fontsize&#39;: 20}) . &#128221; Answer 4 . plot_columns(&#39;client_type&#39;, &#39;quantity&#39;, &#39;mean&#39;) . plot_columns(&#39;product_line&#39;, &#39;quantity&#39;, &#39;mean&#39;) . &#10067; Question 5: Write Report . The fifth question is: Summarize your findings. . &#128221; Answer 5 .",
            "url": "https://anuraganalog.github.io/blog/datacamp/competition/python/notebook/jupyter/workspace/reporting/true/sales/data/2021/12/15/Reporting-on-sales-data.html",
            "relUrl": "/datacamp/competition/python/notebook/jupyter/workspace/reporting/true/sales/data/2021/12/15/Reporting-on-sales-data.html",
            "date": " • Dec 15, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Reducing the number of high fatality accidents",
            "content": "Reducing the number of high fatality accidents . &#128214; Background . You work for the road safety team within the department of transport and are looking into how they can reduce the number of major incidents. The safety team classes major incidents as fatal accidents involving 3+ casualties. They are trying to learn more about the characteristics of these major incidents so they can brainstorm interventions that could lower the number of deaths. They have asked for your assistance with answering a number of questions. . &#128190; The data . The reporting department have been collecting data on every accident that is reported. They&#39;ve included this along with a lookup file for 2020&#39;s accidents. . Published by the department for transport. https://data.gov.uk/dataset/road-accidents-safety-data Contains public sector information licensed under the Open Government Licence v3.0. . import pandas as pd accidents = pd.read_csv(r&#39;./data/accident-data.csv&#39;) accidents.head() . accident_index accident_year accident_reference longitude latitude accident_severity number_of_vehicles number_of_casualties date day_of_week ... second_road_class second_road_number pedestrian_crossing_human_control pedestrian_crossing_physical_facilities light_conditions weather_conditions road_surface_conditions special_conditions_at_site carriageway_hazards urban_or_rural_area . 0 2020010219808 | 2020 | 10219808 | -0.254001 | 51.462262 | 3.0 | 1.0 | 1.0 | 04/02/2020 | 3.0 | ... | 6.0 | 0.0 | 9.0 | 9.0 | 1.0 | 9.0 | 9.0 | 0.0 | 0.0 | 1.0 | . 1 2020010220496 | 2020 | 10220496 | -0.139253 | 51.470327 | 3.0 | 1.0 | 2.0 | 27/04/2020 | 2.0 | ... | 6.0 | 0.0 | 0.0 | 4.0 | 1.0 | 1.0 | 1.0 | 0.0 | 0.0 | 1.0 | . 2 2020010228005 | 2020 | 10228005 | -0.178719 | 51.529614 | 3.0 | 1.0 | 1.0 | 01/01/2020 | 4.0 | ... | 6.0 | 0.0 | 0.0 | 0.0 | 4.0 | 1.0 | 2.0 | 0.0 | 0.0 | 1.0 | . 3 2020010228006 | 2020 | 10228006 | -0.001683 | 51.541210 | 2.0 | 1.0 | 1.0 | 01/01/2020 | 4.0 | ... | 6.0 | 0.0 | 0.0 | 4.0 | 4.0 | 1.0 | 1.0 | 0.0 | 0.0 | 1.0 | . 4 2020010228011 | 2020 | 10228011 | -0.137592 | 51.515704 | 3.0 | 1.0 | 2.0 | 01/01/2020 | 4.0 | ... | 5.0 | 0.0 | 0.0 | 0.0 | 4.0 | 1.0 | 1.0 | 0.0 | 0.0 | 1.0 | . 5 rows × 27 columns . lookup = pd.read_csv(r&#39;./data/road-safety-lookups.csv&#39;) lookup.head() . table field name code/format label note . 0 Accident | accident_index | NaN | NaN | unique value for each accident. The accident_i... | . 1 Accident | accident_year | NaN | NaN | NaN | . 2 Accident | accident_reference | NaN | NaN | In year id used by the police to reference a c... | . 3 Accident | longitude | NaN | NaN | Null if not known | . 4 Accident | Latitude | NaN | NaN | Null if not known | . &#128170; Competition challenge . Create a report that covers the following: . What time of day and day of the week do most major incidents happen? | Are there any patterns in the time of day/ day of the week when major incidents occur? | What characteristics stand out in major incidents compared with other accidents? | On what areas would you recommend the planning team focus their brainstorming efforts to reduce major incidents? | &#129489;&#8205;&#9878;&#65039; Judging criteria . CATEGORY WEIGHTING DETAILS . Recommendations | 35% | Clarity of recommendations - how clear and well presented the recommendation is. | Quality of recommendations - are appropriate analytical techniques used &amp; are the conclusions valid? | Number of relevant insights found for the target audience. | . | . Storytelling | 30% | How well the data and insights are connected to the recommendation. | How the narrative and whole report connects together. | Balancing making the report in depth enough but also concise. | . | . Visualizations | 25% | Appropriateness of visualization used. | Clarity of insight from visualization. | . | . Votes | 10% | Up voting - most upvoted entries get the most points. | . | . &#9989; Checklist before publishing into the competition . Rename your workspace to make it descriptive of your work. N.B. you should leave the notebook name as notebook.ipynb. | Remove redundant cells like the judging criteria so the workbook is focused on your story. | Make sure the workbook reads well and explains how you found your insights. | Check that all the cells run without error. | . &#8987;&#65039; Time is ticking. Good luck! .",
            "url": "https://anuraganalog.github.io/blog/datacamp/competition/python/notebook/jupyter/workspace/reducing/the/number/of/high/fatality/accidents/2021/11/22/Reducing-the-number-of-high-fatality-accidents.html",
            "relUrl": "/datacamp/competition/python/notebook/jupyter/workspace/reducing/the/number/of/high/fatality/accidents/2021/11/22/Reducing-the-number-of-high-fatality-accidents.html",
            "date": " • Nov 22, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Find Movie Similarity from Plot Summaries",
            "content": "1. Import and observe dataset . We all love watching movies! There are some movies we like, some we don&#39;t. Most people have a preference for movies of a similar genre. Some of us love watching action movies, while some of us like watching horror. Some of us like watching movies that have ninjas in them, while some of us like watching superheroes. . Movies within a genre often share common base parameters. Consider the following two movies: . . Both movies, 2001: A Space Odyssey and Close Encounters of the Third Kind, are movies based on aliens coming to Earth. I&#39;ve seen both, and they indeed share many similarities. We could conclude that both of these fall into the same genre of movies based on intuition, but that&#39;s no fun in a data science context. In this notebook, we will quantify the similarity of movies based on their plot summaries available on IMDb and Wikipedia, then separate them into groups, also known as clusters. We&#39;ll create a dendrogram to represent how closely the movies are related to each other. . Let&#39;s start by importing the dataset and observing the data provided. . import numpy as np import pandas as pd import nltk # Set seed for reproducibility np.random.seed(5) # Read in IMDb and Wikipedia movie data (both in same file) movies_df = pd.read_csv(&#39;datasets/movies.csv&#39;) print(&quot;Number of movies loaded: %s &quot; % (len(movies_df))) # Display the data movies_df . Number of movies loaded: 100 . rank title genre wiki_plot imdb_plot . 0 0 | The Godfather | [u&#39; Crime&#39;, u&#39; Drama&#39;] | On the day of his only daughter&#39;s wedding, Vit... | In late summer 1945, guests are gathered for t... | . 1 1 | The Shawshank Redemption | [u&#39; Crime&#39;, u&#39; Drama&#39;] | In 1947, banker Andy Dufresne is convicted of ... | In 1947, Andy Dufresne (Tim Robbins), a banker... | . 2 2 | Schindler&#39;s List | [u&#39; Biography&#39;, u&#39; Drama&#39;, u&#39; History&#39;] | In 1939, the Germans move Polish Jews into the... | The relocation of Polish Jews from surrounding... | . 3 3 | Raging Bull | [u&#39; Biography&#39;, u&#39; Drama&#39;, u&#39; Sport&#39;] | In a brief scene in 1964, an aging, overweight... | The film opens in 1964, where an older and fat... | . 4 4 | Casablanca | [u&#39; Drama&#39;, u&#39; Romance&#39;, u&#39; War&#39;] | It is early December 1941. American expatriate... | In the early years of World War II, December 1... | . 5 5 | One Flew Over the Cuckoo&#39;s Nest | [u&#39; Drama&#39;] | In 1963 Oregon, Randle Patrick &quot;Mac&quot; McMurphy ... | In 1963 Oregon, Randle Patrick McMurphy (Nicho... | . 6 6 | Gone with the Wind | [u&#39; Drama&#39;, u&#39; Romance&#39;, u&#39; War&#39;] | nPart 1 n n Part 1 Part 1 n n On the... | The film opens in Tara, a cotton plantation ow... | . 7 7 | Citizen Kane | [u&#39; Drama&#39;, u&#39; Mystery&#39;] | n n n nOrson Welles as Charles Foster Kane n ... | It&#39;s 1941, and newspaper tycoon Charles Foster... | . 8 8 | The Wizard of Oz | [u&#39; Adventure&#39;, u&#39; Family&#39;, u&#39; Fantasy&#39;, u&#39; Mu... | The film starts in sepia-tinted Kansas in the ... | Dorothy Gale (Judy Garland) is an orphaned tee... | . 9 9 | Titanic | [u&#39; Drama&#39;, u&#39; Romance&#39;] | In 1996, treasure hunter Brock Lovett and his ... | In 1996, treasure hunter Brock Lovett and his ... | . 10 10 | Lawrence of Arabia | [u&#39; Adventure&#39;, u&#39; Biography&#39;, u&#39; Drama&#39;, u&#39; H... | ] n The film is presented in two parts, s... | In 1935, T. E. Lawrence (Peter O&#39;Toole) is kil... | . 11 11 | The Godfather: Part II | [u&#39; Crime&#39;, u&#39; Drama&#39;] | nIn 1901 Corleone, Sicily, nine-year-old Vito... | The Godfather Part II presents two parallel st... | . 12 12 | Psycho | [u&#39; Horror&#39;, u&#39; Mystery&#39;, u&#39; Thriller&#39;] | Patrick Bateman is a wealthy investment banker... | In a Phoenix hotel room on a Friday afternoon,... | . 13 13 | Sunset Blvd. | [u&#39; Drama&#39;, u&#39; Film-Noir&#39;] | At a Sunset Boulevard mansion, the body of Joe... | The film opens with the camera tracking down S... | . 14 14 | Vertigo | [u&#39; Mystery&#39;, u&#39; Romance&#39;, u&#39; Thriller&#39;] | ridge, Fort Point n n n n n n&quot;Madeleine&quot; a... | A woman&#39;s face gives way to a kaleidoscope of ... | . 15 15 | On the Waterfront | [u&#39; Crime&#39;, u&#39; Drama&#39;] | Mob-connected union boss Johnny Friendly (Lee ... | Terry Malloy (Marlon Brando) once dreamt of be... | . 16 16 | Forrest Gump | [u&#39; Drama&#39;, u&#39; Romance&#39;] | While waiting at a bus stop in 1981, Forrest G... | The film begins with a feather falling to the ... | . 17 17 | The Sound of Music | [u&#39; Biography&#39;, u&#39; Drama&#39;, u&#39; Family&#39;, u&#39; Musi... | In 1938, while living as a young postulant at ... | The widowed, retired Austrian naval officer, C... | . 18 18 | West Side Story | [u&#39; Crime&#39;, u&#39; Drama&#39;, u&#39; Musical&#39;, u&#39; Romance... | ] ] n In the West Side&#39;s Lincoln Square ne... | A fight set to music between an American gang,... | . 19 19 | Star Wars | [u&#39; Action&#39;, u&#39; Adventure&#39;, u&#39; Fantasy&#39;, u&#39; Sc... | The galaxy is in a civil war, and spies for th... | nNote: Italicized paragraphs denote scenes ad... | . 20 20 | E.T. the Extra-Terrestrial | [u&#39; Adventure&#39;, u&#39; Family&#39;, u&#39; Sci-Fi&#39;] | In a California forest, a group of alien botan... | In a forested area overlooking a sprawling sub... | . 21 21 | 2001: A Space Odyssey | [u&#39; Mystery&#39;, u&#39; Sci-Fi&#39;] | The film consists of four major sections, all ... | To Richard Strauss&#39; tone poem &quot;Thus Spake Zara... | . 22 22 | The Silence of the Lambs | [u&#39; Crime&#39;, u&#39; Drama&#39;, u&#39; Thriller&#39;] | is pulled from her training at the FBI Academy... | Promising FBI Academy student Clarice Starling... | . 23 23 | Chinatown | [u&#39; Drama&#39;, u&#39; Mystery&#39;, u&#39; Thriller&#39;] | A woman identifying herself as Evelyn Mulwray ... | Set in 1937 Los Angeles, a private investigato... | . 24 24 | The Bridge on the River Kwai | [u&#39; Adventure&#39;, u&#39; Drama&#39;, u&#39; War&#39;] | In World War II, British prisoners arrive at a... | this synopsis is primarily from the wikipedia ... | . 25 25 | Singin&#39; in the Rain | [u&#39; Comedy&#39;, u&#39; Musical&#39;, u&#39; Romance&#39;] | Don Lockwood is a popular silent film star wit... | Don Lockwood (Gene Kelly) is a popular silent ... | . 26 26 | It&#39;s a Wonderful Life | [u&#39; Drama&#39;, u&#39; Family&#39;, u&#39; Fantasy&#39;] | n n n nDonna Reed (as Mary Bailey) and James ... | This movie is about a divine intervention by a... | . 27 27 | Some Like It Hot | [u&#39; Comedy&#39;] | It is February 1929 in the city of Chicago. Jo... | Joe and Jerry, a saxophonist and bassist, resp... | . 28 28 | 12 Angry Men | [u&#39; Drama&#39;] | The story begins in a New York City courthous... | A teenaged Hispanic boy has just been tried fo... | . 29 29 | Dr. Strangelove or: How I Learned to Stop Worr... | [u&#39; Comedy&#39;, u&#39; War&#39;] | United States Air Force Brigadier General Jack... | At the Burpelson U.S. Air Force Base somewhere... | . ... ... | ... | ... | ... | ... | . 70 70 | Rain Man | [u&#39; Drama&#39;] | Charlie Babbitt is in the middle of importing ... | Charlie Babbitt (Tom Cruise), a Los Angeles ca... | . 71 71 | Annie Hall | [u&#39; Comedy&#39;, u&#39; Drama&#39;, u&#39; Romance&#39;] | The comedian Alvy Singer (Woody Allen) is tryi... | Annie Hall is a film about a comedian, Alvy Si... | . 72 72 | Out of Africa | [u&#39; Biography&#39;, u&#39; Drama&#39;, u&#39; Romance&#39;] | The story begins in 1913 in Denmark, when Kare... | [Out Of Africa]A well-heeled Danish lady goes ... | . 73 73 | Good Will Hunting | [u&#39; Drama&#39;] | Twenty-year-old Will Hunting (Damon) of South ... | Though Will Hunting (Matt Damon) has genius-le... | . 74 74 | Terms of Endearment | [u&#39; Comedy&#39;, u&#39; Drama&#39;] | Aurora Greenway (Shirley MacLaine) and her dau... | NaN | . 75 75 | Tootsie | [u&#39; Comedy&#39;, u&#39; Drama&#39;, u&#39; Romance&#39;] | Michael Dorsey (Dustin Hoffman) is a respected... | Michael Dorsey is an actor living and working ... | . 76 76 | Fargo | [u&#39; Crime&#39;, u&#39; Drama&#39;, u&#39; Thriller&#39;] | In the winter of 1987, Minneapolis car salesma... | The movie opens with a car towing a new tan Ol... | . 77 77 | Giant | [u&#39; Drama&#39;, u&#39; Romance&#39;] | Jordan &quot;Bick&quot; Benedict (Rock Hudson), head of ... | In the early 1920s, Jordan &quot;Bick&quot; Benedict (Ro... | . 78 78 | The Grapes of Wrath | [u&#39; Drama&#39;] | The film opens with Tom Joad (Henry Fonda), re... | After serving four years in prison for killing... | . 79 79 | Shane | [u&#39; Drama&#39;, u&#39; Romance&#39;, u&#39; Western&#39;] | n n n nAlan Ladd and Jean Arthur n n n n ... | NaN | . 80 80 | The Green Mile | [u&#39; Crime&#39;, u&#39; Drama&#39;, u&#39; Fantasy&#39;, u&#39; Mystery&#39;] | In a Louisiana nursing home in 1999, Paul Edge... | The movie begins with an old man named Paul Ed... | . 81 81 | Close Encounters of the Third Kind | [u&#39; Drama&#39;, u&#39; Sci-Fi&#39;] | In the Sonoran Desert, French scientist Claude... | In what appers to be the Sonoran Desert; in or... | . 82 82 | Network | [u&#39; Drama&#39;] | Howard Beale, the longtime anchor of the Union... | NaN | . 83 83 | Nashville | [u&#39; Drama&#39;, u&#39; Music&#39;] | The overarching plot takes place over five day... | The overarching plot takes place over five day... | . 84 84 | The Graduate | [u&#39; Comedy&#39;, u&#39; Drama&#39;, u&#39; Romance&#39;] | Benjamin Braddock, going on from twenty to twe... | The film explores the life of 21-year-old Ben ... | . 85 85 | American Graffiti | [u&#39; Comedy&#39;, u&#39; Drama&#39;] | In late August 1962 recent high school graduat... | It&#39;s the last night of the summer in 1962, and... | . 86 86 | Pulp Fiction | [u&#39; Crime&#39;, u&#39; Drama&#39;, u&#39; Thriller&#39;] | The Diner&quot; &quot;Prologue—The Diner&quot; n &quot;Pumpkin... | Late one morning in the Hawthorne Grill, a res... | . 87 87 | The African Queen | [u&#39; Adventure&#39;, u&#39; Romance&#39;, u&#39; War&#39;] | Robert Morley and Katharine Hepburn play Samue... | An English spinster, Rose (Katharine Hepburn),... | . 88 88 | Stagecoach | [u&#39; Adventure&#39;, u&#39; Western&#39;] | In 1880, a motley group of strangers boards th... | NaN | . 89 89 | Mutiny on the Bounty | [u&#39; Adventure&#39;, u&#39; Drama&#39;, u&#39; History&#39;] | In the year 1787, the Bounty sets sail from En... | NaN | . 90 90 | The Maltese Falcon | [u&#39; Drama&#39;, u&#39; Film-Noir&#39;, u&#39; Mystery&#39;] | n n nIn 1539 the Knight Templars of Malta, pa... | Private eye Sam Spade and his partner Miles Ar... | . 91 91 | A Clockwork Orange | [u&#39; Crime&#39;, u&#39; Drama&#39;, u&#39; Sci-Fi&#39;] | In futuristic London, Alex DeLarge is the lead... | A bit of the old ultra-violence&quot;.London, Engla... | . 92 92 | Taxi Driver | [u&#39; Crime&#39;, u&#39; Drama&#39;] | Travis Bickle, an honorably discharged U.S. Ma... | Travis Bickle (Robert De Niro) goes to a New Y... | . 93 93 | Wuthering Heights | [u&#39; Drama&#39;, u&#39; Romance&#39;] | A traveller named Lockwood (Miles Mander) is c... | NaN | . 94 94 | Double Indemnity | [u&#39; Crime&#39;, u&#39; Drama&#39;, u&#39; Film-Noir&#39;, u&#39; Thril... | n n n nNeff confesses into a Dictaphone. n n ... | Walter Neff (MacMurray) is a successful insura... | . 95 95 | Rebel Without a Cause | [u&#39; Drama&#39;] | n n n nJim Stark is in police custody. n n ... | Shortly after moving to Los Angeles with his p... | . 96 96 | Rear Window | [u&#39; Mystery&#39;, u&#39; Thriller&#39;] | n n n nJames Stewart as L.B. Jefferies n n ... | L.B. &quot;Jeff&quot; Jeffries (James Stewart) recuperat... | . 97 97 | The Third Man | [u&#39; Film-Noir&#39;, u&#39; Mystery&#39;, u&#39; Thriller&#39;] | n n n nSocial network mapping all major chara... | Sights of Vienna, Austria, flash across the sc... | . 98 98 | North by Northwest | [u&#39; Mystery&#39;, u&#39; Thriller&#39;] | Advertising executive Roger O. Thornhill is mi... | At the end of an ordinary work day, advertisin... | . 99 99 | Yankee Doodle Dandy | [u&#39; Biography&#39;, u&#39; Drama&#39;, u&#39; Musical&#39;] | n In the early days of World War II, Cohan ... | NaN | . 100 rows × 5 columns . 2. Combine Wikipedia and IMDb plot summaries . The dataset we imported currently contains two columns titled wiki_plot and imdb_plot. They are the plot found for the movies on Wikipedia and IMDb, respectively. The text in the two columns is similar, however, they are often written in different tones and thus provide context on a movie in a different manner of linguistic expression. Further, sometimes the text in one column may mention a feature of the plot that is not present in the other column. For example, consider the following plot extracts from The Godfather: . Wikipedia: &quot;On the day of his only daughter&#39;s wedding, Vito Corleone&quot; | IMDb: &quot;In late summer 1945, guests are gathered for the wedding reception of Don Vito Corleone&#39;s daughter Connie&quot; | . While the Wikipedia plot only mentions it is the day of the daughter&#39;s wedding, the IMDb plot also mentions the year of the scene and the name of the daughter. . Let&#39;s combine both the columns to avoid the overheads in computation associated with extra columns to process. . movies_df[&#39;plot&#39;] = movies_df[&#39;wiki_plot&#39;].astype(str) + &quot; n&quot; + movies_df[&#39;imdb_plot&#39;].astype(str) # Inspect the new DataFrame movies_df.head() . rank title genre wiki_plot imdb_plot plot . 0 0 | The Godfather | [u&#39; Crime&#39;, u&#39; Drama&#39;] | On the day of his only daughter&#39;s wedding, Vit... | In late summer 1945, guests are gathered for t... | On the day of his only daughter&#39;s wedding, Vit... | . 1 1 | The Shawshank Redemption | [u&#39; Crime&#39;, u&#39; Drama&#39;] | In 1947, banker Andy Dufresne is convicted of ... | In 1947, Andy Dufresne (Tim Robbins), a banker... | In 1947, banker Andy Dufresne is convicted of ... | . 2 2 | Schindler&#39;s List | [u&#39; Biography&#39;, u&#39; Drama&#39;, u&#39; History&#39;] | In 1939, the Germans move Polish Jews into the... | The relocation of Polish Jews from surrounding... | In 1939, the Germans move Polish Jews into the... | . 3 3 | Raging Bull | [u&#39; Biography&#39;, u&#39; Drama&#39;, u&#39; Sport&#39;] | In a brief scene in 1964, an aging, overweight... | The film opens in 1964, where an older and fat... | In a brief scene in 1964, an aging, overweight... | . 4 4 | Casablanca | [u&#39; Drama&#39;, u&#39; Romance&#39;, u&#39; War&#39;] | It is early December 1941. American expatriate... | In the early years of World War II, December 1... | It is early December 1941. American expatriate... | . 3. Tokenization . Tokenization is the process by which we break down articles into individual sentences or words, as needed. Besides the tokenization method provided by NLTK, we might have to perform additional filtration to remove tokens which are entirely numeric values or punctuation. . While a program may fail to build context from &quot;While waiting at a bus stop in 1981&quot; (Forrest Gump), because this string would not match in any dictionary, it is possible to build context from the words &quot;while&quot;, &quot;waiting&quot; or &quot;bus&quot; because they are present in the English dictionary. . Let us perform tokenization on a small extract from The Godfather. . sent_tokenized = [sent for sent in nltk.sent_tokenize(&quot;&quot;&quot; Today (May 19, 2016) is his only daughter&#39;s wedding. Vito Corleone is the Godfather. &quot;&quot;&quot;)] # Word Tokenize first sentence from sent_tokenized, save as words_tokenized words_tokenized = [word for word in nltk.word_tokenize(sent_tokenized[0])] # Remove tokens that do not contain any letters from words_tokenized import re filtered = [word for word in words_tokenized if re.search(&#39;[a-zA-Z]&#39;, word)] # Display filtered words to observe words after tokenization filtered . [&#39;Today&#39;, &#39;May&#39;, &#39;is&#39;, &#39;his&#39;, &#39;only&#39;, &#39;daughter&#39;, &#34;&#39;s&#34;, &#39;wedding&#39;] . 4. Stemming . Stemming is the process by which we bring down a word from its different forms to the root word. This helps us establish meaning to different forms of the same words without having to deal with each form separately. For example, the words &#39;fishing&#39;, &#39;fished&#39;, and &#39;fisher&#39; all get stemmed to the word &#39;fish&#39;. . Consider the following sentences: . &quot;Young William Wallace witnesses the treachery of Longshanks&quot; ~ Gladiator | &quot;escapes to the city walls only to witness Cicero&#39;s death&quot; ~ Braveheart | . Instead of building separate dictionary entries for both witnesses and witness, which mean the same thing outside of quantity, stemming them reduces them to &#39;wit&#39;. . There are different algorithms available for stemming such as the Porter Stemmer, Snowball Stemmer, etc. We shall use the Snowball Stemmer. . # ... YOUR CODE FOR TASK 4 ... from nltk.stem.snowball import SnowballStemmer # Create an English language SnowballStemmer object stemmer = SnowballStemmer(&quot;english&quot;) # Print filtered to observe words without stemming print(&quot;Without stemming: &quot;, filtered) # Stem the words from filtered and store in stemmed_words stemmed_words = [stemmer.stem(word) for word in filtered] # Print the stemmed_words to observe words after stemming print(&quot;After stemming: &quot;, stemmed_words) . Without stemming: [&#39;Today&#39;, &#39;May&#39;, &#39;is&#39;, &#39;his&#39;, &#39;only&#39;, &#39;daughter&#39;, &#34;&#39;s&#34;, &#39;wedding&#39;] After stemming: [&#39;today&#39;, &#39;may&#39;, &#39;is&#39;, &#39;his&#39;, &#39;onli&#39;, &#39;daughter&#39;, &#34;&#39;s&#34;, &#39;wed&#39;] . 5. Club together Tokenize &amp; Stem . We are now able to tokenize and stem sentences. But we may have to use the two functions repeatedly one after the other to handle a large amount of data, hence we can think of wrapping them in a function and passing the text to be tokenized and stemmed as the function argument. Then we can pass the new wrapping function, which shall perform both tokenizing and stemming instead of just tokenizing, as the tokenizer argument while creating the TF-IDF vector of the text. . What difference does it make though? Consider the sentence from the plot of The Godfather: &quot;Today (May 19, 2016) is his only daughter&#39;s wedding.&quot; If we do a &#39;tokenize-only&#39; for this sentence, we have the following result: . &#39;today&#39;, &#39;may&#39;, &#39;is&#39;, &#39;his&#39;, &#39;only&#39;, &#39;daughter&#39;, &quot;&#39;s&quot;, &#39;wedding&#39; . But when we do a &#39;tokenize-and-stem&#39; operation we get: . &#39;today&#39;, &#39;may&#39;, &#39;is&#39;, &#39;his&#39;, &#39;onli&#39;, &#39;daughter&#39;, &quot;&#39;s&quot;, &#39;wed&#39; . All the words are in their root form, which will lead to a better establishment of meaning as some of the non-root forms may not be present in the NLTK training corpus. . def tokenize_and_stem(text): # Tokenize by sentence, then by word tokens = [word for sent in nltk.sent_tokenize(text) for word in nltk.word_tokenize(sent)] # Filter out raw tokens to remove noise filtered_tokens = [token for token in tokens if re.search(&#39;[a-zA-Z]&#39;, token)] # Stem the filtered_tokens stems = [stemmer.stem(word) for word in filtered_tokens] return stems words_stemmed = tokenize_and_stem(&quot;Today (May 19, 2016) is his only daughter&#39;s wedding.&quot;) print(words_stemmed) . [&#34;today (may 19, 2016) is his only daughter&#39;s wedding.&#34;] . 6. Create TfidfVectorizer . Computers do not understand text. These are machines only capable of understanding numbers and performing numerical computation. Hence, we must convert our textual plot summaries to numbers for the computer to be able to extract meaning from them. One simple method of doing this would be to count all the occurrences of each word in the entire vocabulary and return the counts in a vector. Enter CountVectorizer. . Consider the word &#39;the&#39;. It appears quite frequently in almost all movie plots and will have a high count in each case. But obviously, it isn&#39;t the theme of all the movies! Term Frequency-Inverse Document Frequency (TF-IDF) is one method which overcomes the shortcomings of CountVectorizer. The Term Frequency of a word is the measure of how often it appears in a document, while the Inverse Document Frequency is the parameter which reduces the importance of a word if it frequently appears in several documents. . For example, when we apply the TF-IDF on the first 3 sentences from the plot of The Wizard of Oz, we are told that the most important word there is &#39;Toto&#39;, the pet dog of the lead character. This is because the movie begins with &#39;Toto&#39; biting someone due to which the journey of Oz begins! . In simplest terms, TF-IDF recognizes words which are unique and important to any given document. Let&#39;s create one for our purposes. . # ... YOUR CODE FOR TASK 6 ... from sklearn.feature_extraction.text import TfidfVectorizer # Instantiate TfidfVectorizer object with stopwords and tokenizer # parameters for efficient processing of text tfidf_vectorizer = TfidfVectorizer(max_df=0.8, max_features=200000, min_df=0.2, stop_words=&#39;english&#39;, use_idf=True, tokenizer=tokenize_and_stem, ngram_range=(1,3)) . 7. Fit transform TfidfVectorizer . Once we create a TF-IDF Vectorizer, we must fit the text to it and then transform the text to produce the corresponding numeric form of the data which the computer will be able to understand and derive meaning from. To do this, we use the fit_transform() method of the TfidfVectorizer object. . If we observe the TfidfVectorizer object we created, we come across a parameter stopwords. &#39;stopwords&#39; are those words in a given text which do not contribute considerably towards the meaning of the sentence and are generally grammatical filler words. For example, in the sentence &#39;Dorothy Gale lives with her dog Toto on the farm of her Aunt Em and Uncle Henry&#39;, we could drop the words &#39;her&#39; and &#39;the&#39;, and still have a similar overall meaning to the sentence. Thus, &#39;her&#39; and &#39;the&#39; are stopwords and can be conveniently dropped from the sentence. . On setting the stopwords to &#39;english&#39;, we direct the vectorizer to drop all stopwords from a pre-defined list of English language stopwords present in the nltk module. Another parameter, ngram_range, defines the length of the ngrams to be formed while vectorizing the text. . # to create a vector representation of the plot summaries tfidf_matrix = tfidf_vectorizer.fit_transform([x for x in movies_df[&quot;plot&quot;]]) print(tfidf_matrix.shape) . ValueError Traceback (most recent call last) &lt;ipython-input-67-37f6c54f1a06&gt; in &lt;module&gt; 1 # Fit and transform the tfidf_vectorizer with the &#34;plot&#34; of each movie 2 # to create a vector representation of the plot summaries -&gt; 3 tfidf_matrix = tfidf_vectorizer.fit_transform([x for x in movies_df[&#34;plot&#34;]]) 4 5 print(tfidf_matrix.shape) /usr/local/lib/python3.6/dist-packages/sklearn/feature_extraction/text.py in fit_transform(self, raw_documents, y) 1603 &#34;&#34;&#34; 1604 self._check_params() -&gt; 1605 X = super(TfidfVectorizer, self).fit_transform(raw_documents) 1606 self._tfidf.fit(X) 1607 # X is already a transformed view of raw_documents so /usr/local/lib/python3.6/dist-packages/sklearn/feature_extraction/text.py in fit_transform(self, raw_documents, y) 1051 max_doc_count, 1052 min_doc_count, -&gt; 1053 max_features) 1054 1055 self.vocabulary_ = vocabulary /usr/local/lib/python3.6/dist-packages/sklearn/feature_extraction/text.py in _limit_features(self, X, vocabulary, high, low, limit) 918 kept_indices = np.where(mask)[0] 919 if len(kept_indices) == 0: --&gt; 920 raise ValueError(&#34;After pruning, no terms remain. Try a lower&#34; 921 &#34; min_df or a higher max_df.&#34;) 922 return X[:, kept_indices], removed_terms ValueError: After pruning, no terms remain. Try a lower min_df or a higher max_df. . 8. Import KMeans and create clusters . To determine how closely one movie is related to the other by the help of unsupervised learning, we can use clustering techniques. Clustering is the method of grouping together a number of items such that they exhibit similar properties. According to the measure of similarity desired, a given sample of items can have one or more clusters. . A good basis of clustering in our dataset could be the genre of the movies. Say we could have a cluster &#39;0&#39; which holds movies of the &#39;Drama&#39; genre. We would expect movies like Chinatown or Psycho to belong to this cluster. Similarly, the cluster &#39;1&#39; in this project holds movies which belong to the &#39;Adventure&#39; genre (Lawrence of Arabia and the Raiders of the Lost Ark, for example). . K-means is an algorithm which helps us to implement clustering in Python. The name derives from its method of implementation: the given sample is divided into K clusters where each cluster is denoted by the mean of all the items lying in that cluster. . We get the following distribution for the clusters: . . from sklearn.cluster import KMeans # Create a KMeans object with 5 clusters and save as km km = KMeans(n_clusters=5) # Fit the k-means object with tfidf_matrix km.fit(tfidf_matrix) clusters = km.labels_.tolist() # Create a column cluster to denote the generated cluster for each movie movies_df[&quot;cluster&quot;] = clusters # Display number of films per cluster (clusters from 0 to 4) movies_df[&#39;cluster&#39;].value_counts() . 9. Calculate similarity distance . Consider the following two sentences from the movie The Wizard of Oz: . &quot;they find in the Emerald City&quot; . &quot;they finally reach the Emerald City&quot; . If we put the above sentences in a CountVectorizer, the vocabulary produced would be &quot;they, find, in, the, Emerald, City, finally, reach&quot; and the vectors for each sentence would be as follows: . 1, 1, 1, 1, 1, 1, 0, 0 . 1, 0, 0, 1, 1, 1, 1, 1 . When we calculate the cosine angle formed between the vectors represented by the above, we get a score of 0.667. This means the above sentences are very closely related. Similarity distance is 1 - cosine similarity angle. This follows from that if the vectors are similar, the cosine of their angle would be 1 and hence, the distance between then would be 1 - 1 = 0. . Let&#39;s calculate the similarity distance for all of our movies. . from sklearn.metrics.pairwise import cosine_similarity # Calculate the similarity distance similarity_distance = 1 - cosine_similarity(tfidf_matrix) . 10. Import Matplotlib, Linkage, and Dendrograms . We shall now create a tree-like diagram (called a dendrogram) of the movie titles to help us understand the level of similarity between them visually. Dendrograms help visualize the results of hierarchical clustering, which is an alternative to k-means clustering. Two pairs of movies at the same level of hierarchical clustering are expected to have similar strength of similarity between the corresponding pairs of movies. For example, the movie Fargo would be as similar to North By Northwest as the movie Platoon is to Saving Private Ryan, given both the pairs exhibit the same level of the hierarchy. . Let&#39;s import the modules we&#39;ll need to create our dendrogram. . # ... YOUR CODE FOR TASK 10 ... import matplotlib.pyplot as plt # Configure matplotlib to display the output inline %matplotlib inline # Import modules necessary to plot dendrogram # ... YOUR CODE FOR TASK 10 ... from scipy.cluster.hierarchy import linkage, dendrogram . 11. Create merging and plot dendrogram . We shall plot a dendrogram of the movies whose similarity measure will be given by the similarity distance we previously calculated. The lower the similarity distance between any two movies, the lower their linkage will make an intercept on the y-axis. For instance, the lowest dendrogram linkage we shall discover will be between the movies, It&#39;s a Wonderful Life and A Place in the Sun. This indicates that the movies are very similar to each other in their plots. . mergings = linkage(similarity_distance, method=&#39;complete&#39;) # Plot the dendrogram, using title as label column dendrogram_ = dendrogram(mergings, labels=[x for x in movies_df[&quot;title&quot;]], leaf_rotation=90, leaf_font_size=16, ) # Adjust the plot fig = plt.gcf() _ = [lbl.set_color(&#39;r&#39;) for lbl in plt.gca().get_xmajorticklabels()] fig.set_size_inches(108, 21) # Show the plotted dendrogram plt.show() . 12. Which movies are most similar? . We can now determine the similarity between movies based on their plots! To wrap up, let&#39;s answer one final question: which movie is most similar to the movie Braveheart? . ans = &quot;Gladiator&quot; print(ans) .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/31/Find-Movie-Similarity-from-Plot-Summaries.html",
            "relUrl": "/datacamp/projects/python/2021/03/31/Find-Movie-Similarity-from-Plot-Summaries.html",
            "date": " • Mar 31, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Analyzing Netflix Data",
            "content": "1. Loading your friend&#39;s data into a dictionary . Netflix! What started in 1997 as a DVD rental service has since exploded into the largest entertainment/media company by market capitalization, boasting over 200 million subscribers as of January 2021. . Given the large number of movies and series available on the platform, it is a perfect opportunity to flex our data manipulation skills and dive into the entertainment industry. Our friend has also been brushing up on their Python skills and has taken a first crack at a CSV file containing Netflix data. For their first order of business, they have been performing some analyses, and they believe that the average duration of movies has been declining. . As evidence of this, they have provided us with the following information. For the years from 2011 to 2020, the average movie durations are 103, 101, 99, 100, 100, 95, 95, 96, 93, and 90, respectively. . If we&#39;re going to be working with this data, we know a good place to start would be to probably start working with pandas. But first we&#39;ll need to create a DataFrame from scratch. Let&#39;s start by creating a Python object covered in Intermediate Python: a dictionary! . years = list(range(2011, 2021)) durations = [103, 101, 99, 100, 100, 95, 95, 96, 93, 90] # Create a dictionary with the two lists movie_dict = {&#39;years&#39;: years, &#39;durations&#39;: durations} # Print the dictionary movie_dict . {&#39;years&#39;: [2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020], &#39;durations&#39;: [103, 101, 99, 100, 100, 95, 95, 96, 93, 90]} . 2. Creating a DataFrame from a dictionary . Perfect! We now have our friend&#39;s data stored in a nice Python object. We can already perform several operations on a dictionary to manipulate its contents (such as updating or adding to it). But a more useful structure might be a pandas DataFrame, a tabular data structure containing labeled axes and rows. Luckily, DataFrames can be created very easily from the dictionary created in the previous step! . To convert our dictionary movie_dict to a pandas DataFrame, we will first need to import the library under its usual alias. We&#39;ll also want to inspect our DataFrame to ensure it was created correctly. Let&#39;s perform these steps now. . import pandas as pd # Create a DataFrame from the dictionary durations_df = pd.DataFrame.from_dict(movie_dict) # Print the DataFrame print(durations_df) . years durations 0 2011 103 1 2012 101 2 2013 99 3 2014 100 4 2015 100 5 2016 95 6 2017 95 7 2018 96 8 2019 93 9 2020 90 . 3. A visual inspection of our data . Alright, we now have a pandas DataFrame, the most common way to work with tabular data in Python. Now back to the task at hand. We want to follow up on our friend&#39;s assertion that movie lengths have been decreasing over time. A great place to start will be a visualization of the data. . Given that the data is continuous, a line plot would be a good choice, with the dates represented along the x-axis and the average length in minutes along the y-axis. This will allow us to easily spot any trends in movie durations. There are many ways to visualize data in Python, but matploblib.pyplot is one of the most common packages to do so. . Note: In order for us to correctly test your plot, you will need to initalize a matplotlib.pyplot Figure object, which we have already provided in the cell below. You can continue to create your plot as you have learned in Intermediate Python. . import matplotlib.pyplot as plt fig = plt.figure() # Draw a line plot of release_years and durations plt.plot(durations_df[&#39;years&#39;], durations_df[&#39;durations&#39;]) # Create a title plt.title(&quot;Netflix Movie Durations 2011-2020&quot;) # Show the plot plt.show() . 4. Loading the rest of the data from a CSV . Well, it looks like there is something to the idea that movie lengths have decreased over the past ten years! But equipped only with our friend&#39;s aggregations, we&#39;re limited in the further explorations we can perform. There are a few questions about this trend that we are currently unable to answer, including: . What does this trend look like over a longer period of time? | Is this explainable by something like the genre of entertainment? | Upon asking our friend for the original CSV they used to perform their analyses, they gladly oblige and send it. We now have access to the CSV file, available at the path &quot;datasets/netflix_data.csv&quot;. Let&#39;s create another DataFrame, this time with all of the data. Given the length of our friend&#39;s data, printing the whole DataFrame is probably not a good idea, so we will inspect it by printing only the first five rows. . netflix_df = pd.read_csv(&quot;datasets/netflix_data.csv&quot;) # Print the first five rows of the DataFrame netflix_df.head() . show_id type title director cast country date_added release_year duration description genre . 0 s1 | TV Show | 3% | NaN | João Miguel, Bianca Comparato, Michel Gomes, R... | Brazil | August 14, 2020 | 2020 | 4 | In a future where the elite inhabit an island ... | International TV | . 1 s2 | Movie | 7:19 | Jorge Michel Grau | Demián Bichir, Héctor Bonilla, Oscar Serrano, ... | Mexico | December 23, 2016 | 2016 | 93 | After a devastating earthquake hits Mexico Cit... | Dramas | . 2 s3 | Movie | 23:59 | Gilbert Chan | Tedd Chan, Stella Chung, Henley Hii, Lawrence ... | Singapore | December 20, 2018 | 2011 | 78 | When an army recruit is found dead, his fellow... | Horror Movies | . 3 s4 | Movie | 9 | Shane Acker | Elijah Wood, John C. Reilly, Jennifer Connelly... | United States | November 16, 2017 | 2009 | 80 | In a postapocalyptic world, rag-doll robots hi... | Action | . 4 s5 | Movie | 21 | Robert Luketic | Jim Sturgess, Kevin Spacey, Kate Bosworth, Aar... | United States | January 1, 2020 | 2008 | 123 | A brilliant group of students become card-coun... | Dramas | . 5. Filtering for movies! . Okay, we have our data! Now we can dive in and start looking at movie lengths. . Or can we? Looking at the first five rows of our new DataFrame, we notice a column type. Scanning the column, it&#39;s clear there are also TV shows in the dataset! Moreover, the duration column we planned to use seems to represent different values depending on whether the row is a movie or a show (perhaps the number of minutes versus the number of seasons)? . Fortunately, a DataFrame allows us to filter data quickly, and we can select rows where type is Movie. While we&#39;re at it, we don&#39;t need information from all of the columns, so let&#39;s create a new DataFrame netflix_movies containing only title, country, genre, release_year, and duration. . Let&#39;s put our data subsetting skills to work! . netflix_df_movies_only = netflix_df[netflix_df[&#39;type&#39;] == &#39;Movie&#39;] # Select only the columns of interest netflix_movies_col_subset = netflix_df_movies_only[[&#39;title&#39;, &#39;country&#39;, &#39;genre&#39;, &#39;release_year&#39;, &#39;duration&#39;]] # Print the first five rows of the new DataFrame netflix_movies_col_subset.head() . title country genre release_year duration . 1 7:19 | Mexico | Dramas | 2016 | 93 | . 2 23:59 | Singapore | Horror Movies | 2011 | 78 | . 3 9 | United States | Action | 2009 | 80 | . 4 21 | United States | Dramas | 2008 | 123 | . 6 122 | Egypt | Horror Movies | 2019 | 95 | . 6. Creating a scatter plot . Okay, now we&#39;re getting somewhere. We&#39;ve read in the raw data, selected rows of movies, and have limited our DataFrame to our columns of interest. Let&#39;s try visualizing the data again to inspect the data over a longer range of time. . This time, we are no longer working with aggregates but instead with individual movies. A line plot is no longer a good choice for our data, so let&#39;s try a scatter plot instead. We will again plot the year of release on the x-axis and the movie duration on the y-axis. . Note: Although not taught in Intermediate Python, we have provided you the code fig = plt.figure(figsize=(12,8)) to increase the size of the plot (to help you see the results), as well as to assist with testing. For more information on how to create or work with a matplotlib figure, refer to the documentation. . fig = plt.figure(figsize=(12,8)) # Create a scatter plot of duration versus year plt.scatter(netflix_movies_col_subset[&#39;release_year&#39;], netfl&#39;duration&#39;) # Create a title plt.title(&quot;Movie Duration by Year of Release&quot;) # Show the plot plt.show() . &lt;Figure size 864x576 with 0 Axes&gt; . 7. Digging deeper . This is already much more informative than the simple plot we created when our friend first gave us some data. We can also see that, while newer movies are overrepresented on the platform, many short movies have been released in the past two decades. . Upon further inspection, something else is going on. Some of these films are under an hour long! Let&#39;s filter our DataFrame for movies with a duration under 60 minutes and look at the genres. This might give us some insight into what is dragging down the average. . short_movies = netflix_movies_col_subset[netflix_movies_col_subset[&#39;duration&#39;] &lt; 60] # Print the first 20 rows of short_movies short_movies.head(20) . title country genre release_year duration . 35 #Rucker50 | United States | Documentaries | 2016 | 56 | . 55 100 Things to do Before High School | United States | Uncategorized | 2014 | 44 | . 67 13TH: A Conversation with Oprah Winfrey &amp; Ava ... | NaN | Uncategorized | 2017 | 37 | . 101 3 Seconds Divorce | Canada | Documentaries | 2018 | 53 | . 146 A 3 Minute Hug | Mexico | Documentaries | 2019 | 28 | . 162 A Christmas Special: Miraculous: Tales of Lady... | France | Uncategorized | 2016 | 22 | . 171 A Family Reunion Christmas | United States | Uncategorized | 2019 | 29 | . 177 A Go! Go! Cory Carson Christmas | United States | Children | 2020 | 22 | . 178 A Go! Go! Cory Carson Halloween | NaN | Children | 2020 | 22 | . 179 A Go! Go! Cory Carson Summer Camp | NaN | Children | 2020 | 21 | . 181 A Grand Night In: The Story of Aardman | United Kingdom | Documentaries | 2015 | 59 | . 200 A Love Song for Latasha | United States | Documentaries | 2020 | 20 | . 220 A Russell Peters Christmas | Canada | Stand-Up | 2011 | 44 | . 233 A StoryBots Christmas | United States | Children | 2017 | 26 | . 237 A Tale of Two Kitchens | United States | Documentaries | 2019 | 30 | . 242 A Trash Truck Christmas | NaN | Children | 2020 | 28 | . 247 A Very Murray Christmas | United States | Comedies | 2015 | 57 | . 285 Abominable Christmas | United States | Children | 2012 | 44 | . 295 Across Grace Alley | United States | Dramas | 2013 | 24 | . 305 Adam Devine: Best Time of Our Lives | United States | Stand-Up | 2019 | 59 | . 8. Marking non-feature films . Interesting! It looks as though many of the films that are under 60 minutes fall into genres such as &quot;Children&quot;, &quot;Stand-Up&quot;, and &quot;Documentaries&quot;. This is a logical result, as these types of films are probably often shorter than 90 minute Hollywood blockbuster. . We could eliminate these rows from our DataFrame and plot the values again. But another interesting way to explore the effect of these genres on our data would be to plot them, but mark them with a different color. . In Python, there are many ways to do this, but one fun way might be to use a loop to generate a list of colors based on the contents of the genre column. Much as we did in Intermediate Python, we can then pass this list to our plotting function in a later step to color all non-typical genres in a different color! . Note: Although we are using the basic colors of red, blue, green, and black, matplotlib has many named colors you can use when creating plots. For more information, you can refer to the documentation here! . colors = list() # Iterate over rows of netflix_movies_col_subset for idx, row in netflix_movies_col_subset.iterrows(): if row[&#39;genre&#39;] == &quot;Children&quot;: colors.append(&quot;red&quot;) elif row[&#39;genre&#39;] == &quot;Documentaries&quot;: colors.append(&quot;blue&quot;) elif row[&#39;genre&#39;] == &quot;Stand-Up&quot;: colors.append(&quot;green&quot;) else: colors.append(&quot;black&quot;) # Inspect the first 10 values in your list colors[:10] . [&#39;black&#39;, &#39;black&#39;, &#39;black&#39;, &#39;black&#39;, &#39;black&#39;, &#39;black&#39;, &#39;black&#39;, &#39;black&#39;, &#39;black&#39;, &#39;blue&#39;] . 9. Plotting with color! . Lovely looping! We now have a colors list that we can pass to our scatter plot, which should allow us to visually inspect whether these genres might be responsible for the decline in the average duration of movies. . This time, we&#39;ll also spruce up our plot with some additional axis labels and a new theme with plt.style.use(). The latter isn&#39;t taught in Intermediate Python, but can be a fun way to add some visual flair to a basic matplotlib plot. You can find more information on customizing the style of your plot here! . plt.style.use(&#39;fivethirtyeight&#39;) fig = plt.figure(figsize=(12,8)) # Create a scatter plot of duration versus release_year netflix_movies_col_subset.plot(kind=&#39;scatter&#39;, x=&#39;release_year&#39;, y=&#39;duration&#39;, c=colors) # Create a title and axis labels plt.title(&quot;Movie duration by year of release&quot;) plt.xlabel(&quot;Release year&quot;) plt.ylabel(&quot;Duration (min)&quot;) # Show the plot plt.show() . &lt;Figure size 864x576 with 0 Axes&gt; . 10. What next? . Well, as we suspected, non-typical genres such as children&#39;s movies and documentaries are all clustered around the bottom half of the plot. But we can&#39;t know for certain until we perform additional analyses. . Congratulations, you&#39;ve performed an exploratory analysis of some entertainment data, and there are lots of fun ways to develop your skills as a Pythonic data scientist. These include learning how to analyze data further with statistics, creating more advanced visualizations, and perhaps most importantly, learning more advanced ways of working with data in pandas. This latter skill is covered in our fantastic course Data Manipulation with pandas. . We hope you enjoyed this application of the skills learned in Intermediate Python, and wish you all the best on the rest of your journey! . are_movies_getting_shorter = &quot;Yes&quot; .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/31/Analyzing-Netflix-Data.html",
            "relUrl": "/datacamp/projects/python/2021/03/31/Analyzing-Netflix-Data.html",
            "date": " • Mar 31, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "Generating Keywords for Google Ads",
            "content": "1. The brief . Imagine working for a digital marketing agency, and the agency is approached by a massive online retailer of furniture. They want to test our skills at creating large campaigns for all of their website. We are tasked with creating a prototype set of keywords for search campaigns for their sofas section. The client says that they want us to generate keywords for the following products: . sofas | convertible sofas | love seats | recliners | sofa beds | . The brief: The client is generally a low-cost retailer, offering many promotions and discounts. We will need to focus on such keywords. We will also need to move away from luxury keywords and topics, as we are targeting price-sensitive customers. Because we are going to be tight on budget, it would be good to focus on a tightly targeted set of keywords and make sure they are all set to exact and phrase match. . Based on the brief above we will first need to generate a list of words, that together with the products given above would make for good keywords. Here are some examples: . Products: sofas, recliners | Words: buy, prices | . The resulting keywords: &#39;buy sofas&#39;, &#39;sofas buy&#39;, &#39;buy recliners&#39;, &#39;recliners buy&#39;, &#39;prices sofas&#39;, &#39;sofas prices&#39;, &#39;prices recliners&#39;, &#39;recliners prices&#39;. . As a final result, we want to have a DataFrame that looks like this: . Campaign Ad Group Keyword Criterion Type . Campaign1 | AdGroup_1 | keyword 1a | Exact | . Campaign1 | AdGroup_1 | keyword 1a | Phrase | . Campaign1 | AdGroup_1 | keyword 1b | Exact | . Campaign1 | AdGroup_1 | keyword 1b | Phrase | . Campaign1 | AdGroup_2 | keyword 2a | Exact | . Campaign1 | AdGroup_2 | keyword 2a | Phrase | . The first step is to come up with a list of words that users might use to express their desire in buying low-cost sofas. . words = [&#39;buy&#39;, &#39;promotion&#39;, &#39;discount&#39;, &#39;price&#39;, &#39;promo&#39;, &#39;shop&#39;] # Print list of words # ... YOUR CODE FOR TASK 1 ... print(words) . [&#39;buy&#39;, &#39;promotion&#39;, &#39;discount&#39;, &#39;price&#39;, &#39;promo&#39;, &#39;shop&#39;] . 2. Combine the words with the product names . Imagining all the possible combinations of keywords can be stressful! But not for us, because we are keyword ninjas! We know how to translate campaign briefs into Python data structures and can imagine the resulting DataFrames that we need to create. . Now that we have brainstormed the words that work well with the brief that we received, it is now time to combine them with the product names to generate meaningful search keywords. We want to combine every word with every product once before, and once after, as seen in the example above. . As a quick reminder, for the product &#39;recliners&#39; and the words &#39;buy&#39; and &#39;price&#39; for example, we would want to generate the following combinations: . buy recliners recliners buy price recliners recliners price … . and so on for all the words and products that we have. . products = [&#39;sofas&#39;, &#39;convertible sofas&#39;, &#39;love seats&#39;, &#39;recliners&#39;, &#39;sofa beds&#39;] # Create an empty list keywords_list = list() # Loop through products for product in products: # Loop through words for word in words: # Append combinations keywords_list.append([product, product + &#39; &#39; + word]) keywords_list.append([product, word + &#39; &#39; + product]) # Inspect keyword list from pprint import pprint pprint(keywords_list) . [[&#39;sofas&#39;, &#39;sofas buy&#39;], [&#39;sofas&#39;, &#39;buy sofas&#39;], [&#39;sofas&#39;, &#39;sofas promotion&#39;], [&#39;sofas&#39;, &#39;promotion sofas&#39;], [&#39;sofas&#39;, &#39;sofas discount&#39;], [&#39;sofas&#39;, &#39;discount sofas&#39;], [&#39;sofas&#39;, &#39;sofas price&#39;], [&#39;sofas&#39;, &#39;price sofas&#39;], [&#39;sofas&#39;, &#39;sofas promo&#39;], [&#39;sofas&#39;, &#39;promo sofas&#39;], [&#39;sofas&#39;, &#39;sofas shop&#39;], [&#39;sofas&#39;, &#39;shop sofas&#39;], [&#39;convertible sofas&#39;, &#39;convertible sofas buy&#39;], [&#39;convertible sofas&#39;, &#39;buy convertible sofas&#39;], [&#39;convertible sofas&#39;, &#39;convertible sofas promotion&#39;], [&#39;convertible sofas&#39;, &#39;promotion convertible sofas&#39;], [&#39;convertible sofas&#39;, &#39;convertible sofas discount&#39;], [&#39;convertible sofas&#39;, &#39;discount convertible sofas&#39;], [&#39;convertible sofas&#39;, &#39;convertible sofas price&#39;], [&#39;convertible sofas&#39;, &#39;price convertible sofas&#39;], [&#39;convertible sofas&#39;, &#39;convertible sofas promo&#39;], [&#39;convertible sofas&#39;, &#39;promo convertible sofas&#39;], [&#39;convertible sofas&#39;, &#39;convertible sofas shop&#39;], [&#39;convertible sofas&#39;, &#39;shop convertible sofas&#39;], [&#39;love seats&#39;, &#39;love seats buy&#39;], [&#39;love seats&#39;, &#39;buy love seats&#39;], [&#39;love seats&#39;, &#39;love seats promotion&#39;], [&#39;love seats&#39;, &#39;promotion love seats&#39;], [&#39;love seats&#39;, &#39;love seats discount&#39;], [&#39;love seats&#39;, &#39;discount love seats&#39;], [&#39;love seats&#39;, &#39;love seats price&#39;], [&#39;love seats&#39;, &#39;price love seats&#39;], [&#39;love seats&#39;, &#39;love seats promo&#39;], [&#39;love seats&#39;, &#39;promo love seats&#39;], [&#39;love seats&#39;, &#39;love seats shop&#39;], [&#39;love seats&#39;, &#39;shop love seats&#39;], [&#39;recliners&#39;, &#39;recliners buy&#39;], [&#39;recliners&#39;, &#39;buy recliners&#39;], [&#39;recliners&#39;, &#39;recliners promotion&#39;], [&#39;recliners&#39;, &#39;promotion recliners&#39;], [&#39;recliners&#39;, &#39;recliners discount&#39;], [&#39;recliners&#39;, &#39;discount recliners&#39;], [&#39;recliners&#39;, &#39;recliners price&#39;], [&#39;recliners&#39;, &#39;price recliners&#39;], [&#39;recliners&#39;, &#39;recliners promo&#39;], [&#39;recliners&#39;, &#39;promo recliners&#39;], [&#39;recliners&#39;, &#39;recliners shop&#39;], [&#39;recliners&#39;, &#39;shop recliners&#39;], [&#39;sofa beds&#39;, &#39;sofa beds buy&#39;], [&#39;sofa beds&#39;, &#39;buy sofa beds&#39;], [&#39;sofa beds&#39;, &#39;sofa beds promotion&#39;], [&#39;sofa beds&#39;, &#39;promotion sofa beds&#39;], [&#39;sofa beds&#39;, &#39;sofa beds discount&#39;], [&#39;sofa beds&#39;, &#39;discount sofa beds&#39;], [&#39;sofa beds&#39;, &#39;sofa beds price&#39;], [&#39;sofa beds&#39;, &#39;price sofa beds&#39;], [&#39;sofa beds&#39;, &#39;sofa beds promo&#39;], [&#39;sofa beds&#39;, &#39;promo sofa beds&#39;], [&#39;sofa beds&#39;, &#39;sofa beds shop&#39;], [&#39;sofa beds&#39;, &#39;shop sofa beds&#39;]] . 3. Convert the list of lists into a DataFrame . Now we want to convert this list of lists into a DataFrame so we can easily manipulate it and manage the final output. . # ... YOUR CODE FOR TASK 3 ... import pandas as pd # Create a DataFrame from list keywords_df = pd.DataFrame.from_records(keywords_list) # Print the keywords DataFrame to explore it # ... YOUR CODE FOR TASK 3 ... keywords_df.head() . 0 1 . 0 sofas | sofas buy | . 1 sofas | buy sofas | . 2 sofas | sofas promotion | . 3 sofas | promotion sofas | . 4 sofas | sofas discount | . 4. Rename the columns of the DataFrame . Before we can upload this table of keywords, we will need to give the columns meaningful names. If we inspect the DataFrame we just created above, we can see that the columns are currently named 0 and 1. Ad Group (example: &quot;sofas&quot;) and Keyword (example: &quot;sofas buy&quot;) are much more appropriate names. . keywords_df.rename(columns=[0, 1]) . TypeError Traceback (most recent call last) &lt;ipython-input-57-c32ddb7ee77c&gt; in &lt;module&gt;() 1 # Rename the columns of the DataFrame -&gt; 2 keywords_df.rename(columns=[0, 1]) /usr/local/lib/python3.5/dist-packages/pandas/util/_decorators.py in wrapper(*args, **kwargs) 185 @wraps(func) 186 def wrapper(*args, **kwargs): --&gt; 187 return func(*args, **kwargs) 188 189 if not PY2: /usr/local/lib/python3.5/dist-packages/pandas/core/frame.py in rename(self, *args, **kwargs) 3779 kwargs.pop(&#39;axis&#39;, None) 3780 kwargs.pop(&#39;mapper&#39;, None) -&gt; 3781 return super(DataFrame, self).rename(**kwargs) 3782 3783 @Substitution(**_shared_doc_kwargs) /usr/local/lib/python3.5/dist-packages/pandas/core/generic.py in rename(self, *args, **kwargs) 972 level = self.axes[axis]._get_level_number(level) 973 result._data = result._data.rename_axis(f, axis=baxis, copy=copy, --&gt; 974 level=level) 975 result._clear_item_cache() 976 /usr/local/lib/python3.5/dist-packages/pandas/core/internals.py in rename_axis(self, mapper, axis, copy, level) 3338 &#34;&#34;&#34; 3339 obj = self.copy(deep=copy) -&gt; 3340 obj.set_axis(axis, _transform_index(self.axes[axis], mapper, level)) 3341 return obj 3342 /usr/local/lib/python3.5/dist-packages/pandas/core/internals.py in _transform_index(index, func, level) 5296 return MultiIndex.from_tuples(items, names=index.names) 5297 else: -&gt; 5298 items = [func(x) for x in index] 5299 return Index(items, name=index.name, tupleize_cols=False) 5300 /usr/local/lib/python3.5/dist-packages/pandas/core/internals.py in &lt;listcomp&gt;(.0) 5296 return MultiIndex.from_tuples(items, names=index.names) 5297 else: -&gt; 5298 items = [func(x) for x in index] 5299 return Index(items, name=index.name, tupleize_cols=False) 5300 TypeError: &#39;list&#39; object is not callable . 5. Add a campaign column . Now we need to add some additional information to our DataFrame. We need a new column called Campaign for the campaign name. We want campaign names to be descriptive of our group of keywords and products, so let&#39;s call this campaign &#39;SEM_Sofas&#39;. . # ... YOUR CODE FOR TASK 5 ... keywords_df[&#39;Campaign&#39;] = &#39;SEM_Sofas&#39; . 6. Create the match type column . There are different keyword match types. One is exact match, which is for matching the exact term or are close variations of that exact term. Another match type is broad match, which means ads may show on searches that include misspellings, synonyms, related searches, and other relevant variations. . Straight from Google&#39;s AdWords documentation: . In general, the broader the match type, the more traffic potential that keyword will have, since your ads may be triggered more often. Conversely, a narrower match type means that your ads may show less often—but when they do, they’re likely to be more related to someone’s search. . Since the client is tight on budget, we want to make sure all the keywords are in exact match at the beginning. . # ... YOUR CODE FOR TASK 6 ... keywords_df[&#39;Criterion Type&#39;] = &#39;Exact&#39; . 7. Duplicate all the keywords into &#39;phrase&#39; match . The great thing about exact match is that it is very specific, and we can control the process very well. The tradeoff, however, is that: . The search volume for exact match is lower than other match types | We can&#39;t possibly think of all the ways in which people search, and so, we are probably missing out on some high-quality keywords. | So it&#39;s good to use another match called phrase match as a discovery mechanism to allow our ads to be triggered by keywords that include our exact match keywords, together with anything before (or after) them. . Later on, when we launch the campaign, we can explore with modified broad match, broad match, and negative match types, for better visibility and control of our campaigns. . keywords_phrase = keywords_df.copy() # Change criterion type match to phrase # ... YOUR CODE FOR TASK 7 ... keywords_phrase[&#39;Criterion Type&#39;] = &#39;Phrase&#39; # Append the DataFrames keywords_df_final = keywords_df.append(keywords_phrase) . 8. Save and summarize! . To upload our campaign, we need to save it as a CSV file. Then we will be able to import it to AdWords editor or BingAds editor. There is also the option of pasting the data into the editor if we want, but having easy access to the saved data is great so let&#39;s save to a CSV file! . Looking at a summary of our campaign structure is good now that we&#39;ve wrapped up our keyword work. We can do that by grouping by ad group and criterion type and counting by keyword. This summary shows us that we assigned specific keywords to specific ad groups, which are each part of a campaign. In essence, we are telling Google (or Bing, etc.) that we want any of the words in each ad group to trigger one of the ads in the same ad group. Separately, we will have to create another table for ads, which is a task for another day and would look something like this: . Campaign Ad Group Headline 1 Headline 2 Description Final URL . SEM_Sofas | Sofas | Looking for Quality Sofas? | Explore Our Massive Collection | 30-day Returns With Free Delivery Within the US. Start Shopping Now | DataCampSofas.com/sofas | . SEM_Sofas | Sofas | Looking for Affordable Sofas? | Check Out Our Weekly Offers | 30-day Returns With Free Delivery Within the US. Start Shopping Now | DataCampSofas.com/sofas | . SEM_Sofas | Recliners | Looking for Quality Recliners? | Explore Our Massive Collection | 30-day Returns With Free Delivery Within the US. Start Shopping Now | DataCampSofas.com/recliners | . SEM_Sofas | Recliners | Need Affordable Recliners? | Check Out Our Weekly Offers | 30-day Returns With Free Delivery Within the US. Start Shopping Now | DataCampSofas.com/recliners | . Together, these tables get us the sample keywords -&gt; ads -&gt; landing pages mapping shown in the diagram below. . . # ... YOUR CODE FOR TASK 8 ... keywords_df_final.to_csv(&#39;keywords.csv&#39;, index=False) # View a summary of our campaign work summary = keywords_df_final.groupby([&#39;Ad Group&#39;, &#39;Criterion Type&#39;])[&#39;Keyword&#39;].count() print(summary) . KeyError Traceback (most recent call last) &lt;ipython-input-64-27d087b4c3d3&gt; in &lt;module&gt;() 4 5 # View a summary of our campaign work -&gt; 6 summary = keywords_df_final.groupby([&#39;Ad Group&#39;, &#39;Criterion Type&#39;])[&#39;Keyword&#39;].count() 7 print(summary) /usr/local/lib/python3.5/dist-packages/pandas/core/generic.py in groupby(self, by, axis, level, as_index, sort, group_keys, squeeze, observed, **kwargs) 6663 return groupby(self, by=by, axis=axis, level=level, as_index=as_index, 6664 sort=sort, group_keys=group_keys, squeeze=squeeze, -&gt; 6665 observed=observed, **kwargs) 6666 6667 def asfreq(self, freq, method=None, how=None, normalize=False, /usr/local/lib/python3.5/dist-packages/pandas/core/groupby/groupby.py in groupby(obj, by, **kwds) 2150 raise TypeError(&#39;invalid type: %s&#39; % type(obj)) 2151 -&gt; 2152 return klass(obj, by, **kwds) 2153 2154 /usr/local/lib/python3.5/dist-packages/pandas/core/groupby/groupby.py in __init__(self, obj, keys, axis, level, grouper, exclusions, selection, as_index, sort, group_keys, squeeze, observed, **kwargs) 597 sort=sort, 598 observed=observed, --&gt; 599 mutated=self.mutated) 600 601 self.obj = obj /usr/local/lib/python3.5/dist-packages/pandas/core/groupby/groupby.py in _get_grouper(obj, key, axis, level, sort, observed, mutated, validate) 3289 in_axis, name, level, gpr = False, None, gpr, None 3290 else: -&gt; 3291 raise KeyError(gpr) 3292 elif isinstance(gpr, Grouper) and gpr.key is not None: 3293 # Add key to exclusions KeyError: &#39;Ad Group&#39; .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/30/Generating-Keywords-for-Google-Ads.html",
            "relUrl": "/datacamp/projects/python/2021/03/30/Generating-Keywords-for-Google-Ads.html",
            "date": " • Mar 30, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "Disney Movies and Box Office Success",
            "content": "1. The dataset . Walt Disney Studios is the foundation on which The Walt Disney Company was built. The Studios has produced more than 600 films since their debut film, Snow White and the Seven Dwarfs in 1937. While many of its films were big hits, some of them were not. In this notebook, we will explore a dataset of Disney movies and analyze what contributes to the success of Disney movies. . . First, we will take a look at the Disney data compiled by Kelly Garrett. The data contains 579 Disney movies with six features: movie title, release date, genre, MPAA rating, total gross, and inflation-adjusted gross. . Let&#39;s load the file and see what the data looks like. . # ... YOUR CODE FOR TASK 1 ... import pandas as pd # Read the file into gross gross = pd.read_csv(&#39;datasets/disney_movies_total_gross.csv&#39;, parse_dates=[&#39;release_date&#39;]) # Print out gross gross.head() . movie_title release_date genre mpaa_rating total_gross inflation_adjusted_gross . 0 Snow White and the Seven Dwarfs | 1937-12-21 | Musical | G | 184925485 | 5228953251 | . 1 Pinocchio | 1940-02-09 | Adventure | G | 84300000 | 2188229052 | . 2 Fantasia | 1940-11-13 | Musical | G | 83320000 | 2187090808 | . 3 Song of the South | 1946-11-12 | Adventure | G | 65000000 | 1078510579 | . 4 Cinderella | 1950-02-15 | Drama | G | 85000000 | 920608730 | . 2. Top ten movies at the box office . Let&#39;s started by exploring the data. We will check which are the 10 Disney movies that have earned the most at the box office. We can do this by sorting movies by their inflation-adjusted gross (we will call it adjusted gross from this point onward). . # ... YOUR CODE FOR TASK 2 ... gross = gross.sort_values(&#39;inflation_adjusted_gross&#39;, ascending=False) # Display the top 10 movies # ... YOUR CODE FOR TASK 2 ... gross.head(10) . movie_title release_date genre mpaa_rating total_gross inflation_adjusted_gross . 0 Snow White and the Seven Dwarfs | 1937-12-21 | Musical | G | 184925485 | 5228953251 | . 1 Pinocchio | 1940-02-09 | Adventure | G | 84300000 | 2188229052 | . 2 Fantasia | 1940-11-13 | Musical | G | 83320000 | 2187090808 | . 8 101 Dalmatians | 1961-01-25 | Comedy | G | 153000000 | 1362870985 | . 6 Lady and the Tramp | 1955-06-22 | Drama | G | 93600000 | 1236035515 | . 3 Song of the South | 1946-11-12 | Adventure | G | 65000000 | 1078510579 | . 564 Star Wars Ep. VII: The Force Awakens | 2015-12-18 | Adventure | PG-13 | 936662225 | 936662225 | . 4 Cinderella | 1950-02-15 | Drama | G | 85000000 | 920608730 | . 13 The Jungle Book | 1967-10-18 | Musical | Not Rated | 141843000 | 789612346 | . 179 The Lion King | 1994-06-15 | Adventure | G | 422780140 | 761640898 | . 3. Movie genre trend . From the top 10 movies above, it seems that some genres are more popular than others. So, we will check which genres are growing stronger in popularity. To do this, we will group movies by genre and then by year to see the adjusted gross of each genre in each year. . gross[&#39;release_year&#39;] = gross[&#39;release_date&#39;].dt.year # Compute mean of adjusted gross per genre and per year group = gross.groupby([&#39;genre&#39;, &#39;release_year&#39;]).mean() # Convert the GroupBy object to a DataFrame genre_yearly = group.reset_index() # Inspect genre_yearly genre_yearly.head(10) . genre release_year total_gross inflation_adjusted_gross . 0 Action | 1981 | 0.0 | 0.0 | . 1 Action | 1982 | 26918576.0 | 77184895.0 | . 2 Action | 1988 | 17577696.0 | 36053517.0 | . 3 Action | 1990 | 59249588.5 | 118358772.0 | . 4 Action | 1991 | 28924936.5 | 57918572.5 | . 5 Action | 1992 | 29028000.0 | 58965304.0 | . 6 Action | 1993 | 21943553.5 | 44682157.0 | . 7 Action | 1994 | 19180582.0 | 39545796.0 | . 8 Action | 1995 | 63037553.5 | 122162426.5 | . 9 Action | 1996 | 135281096.0 | 257755262.5 | . 4. Visualize the genre popularity trend . We will make a plot out of these means of groups to better see how box office revenues have changed over time. . # ... YOUR CODE FOR TASK 4 ... import seaborn as sns # Plot the data # ... YOUR CODE FOR TASK 4 ... sns.relplot(kind=&#39;line&#39;, x=&#39;release_year&#39;, y=&#39;inflation_adjusted_gross&#39;, data=genre_yearly, hue=&#39;genre&#39;) . &lt;seaborn.axisgrid.FacetGrid at 0x7fe115d51400&gt; . 5. Data transformation . The line plot supports our belief that some genres are growing faster in popularity than others. For Disney movies, Action and Adventure genres are growing the fastest. Next, we will build a linear regression model to understand the relationship between genre and box office gross. . Since linear regression requires numerical variables and the genre variable is a categorical variable, we&#39;ll use a technique called one-hot encoding to convert the categorical variables to numerical. This technique transforms each category value into a new column and assigns a 1 or 0 to the column. . For this dataset, there will be 11 dummy variables, one for each genre except the action genre which we will use as a baseline. For example, if a movie is an adventure movie, like The Lion King, the adventure variable will be 1 and other dummy variables will be 0. Since the action genre is our baseline, if a movie is an action movie, such as The Avengers, all dummy variables will be 0. . genre_dummies = pd.get_dummies(gross[&#39;genre&#39;], drop_first=True) # Inspect genre_dummies genre_dummies.head() . Adventure Black Comedy Comedy Concert/Performance Documentary Drama Horror Musical Romantic Comedy Thriller/Suspense Western . 0 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | . 1 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | . 2 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | . 8 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | . 6 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | . 6. The genre effect . Now that we have dummy variables, we can build a linear regression model to predict the adjusted gross using these dummy variables. . From the regression model, we can check the effect of each genre by looking at its coefficient given in units of box office gross dollars. We will focus on the impact of action and adventure genres here. (Note that the intercept and the first coefficient values represent the effect of action and adventure genres respectively). We expect that movies like the Lion King or Star Wars would perform better for box office. . # ... YOUR CODE FOR TASK 6 ... from sklearn.linear_model import LinearRegression # Build a linear regression model regr = LinearRegression() # Fit regr to the dataset # ... YOUR CODE FOR TASK 6 ... regr.fit(genre_dummies, gross[&#39;inflation_adjusted_gross&#39;]) # Get estimated intercept and coefficient values action = regr.intercept_ adventure = regr.coef_[[0]][0] # Inspect the estimated intercept and coefficient values print((action, adventure)) . (102921757.36842026, 87475654.70909917) . 7. Confidence intervals for regression parameters (i) . Next, we will compute 95% confidence intervals for the intercept and coefficients. The 95% confidence intervals for the intercept a and coefficient bi means that the intervals have a probability of 95% to contain the true value a and coefficient bi respectively. If there is a significant relationship between a given genre and the adjusted gross, the confidence interval of its coefficient should exclude 0. . We will calculate the confidence intervals using the pairs bootstrap method. . import numpy as np # Create an array of indices to sample from inds = np.arange(0, len(gross[&#39;genre&#39;])) # Initialize 500 replicate arrays size = 500 bs_action_reps = np.empty(size) bs_adventure_reps = np.empty(size) . 8. Confidence intervals for regression parameters (ii) . After the initialization, we will perform pair bootstrap estimates for the regression parameters. Note that we will draw a sample from a set of (genre, adjusted gross) data where the genre is the original genre variable. We will perform one-hot encoding after that. . for i in range(size): # Resample the indices bs_inds = np.random.choice(inds, size=len(inds)) # Get the sampled genre and sampled adjusted gross bs_genre = gross[&#39;genre&#39;][bs_inds] bs_gross = gross[&#39;inflation_adjusted_gross&#39;][bs_inds] # Convert sampled genre to dummy variables bs_dummies = pd.get_dummies(bs_genre, drop_first=True) # Build and fit a regression model regr = LinearRegression().fit(bs_dummies, bs_gross) # Compute replicates of estimated intercept and coefficient bs_action_reps[i] = regr.intercept_ bs_adventure_reps[i] = regr.coef_[[0]][0] . 9. Confidence intervals for regression parameters (iii) . Finally, we compute 95% confidence intervals for the intercept and coefficient and examine if they exclude 0. If one of them (or both) does, then it is unlikely that the value is 0 and we can conclude that there is a significant relationship between that genre and the adjusted gross. . confidence_interval_action = np.percentile(bs_action_reps, [2.5, 97.5]) confidence_interval_adventure = np.percentile(bs_adventure_reps, [2.5, 97.5]) # Inspect the confidence intervals print(confidence_interval_action) print(confidence_interval_adventure) . AxisError Traceback (most recent call last) &lt;ipython-input-25-ab35250ede16&gt; in &lt;module&gt; 1 # Compute 95% confidence intervals for intercept and coefficient values -&gt; 2 confidence_interval_action = np.percentile(bs_action_reps, 0.95, axis=1) 3 confidence_interval_adventure = np.percentile(bs_adventure_reps, 0.95, axis=1) 4 5 # Inspect the confidence intervals &lt;__array_function__ internals&gt; in percentile(*args, **kwargs) /usr/local/lib/python3.6/dist-packages/numpy/lib/function_base.py in percentile(a, q, axis, out, overwrite_input, interpolation, keepdims) 3731 raise ValueError(&#34;Percentiles must be in the range [0, 100]&#34;) 3732 return _quantile_unchecked( -&gt; 3733 a, q, axis, out, overwrite_input, interpolation, keepdims) 3734 3735 /usr/local/lib/python3.6/dist-packages/numpy/lib/function_base.py in _quantile_unchecked(a, q, axis, out, overwrite_input, interpolation, keepdims) 3851 r, k = _ureduce(a, func=_quantile_ureduce_func, q=q, axis=axis, out=out, 3852 overwrite_input=overwrite_input, -&gt; 3853 interpolation=interpolation) 3854 if keepdims: 3855 return r.reshape(q.shape + k) /usr/local/lib/python3.6/dist-packages/numpy/lib/function_base.py in _ureduce(a, func, **kwargs) 3407 keepdim = list(a.shape) 3408 nd = a.ndim -&gt; 3409 axis = _nx.normalize_axis_tuple(axis, nd) 3410 3411 for ax in axis: /usr/local/lib/python3.6/dist-packages/numpy/core/numeric.py in normalize_axis_tuple(axis, ndim, argname, allow_duplicate) 1356 pass 1357 # Going via an iterator directly is slower than via list comprehension. -&gt; 1358 axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis]) 1359 if not allow_duplicate and len(set(axis)) != len(axis): 1360 if argname: /usr/local/lib/python3.6/dist-packages/numpy/core/numeric.py in &lt;listcomp&gt;(.0) 1356 pass 1357 # Going via an iterator directly is slower than via list comprehension. -&gt; 1358 axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis]) 1359 if not allow_duplicate and len(set(axis)) != len(axis): 1360 if argname: AxisError: axis 1 is out of bounds for array of dimension 1 . type(confidence_interval_action) . numpy.float64 . 10. Should Disney make more action and adventure movies? . The confidence intervals from the bootstrap method for the intercept and coefficient do not contain the value zero, as we have already seen that lower and upper bounds of both confidence intervals are positive. These tell us that it is likely that the adjusted gross is significantly correlated with the action and adventure genres. . From the results of the bootstrap analysis and the trend plot we have done earlier, we could say that Disney movies with plots that fit into the action and adventure genre, according to our data, tend to do better in terms of adjusted gross than other genres. So we could expect more Marvel, Star Wars, and live-action movies in the upcoming years! . more_action_adventure_movies = True .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/30/Disney-Movies-and-Box-Office-Success.html",
            "relUrl": "/datacamp/projects/python/2021/03/30/Disney-Movies-and-Box-Office-Success.html",
            "date": " • Mar 30, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "Classify Song Genres from Audio Data",
            "content": "1. Preparing our dataset . These recommendations are so on point! How does this playlist know me so well? . . Over the past few years, streaming services with huge catalogs have become the primary means through which most people listen to their favorite music. But at the same time, the sheer amount of music on offer can mean users might be a bit overwhelmed when trying to look for newer music that suits their tastes. . For this reason, streaming services have looked into means of categorizing music to allow for personalized recommendations. One method involves direct analysis of the raw audio information in a given song, scoring the raw data on a variety of metrics. Today, we&#39;ll be examining data compiled by a research group known as The Echo Nest. Our goal is to look through this dataset and classify songs as being either &#39;Hip-Hop&#39; or &#39;Rock&#39; - all without listening to a single one ourselves. In doing so, we will learn how to clean our data, do some exploratory data visualization, and use feature reduction towards the goal of feeding our data through some simple machine learning algorithms, such as decision trees and logistic regression. . To begin with, let&#39;s load the metadata about our tracks alongside the track metrics compiled by The Echo Nest. A song is about more than its title, artist, and number of listens. We have another dataset that has musical features of each track such as danceability and acousticness on a scale from -1 to 1. These exist in two different files, which are in different formats - CSV and JSON. While CSV is a popular file format for denoting tabular data, JSON is another common file format in which databases often return the results of a given query. . Let&#39;s start by creating two pandas DataFrames out of these files that we can merge so we have features and labels (often also referred to as X and y) for the classification later on. . import pandas as pd # Read in track metadata with genre labels tracks = pd.read_csv(&#39;datasets/fma-rock-vs-hiphop.csv&#39;) # Read in track metrics with the features echonest_metrics = pd.read_json(&#39;datasets/echonest-metrics.json&#39;, precise_float=True) # Merge the relevant columns of tracks and echonest_metrics echo_tracks = echonest_metrics.merge(tracks[[&#39;track_id&#39;, &#39;genre_top&#39;]], on=&#39;track_id&#39;) # Inspect the resultant dataframe echo_tracks.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 4802 entries, 0 to 4801 Data columns (total 10 columns): acousticness 4802 non-null float64 danceability 4802 non-null float64 energy 4802 non-null float64 instrumentalness 4802 non-null float64 liveness 4802 non-null float64 speechiness 4802 non-null float64 tempo 4802 non-null float64 track_id 4802 non-null int64 valence 4802 non-null float64 genre_top 4802 non-null object dtypes: float64(8), int64(1), object(1) memory usage: 412.7+ KB . 2. Pairwise relationships between continuous variables . We typically want to avoid using variables that have strong correlations with each other -- hence avoiding feature redundancy -- for a few reasons: . To keep the model simple and improve interpretability (with many features, we run the risk of overfitting). | When our datasets are very large, using fewer features can drastically speed up our computation time. | . To get a sense of whether there are any strongly correlated features in our data, we will use built-in functions in the pandas package. . corr_metrics = echo_tracks.corr() corr_metrics.style.background_gradient() . acousticness danceability energy instrumentalness liveness speechiness tempo track_id valence . acousticness 1 | -0.0289537 | -0.281619 | 0.19478 | -0.0199914 | 0.072204 | -0.0263097 | -0.372282 | -0.0138406 | . danceability -0.0289537 | 1 | -0.242032 | -0.255217 | -0.106584 | 0.276206 | -0.242089 | 0.0494541 | 0.473165 | . energy -0.281619 | -0.242032 | 1 | 0.0282377 | 0.113331 | -0.109983 | 0.195227 | 0.140703 | 0.0386027 | . instrumentalness 0.19478 | -0.255217 | 0.0282377 | 1 | -0.0910218 | -0.366762 | 0.022215 | -0.275623 | -0.219967 | . liveness -0.0199914 | -0.106584 | 0.113331 | -0.0910218 | 1 | 0.0411725 | 0.00273169 | 0.0482307 | -0.0450931 | . speechiness 0.072204 | 0.276206 | -0.109983 | -0.366762 | 0.0411725 | 1 | 0.00824055 | -0.0269951 | 0.149894 | . tempo -0.0263097 | -0.242089 | 0.195227 | 0.022215 | 0.00273169 | 0.00824055 | 1 | -0.0253918 | 0.0522212 | . track_id -0.372282 | 0.0494541 | 0.140703 | -0.275623 | 0.0482307 | -0.0269951 | -0.0253918 | 1 | 0.0100698 | . valence -0.0138406 | 0.473165 | 0.0386027 | -0.219967 | -0.0450931 | 0.149894 | 0.0522212 | 0.0100698 | 1 | . 3. Normalizing the feature data . As mentioned earlier, it can be particularly useful to simplify our models and use as few features as necessary to achieve the best result. Since we didn&#39;t find any particular strong correlations between our features, we can instead use a common approach to reduce the number of features called principal component analysis (PCA). . It is possible that the variance between genres can be explained by just a few features in the dataset. PCA rotates the data along the axis of highest variance, thus allowing us to determine the relative contribution of each feature of our data towards the variance between classes. . However, since PCA uses the absolute variance of a feature to rotate the data, a feature with a broader range of values will overpower and bias the algorithm relative to the other features. To avoid this, we must first normalize our data. There are a few methods to do this, but a common way is through standardization, such that all features have a mean = 0 and standard deviation = 1 (the resultant is a z-score). . features = echo_tracks.drop([&#39;genre_top&#39;, &#39;track_id&#39;], axis=1) # Define our labels labels = echo_tracks[&#39;genre_top&#39;] # Import the StandardScaler from sklearn.preprocessing import StandardScaler # Scale the features and set the values to a new variable scaler = StandardScaler() scaled_train_features = scaler.fit_transform(features) . 4. Principal Component Analysis on our scaled data . Now that we have preprocessed our data, we are ready to use PCA to determine by how much we can reduce the dimensionality of our data. We can use scree-plots and cumulative explained ratio plots to find the number of components to use in further analyses. . Scree-plots display the number of components against the variance explained by each component, sorted in descending order of variance. Scree-plots help us get a better sense of which components explain a sufficient amount of variance in our data. When using scree plots, an &#39;elbow&#39; (a steep drop from one data point to the next) in the plot is typically used to decide on an appropriate cutoff. . %matplotlib inline # Import our plotting module, and PCA class #... YOUR CODE ... import matplotlib.pyplot as plt from sklearn.decomposition import PCA # Get our explained variance ratios from PCA using all features pca = PCA() pca.fit(scaled_train_features) exp_variance = pca.explained_variance_ratio_ # plot the explained variance using a barplot fig, ax = plt.subplots() ax.bar(range(features.shape[1]), exp_variance) ax.set_xlabel(&#39;Principal Component #&#39;) . Text(0.5,0,&#39;Principal Component #&#39;) . 5. Further visualization of PCA . Unfortunately, there does not appear to be a clear elbow in this scree plot, which means it is not straightforward to find the number of intrinsic dimensions using this method. . But all is not lost! Instead, we can also look at the cumulative explained variance plot to determine how many features are required to explain, say, about 85% of the variance (cutoffs are somewhat arbitrary here, and usually decided upon by &#39;rules of thumb&#39;). Once we determine the appropriate number of components, we can perform PCA with that many components, ideally reducing the dimensionality of our data. . import numpy as np # Calculate the cumulative explained variance cum_exp_variance = np.cumsum(pca.explained_variance_ratio_) # Plot the cumulative explained variance and draw a dashed line at 0.85. fig, ax = plt.subplots() ax.plot(range(features.shape[1]), cum_exp_variance) ax.axhline(y=0.85, linestyle=&#39;--&#39;) # choose the n_components where about 85% of our variance can be explained n_components = (cum_exp_variance &lt; 0.85).sum() + 1 # Perform PCA with the chosen number of components and project data onto components pca = PCA(n_components, random_state=10) pca.fit(scaled_train_features) pca_projection = pca.transform(scaled_train_features) . 6. Train a decision tree to classify genre . Now we can use the lower dimensional PCA projection of the data to classify songs into genres. To do that, we first need to split our dataset into &#39;train&#39; and &#39;test&#39; subsets, where the &#39;train&#39; subset will be used to train our model while the &#39;test&#39; dataset allows for model performance validation. . Here, we will be using a simple algorithm known as a decision tree. Decision trees are rule-based classifiers that take in features and follow a &#39;tree structure&#39; of binary decisions to ultimately classify a data point into one of two or more categories. In addition to being easy to both use and interpret, decision trees allow us to visualize the &#39;logic flowchart&#39; that the model generates from the training data. . Here is an example of a decision tree that demonstrates the process by which an input image (in this case, of a shape) might be classified based on the number of sides it has and whether it is rotated. . . # ... YOUR CODE ... from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier # Split our data train_features, test_features, train_labels, test_labels = train_test_split(pca_projection, labels, random_state=10) # Train our decision tree tree = DecisionTreeClassifier(random_state=10) tree.fit(train_features, train_labels) # Predict the labels for the test data pred_labels_tree = tree.predict(test_features) . 7. Compare our decision tree to a logistic regression . Although our tree&#39;s performance is decent, it&#39;s a bad idea to immediately assume that it&#39;s therefore the perfect tool for this job -- there&#39;s always the possibility of other models that will perform even better! It&#39;s always a worthwhile idea to at least test a few other algorithms and find the one that&#39;s best for our data. . Sometimes simplest is best, and so we will start by applying logistic regression. Logistic regression makes use of what&#39;s called the logistic function to calculate the odds that a given data point belongs to a given class. Once we have both models, we can compare them on a few performance metrics, such as false positive and false negative rate (or how many points are inaccurately classified). . from sklearn.linear_model import LogisticRegression # Train our logistic regression and predict labels for the test set logreg = LogisticRegression(random_state=10) logreg.fit(train_features, train_labels) pred_labels_logit = logreg.predict(test_features) # Create the classification report for both models from sklearn.metrics import classification_report class_rep_tree = classification_report(test_labels, pred_labels_tree) class_rep_log = classification_report(test_labels, pred_labels_logit) print(&quot;Decision Tree: n&quot;, class_rep_tree) print(&quot;Logistic Regression: n&quot;, class_rep_log) . Decision Tree: precision recall f1-score support Hip-Hop 0.66 0.66 0.66 229 Rock 0.92 0.92 0.92 972 avg / total 0.87 0.87 0.87 1201 Logistic Regression: precision recall f1-score support Hip-Hop 0.75 0.57 0.65 229 Rock 0.90 0.95 0.93 972 avg / total 0.87 0.88 0.87 1201 . 8. Balance our data for greater performance . Both our models do similarly well, boasting an average precision of 87% each. However, looking at our classification report, we can see that rock songs are fairly well classified, but hip-hop songs are disproportionately misclassified as rock songs. . Why might this be the case? Well, just by looking at the number of data points we have for each class, we see that we have far more data points for the rock classification than for hip-hop, potentially skewing our model&#39;s ability to distinguish between classes. This also tells us that most of our model&#39;s accuracy is driven by its ability to classify just rock songs, which is less than ideal. . To account for this, we can weight the value of a correct classification in each class inversely to the occurrence of data points for each class. Since a correct classification for &quot;Rock&quot; is not more important than a correct classification for &quot;Hip-Hop&quot; (and vice versa), we only need to account for differences in sample size of our data points when weighting our classes here, and not relative importance of each class. . hop_only = echo_tracks.loc[echo_tracks[&#39;genre_top&#39;] == &#39;Hip-Hop&#39;] rock_only = echo_tracks.loc[echo_tracks[&#39;genre_top&#39;] == &#39;Rock&#39;] # sample the rocks songs to be the same number as there are hip-hop songs rock_only = rock_only.sample(len(hop_only), random_state=10) # concatenate the dataframes rock_only and hop_only rock_hop_bal = pd.concat([rock_only, hop_only]) # The features, labels, and pca projection are created for the balanced dataframe features = rock_hop_bal.drop([&#39;genre_top&#39;, &#39;track_id&#39;], axis=1) labels = rock_hop_bal[&#39;genre_top&#39;] pca_projection = pca.fit_transform(scaler.fit_transform(features)) # Redefine the train and test set with the pca_projection from the balanced data train_features, test_features, train_labels, test_labels = train_test_split(pca_projection, labels, random_state=10) . 9. Does balancing our dataset improve model bias? . We&#39;ve now balanced our dataset, but in doing so, we&#39;ve removed a lot of data points that might have been crucial to training our models. Let&#39;s test to see if balancing our data improves model bias towards the &quot;Rock&quot; classification while retaining overall classification performance. . Note that we have already reduced the size of our dataset and will go forward without applying any dimensionality reduction. In practice, we would consider dimensionality reduction more rigorously when dealing with vastly large datasets and when computation times become prohibitively large. . tree = DecisionTreeClassifier(random_state=10) tree.fit(train_features, train_labels) pred_labels_tree = tree.predict(test_features) # Train our logistic regression on the balanced data logreg = LogisticRegression(random_state=10) logreg.fit(train_features, train_labels) pred_labels_logit = logreg.predict(test_features) # Compare the models print(&quot;Decision Tree: n&quot;, classification_report(test_labels, pred_labels_tree)) print(&quot;Logistic Regression: n&quot;, classification_report(test_labels, pred_labels_logit)) . Decision Tree: precision recall f1-score support Hip-Hop 0.77 0.77 0.77 230 Rock 0.76 0.76 0.76 225 avg / total 0.76 0.76 0.76 455 Logistic Regression: precision recall f1-score support Hip-Hop 0.82 0.83 0.82 230 Rock 0.82 0.81 0.82 225 avg / total 0.82 0.82 0.82 455 . 10. Using cross-validation to evaluate our models . Success! Balancing our data has removed bias towards the more prevalent class. To get a good sense of how well our models are actually performing, we can apply what&#39;s called cross-validation (CV). This step allows us to compare models in a more rigorous fashion. . Since the way our data is split into train and test sets can impact model performance, CV attempts to split the data multiple ways and test the model on each of the splits. Although there are many different CV methods, all with their own advantages and disadvantages, we will use what&#39;s known as K-fold CV here. K-fold first splits the data into K different, equally sized subsets. Then, it iteratively uses each subset as a test set while using the remainder of the data as train sets. Finally, we can then aggregate the results from each fold for a final model performance score. . from sklearn.model_selection import KFold, cross_val_score # Set up our K-fold cross-validation kf = KFold(n_splits=10) tree = DecisionTreeClassifier() logreg = LogisticRegression() # Train our models using KFold cv tree_score = cross_val_score(tree, pca_projection, labels) logit_score = cross_val_score(logreg, pca_projection, labels) # Print the mean of each array of scores print(&quot;Decision Tree:&quot;, np.mean(tree_score), &quot;Logistic Regression:&quot;, np.mean(logit_score)) . Decision Tree: 0.7538720977360894 Logistic Regression: 0.8076960656591975 .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/30/Classify-Song-Genres-from-Audio-Data.html",
            "relUrl": "/datacamp/projects/python/2021/03/30/Classify-Song-Genres-from-Audio-Data.html",
            "date": " • Mar 30, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "ASL Recognition with Deep Learning",
            "content": "1. American Sign Language (ASL) . American Sign Language (ASL) is the primary language used by many deaf individuals in North America, and it is also used by hard-of-hearing and hearing individuals. The language is as rich as spoken languages and employs signs made with the hand, along with facial gestures and bodily postures. . . A lot of recent progress has been made towards developing computer vision systems that translate sign language to spoken language. This technology often relies on complex neural network architectures that can detect subtle patterns in streaming video. However, as a first step, towards understanding how to build a translation system, we can reduce the size of the problem by translating individual letters, instead of sentences. . In this notebook, we will train a convolutional neural network to classify images of American Sign Language (ASL) letters. After loading, examining, and preprocessing the data, we will train the network and test its performance. . In the code cell below, we load the training and test data. . x_train and x_test are arrays of image data with shape (num_samples, 3, 50, 50), corresponding to the training and test datasets, respectively. | y_train and y_test are arrays of category labels with shape (num_samples,), corresponding to the training and test datasets, respectively. | . import numpy as np np.random.seed(5) import tensorflow as tf tf.set_random_seed(2) from datasets import sign_language import matplotlib.pyplot as plt %matplotlib inline # Load pre-shuffled training and test datasets (x_train, y_train), (x_test, y_test) = sign_language.load_data() . Using TensorFlow backend. . 2. Visualize the training data . Now we&#39;ll begin by creating a list of string-valued labels containing the letters that appear in the dataset. Then, we visualize the first several images in the training data, along with their corresponding labels. . labels = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] # Print the first several training images, along with the labels fig = plt.figure(figsize=(20,5)) for i in range(36): ax = fig.add_subplot(3, 12, i + 1, xticks=[], yticks=[]) ax.imshow(np.squeeze(x_train[i])) ax.set_title(&quot;{}&quot;.format(labels[y_train[i]])) plt.show() . 3. Examine the dataset . Let&#39;s examine how many images of each letter can be found in the dataset. . Remember that dataset has already been split into training and test sets for you, where x_train and x_test contain the images, and y_train and y_test contain their corresponding labels. . Each entry in y_train and y_test is one of 0, 1, or 2, corresponding to the letters &#39;A&#39;, &#39;B&#39;, and &#39;C&#39;, respectively. . We will use the arrays y_train and y_test to verify that both the training and test sets each have roughly equal proportions of each letter. . num_A_train = sum(y_train==0) # Number of B&#39;s in the training dataset num_B_train = sum(y_train==1) # Number of C&#39;s in the training dataset num_C_train = sum(y_train==2) # Number of A&#39;s in the test dataset num_A_test = sum(y_test==0) # Number of B&#39;s in the test dataset num_B_test = sum(y_test==1) # Number of C&#39;s in the test dataset num_C_test = sum(y_test==2) # Print statistics about the dataset print(&quot;Training set:&quot;) print(&quot; tA: {}, B: {}, C: {}&quot;.format(num_A_train, num_B_train, num_C_train)) print(&quot;Test set:&quot;) print(&quot; tA: {}, B: {}, C: {}&quot;.format(num_A_test, num_B_test, num_C_test)) . Training set: A: 540, B: 528, C: 532 Test set: A: 118, B: 144, C: 138 . 4. One-hot encode the data . Currently, our labels for each of the letters are encoded as categorical integers, where &#39;A&#39;, &#39;B&#39; and &#39;C&#39; are encoded as 0, 1, and 2, respectively. However, recall that Keras models do not accept labels in this format, and we must first one-hot encode the labels before supplying them to a Keras model. . This conversion will turn the one-dimensional array of labels into a two-dimensional array. . . Each row in the two-dimensional array of one-hot encoded labels corresponds to a different image. The row has a 1 in the column that corresponds to the correct label, and 0 elsewhere. . For instance, . 0 is encoded as [1, 0, 0], | 1 is encoded as [0, 1, 0], and | 2 is encoded as [0, 0, 1]. | . from keras.utils import np_utils # One-hot encode the training labels y_train_OH = np_utils.to_categorical(y_train) # One-hot encode the test labels y_test_OH = np_utils.to_categorical(y_test) . 5. Define the model . Now it&#39;s time to define a convolutional neural network to classify the data. . This network accepts an image of an American Sign Language letter as input. The output layer returns the network&#39;s predicted probabilities that the image belongs in each category. . from keras.layers import Conv2D, MaxPooling2D from keras.layers import Flatten, Dense from keras.models import Sequential model = Sequential() # First convolutional layer accepts image input model.add(Conv2D(filters=5, kernel_size=5, padding=&#39;same&#39;, activation=&#39;relu&#39;, input_shape=(50, 50, 3))) # Add a max pooling layer model.add(MaxPooling2D((4, 4))) # Add a convolutional layer model.add(Conv2D(filters=15, kernel_size=5, padding=&#39;same&#39;, activation=&#39;relu&#39;)) # Add another max pooling layer model.add(MaxPooling2D((4, 4))) # Flatten and feed to output layer model.add(Flatten()) model.add(Dense(3, activation=&#39;softmax&#39;)) # Summarize the model model.summary() . _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d_1 (Conv2D) (None, 50, 50, 5) 380 _________________________________________________________________ max_pooling2d_1 (MaxPooling2 (None, 12, 12, 5) 0 _________________________________________________________________ conv2d_2 (Conv2D) (None, 12, 12, 15) 1890 _________________________________________________________________ max_pooling2d_2 (MaxPooling2 (None, 3, 3, 15) 0 _________________________________________________________________ flatten_1 (Flatten) (None, 135) 0 _________________________________________________________________ dense_1 (Dense) (None, 3) 408 ================================================================= Total params: 2,678 Trainable params: 2,678 Non-trainable params: 0 _________________________________________________________________ . 6. Compile the model . After we have defined a neural network in Keras, the next step is to compile it! . model.compile(optimizer=&#39;rmsprop&#39;, loss=&#39;categorical_crossentropy&#39;, metrics=[&#39;accuracy&#39;]) . 7. Train the model . Once we have compiled the model, we&#39;re ready to fit it to the training data. . hist = model.fit(x=x_train, y=y_train_OH, epochs=2, validation_split=0.2, batch_size=32) . Train on 1280 samples, validate on 320 samples Epoch 1/2 1280/1280 [==============================] - 2s 2ms/step - loss: 0.9560 - acc: 0.6164 - val_loss: 0.7627 - val_acc: 0.8500 Epoch 2/2 1280/1280 [==============================] - 2s 2ms/step - loss: 0.6086 - acc: 0.8875 - val_loss: 0.4636 - val_acc: 0.9187 . 8. Test the model . To evaluate the model, we&#39;ll use the test dataset. This will tell us how the network performs when classifying images it has never seen before! . If the classification accuracy on the test dataset is similar to the training dataset, this is a good sign that the model did not overfit to the training data. . score = model.evaluate(x=x_test, y=y_test_OH, verbose=0) print(&#39;Test accuracy:&#39;, score[1]) . Test accuracy: 0.94 . 9. Visualize mistakes . Hooray! Our network gets very high accuracy on the test set! . The final step is to take a look at the images that were incorrectly classified by the model. Do any of the mislabeled images look relatively difficult to classify, even to the human eye? . Sometimes, it&#39;s possible to review the images to discover special characteristics that are confusing to the model. However, it is also often the case that it&#39;s hard to interpret what the model had in mind! . y_probs = model.predict(x_test) # Get predicted labels for test dataset y_preds = np.argmax(y_probs, axis=1) # Indices corresponding to test images which were mislabeled bad_test_idxs = np.arange(len(y_test))[y_test != y_preds] # Print mislabeled examples fig = plt.figure(figsize=(25,4)) for i, idx in enumerate(bad_test_idxs): ax = fig.add_subplot(2, np.ceil(len(bad_test_idxs)/2), i + 1, xticks=[], yticks=[]) ax.imshow(np.squeeze(x_test[idx])) ax.set_title(&quot;{} (pred: {})&quot;.format(labels[y_test[idx]], labels[y_preds[idx]])) .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/30/ASL-Recognition-with-Deep-Learning.html",
            "relUrl": "/datacamp/projects/python/2021/03/30/ASL-Recognition-with-Deep-Learning.html",
            "date": " • Mar 30, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "Naive Bees Predict Species from Images",
            "content": "1. Import Python libraries . A honey bee (Apis). . Can a machine identify a bee as a honey bee or a bumble bee? These bees have different behaviors and appearances, but given the variety of backgrounds, positions, and image resolutions, it can be a challenge for machines to tell them apart. . Being able to identify bee species from images is a task that ultimately would allow researchers to more quickly and effectively collect field data. Pollinating bees have critical roles in both ecology and agriculture, and diseases like colony collapse disorder threaten these species. Identifying different species of bees in the wild means that we can better understand the prevalence and growth of these important insects. . A bumble bee (Bombus). . After loading and pre-processing images, this notebook walks through building a model that can automatically detect honey bees and bumble bees. . import os import matplotlib as mpl import matplotlib.pyplot as plt from IPython.display import display %matplotlib inline import pandas as pd import numpy as np # import Image from PIL # ... YOUR CODE FOR TASK 1 ... from PIL import Image from skimage.feature import hog from skimage.color import rgb2grey from sklearn.preprocessing import StandardScaler from sklearn.decomposition import PCA # import train_test_split from sklearn&#39;s model selection module # ... YOUR CODE FOR TASK 1 ... from sklearn.model_selection import train_test_split # import SVC from sklearn&#39;s svm module # ... YOUR CODE FOR TASK 1 ... from sklearn.svm import SVC # import accuracy_score from sklearn&#39;s metrics module from sklearn.metrics import roc_curve, auc, accuracy_score . 2. Display image of each bee type . Now that we have all of our imports ready, it is time to look at some images. We will load our labels.csv file into a dataframe called labels, where the index is the image name (e.g. an index of 1036 refers to an image named 1036.jpg) and the genus column tells us the bee type. genus takes the value of either 0.0 (Apis or honey bee) or 1.0 (Bombus or bumble bee). . The function get_image converts an index value from the dataframe into a file path where the image is located, opens the image using the Image object in Pillow, and then returns the image as a numpy array. . We&#39;ll use this function to load the sixth Apis image and then the sixth Bombus image in the dataframe. . labels = pd.read_csv(&quot;datasets/labels.csv&quot;, index_col=0) # show the first five rows of the dataframe using head display(labels.head()) def get_image(row_id, root=&quot;datasets/&quot;): &quot;&quot;&quot; Converts an image number into the file path where the image is located, opens the image, and returns the image as a numpy array. &quot;&quot;&quot; filename = &quot;{}.jpg&quot;.format(row_id) file_path = os.path.join(root, filename) img = Image.open(file_path) return np.array(img) # subset the dataframe to just Apis (genus is 0.0) get the value of the sixth item in the index apis_row = labels[labels.genus == 0.0].index[5] # show the corresponding image of an Apis plt.imshow(get_image(apis_row)) plt.show() # subset the dataframe to just Bombus (genus is 1.0) get the value of the sixth item in the index bombus_row = labels[labels.genus == 1.0].index[5] # show the corresponding image of a Bombus plt.imshow(get_image(bombus_row)) plt.show() . genus . id . 520 1.0 | . 3800 1.0 | . 3289 1.0 | . 2695 1.0 | . 4922 1.0 | . 3. Image manipulation with rgb2grey . scikit-image has a number of image processing functions built into the library, for example, converting an image to greyscale. The rgb2grey function computes the luminance of an RGB image using the following formula Y = 0.2125 R + 0.7154 G + 0.0721 B. . Image data is represented as a matrix, where the depth is the number of channels. An RGB image has three channels (red, green, and blue) whereas the returned greyscale image has only one channel. Accordingly, the original color image has the dimensions 100x100x3 but after calling rgb2grey, the resulting greyscale image has only one channel, making the dimensions 100x100x1. . bombus = get_image(bombus_row) # print the shape of the bombus image print(&#39;Color bombus image has shape: &#39;, bombus.shape) # convert the bombus image to greyscale grey_bombus = rgb2grey(bombus) # show the greyscale image plt.imshow(grey_bombus, cmap=mpl.cm.gray) # greyscale bombus image only has one channel print(&#39;Greyscale bombus image has shape: &#39;, grey_bombus.shape) . Color bombus image has shape: (100, 100, 3) Greyscale bombus image has shape: (100, 100) . 4. Histogram of oriented gradients . Now we need to turn these images into something that a machine learning algorithm can understand. Traditional computer vision techniques have relied on mathematical transforms to turn images into useful features. For example, you may want to detect edges of objects in an image, increase the contrast, or filter out particular colors. . We&#39;ve got a matrix of pixel values, but those don&#39;t contain enough interesting information on their own for most algorithms. We need to help the algorithms along by picking out some of the salient features for them using the histogram of oriented gradients (HOG) descriptor. The idea behind HOG is that an object&#39;s shape within an image can be inferred by its edges, and a way to identify edges is by looking at the direction of intensity gradients (i.e. changes in luminescence). . . An image is divided in a grid fashion into cells, and for the pixels within each cell, a histogram of gradient directions is compiled. To improve invariance to highlights and shadows in an image, cells are block normalized, meaning an intensity value is calculated for a larger region of an image called a block and used to contrast normalize all cell-level histograms within each block. The HOG feature vector for the image is the concatenation of these cell-level histograms. . hog_features, hog_image = hog(bombus, visualize=True, block_norm=&#39;L2-Hys&#39;, pixels_per_cell=(16, 16)) # show our hog_image with a grey colormap plt.imshow(hog_image, cmap=mpl.cm.gray) . &lt;matplotlib.image.AxesImage at 0x7fd10a58b358&gt; . 5. Create image features and flatten into a single row . Algorithms require data to be in a format where rows correspond to images and columns correspond to features. This means that all the information for a given image needs to be contained in a single row. . We want to provide our model with the raw pixel values from our images as well as the HOG features we just calculated. To do this, we will write a function called create_features that combines these two sets of features by flattening the three-dimensional array into a one-dimensional (flat) array. . def create_features(img): # flatten three channel color image color_features = img.flatten() # convert image to greyscale grey_image = rgb2grey(img) # get HOG features from greyscale image hog_features = hog(grey_image, block_norm=&#39;L2-Hys&#39;, pixels_per_cell=(16, 16)) # combine color and hog features into a single array flat_features = np.hstack((color_features, hog_features)) return flat_features bombus_features = create_features(bombus) # print shape of bombus_features # ... YOUR CODE FOR TASK 5 ... print(bombus_features.shape) . (31296,) . 6. Loop over images to preprocess . Above we generated a flattened features array for the bombus image. Now it&#39;s time to loop over all of our images. We will create features for each image and then stack the flattened features arrays into a big matrix we can pass into our model. . In the create_feature_matrix function, we&#39;ll do the following: . Load an image | Generate a row of features using the create_features function above | Stack the rows into a features matrix | . In the resulting features matrix, rows correspond to images and columns to features. . def create_feature_matrix(label_dataframe): features_list = [] for img_id in label_dataframe.index: # load image img = get_image(img_id) # get features for image image_features = create_features(img) features_list.append(image_features) # convert list of arrays into a matrix feature_matrix = np.array(features_list) return feature_matrix # run create_feature_matrix on our dataframe of images feature_matrix = create_feature_matrix(labels) . 7. Scale feature matrix + PCA . Our features aren&#39;t quite done yet. Many machine learning methods are built to work best with data that has a mean of 0 and unit variance. Luckily, scikit-learn provides a simple way to rescale your data to work well using StandardScaler. They&#39;ve got a more thorough explanation of why that is in the linked docs. . Remember also that we have over 31,000 features for each image and only 500 images total. To use an SVM, our model of choice, we also need to reduce the number of features we have using principal component analysis (PCA). . PCA is a way of linearly transforming the data such that most of the information in the data is contained within a smaller number of features called components. Below is a visual example from an image dataset containing handwritten numbers. The image on the left is the original image with 784 components. We can see that the image on the right (post PCA) captures the shape of the number quite effectively even with only 59 components. . . In our case, we will keep 500 components. This means our feature matrix will only have 500 columns rather than the original 31,296. . print(&#39;Feature matrix shape is: &#39;, feature_matrix.shape) # define standard scaler ss = StandardScaler() # run this on our feature matrix bees_stand = ss.fit_transform(feature_matrix) pca = PCA(n_components=500) # use fit_transform to run PCA on our standardized matrix bees_pca = pca.fit_transform(bees_stand) # look at new shape print(&#39;PCA matrix shape is: &#39;, bees_pca.shape) . Feature matrix shape is: (500, 31296) PCA matrix shape is: (500, 500) . 8. Split into train and test sets . Now we need to convert our data into train and test sets. We&#39;ll use 70% of images as our training data and test our model on the remaining 30%. Scikit-learn&#39;s train_test_split function makes this easy. . X_train, X_test, y_train, y_test = train_test_split(bees_pca, labels.genus.values, test_size=.3, random_state=1234123) # look at the distrubution of labels in the train set # ... YOUR CODE FOR TASK 8 ... pd.Series(y_train).value_counts() . 0.0 175 1.0 175 dtype: int64 . 9. Train model . It&#39;s finally time to build our model! We&#39;ll use a support vector machine (SVM), a type of supervised machine learning model used for regression, classification, and outlier detection.&quot; An SVM model is a representation of the examples as points in space, mapped so that the examples of the separate categories are divided by a clear gap that is as wide as possible. New examples are then mapped into that same space and predicted to belong to a category based on which side of the gap they fall.&quot; . Here&#39;s a visualization of the maximum margin separating two classes using an SVM classifier with a linear kernel. . Since we have a classification task -- honey or bumble bee -- we will use the support vector classifier (SVC), a type of SVM. We imported this class at the top of the notebook. . svm = SVC(probability=True, random_state=42) # fit model # ... YOUR CODE FOR TASK 9 ... svm.fit(X_train, y_train) . SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0, decision_function_shape=&#39;ovr&#39;, degree=3, gamma=&#39;auto&#39;, kernel=&#39;rbf&#39;, max_iter=-1, probability=True, random_state=42, shrinking=True, tol=0.001, verbose=False) . 10. Score model . Now we&#39;ll use our trained model to generate predictions for our test data. To see how well our model did, we&#39;ll calculate the accuracy by comparing our predicted labels for the test set with the true labels in the test set. Accuracy is the number of correct predictions divided by the total number of predictions. Scikit-learn&#39;s accuracy_score function will do math for us. Sometimes accuracy can be misleading, but since we have an equal number of honey and bumble bees, it is a useful metric for this problem. . y_pred = svm.predict(X_test) # calculate accuracy accuracy = accuracy_score(y_test, y_pred) print(&#39;Model accuracy is: &#39;, accuracy) . Model accuracy is: 0.5 . 11. ROC curve + AUC . Above, we used svm.predict to predict either 0.0 or 1.0 for each image in X_test. Now, we&#39;ll use svm.predict_proba to get the probability that each class is the true label. For example, predict_proba returns [0.46195176, 0.53804824] for the first image, meaning there is a 46% chance the bee in the image is an Apis (0.0) and a 53% chance the bee in the image is a Bombus (1.0). Note that the two probabilities for each image always sum to 1. . Using the default settings, probabilities of 0.5 or above are assigned a class label of 1.0 and those below are assigned a 0.0. However, this threshold can be adjusted. The receiver operating characteristic curve (ROC curve) plots the false positive rate and true positive rate at different thresholds. ROC curves are judged visually by how close they are to the upper lefthand corner. . The area under the curve (AUC) is also calculated, where 1 means every predicted label was correct. Generally, the worst score for AUC is 0.5, which is the performance of a model that randomly guesses. See the scikit-learn documentation for more resources and examples on ROC curves and AUC. . probabilities = svm.predict_proba(X_test) # select the probabilities for label 1.0 y_proba = probabilities[:, 1] # calculate false positive rate and true positive rate at different thresholds false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_proba, pos_label=1) # calculate AUC roc_auc = auc(false_positive_rate, true_positive_rate) plt.title(&#39;Receiver Operating Characteristic&#39;) # plot the false positive rate on the x axis and the true positive rate on the y axis roc_plot = plt.plot(false_positive_rate, true_positive_rate, label=&#39;AUC = {:0.2f}&#39;.format(roc_auc)) plt.legend(loc=0) plt.plot([0,1], [0,1], ls=&#39;--&#39;) plt.ylabel(&#39;True Positive Rate&#39;) plt.xlabel(&#39;False Positive Rate&#39;); .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/29/Naive-Bees-Predict-Species-from-Images.html",
            "relUrl": "/datacamp/projects/python/2021/03/29/Naive-Bees-Predict-Species-from-Images.html",
            "date": " • Mar 29, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "Naive Bees Image Loading and Processing",
            "content": "1. Import Python libraries . A honey bee. . The question at hand is: can a machine identify a bee as a honey bee or a bumble bee? These bees have different behaviors and appearances, but given the variety of backgrounds, positions, and image resolutions it can be a challenge for machines to tell them apart. . Being able to identify bee species from images is a task that ultimately would allow researchers to more quickly and effectively collect field data. Pollinating bees have critical roles in both ecology and agriculture, and diseases like colony collapse disorder threaten these species. Identifying different species of bees in the wild means that we can better understand the prevalence and growth of these important insects. . A bumble bee. . This notebook walks through loading and processing images. After loading and processing these images, they will be ready for building models that can automatically detect honeybees and bumblebees. . from pathlib import Path # We set up matplotlib, pandas, and the display function %matplotlib inline import matplotlib.pyplot as plt from IPython.display import display import pandas as pd # import numpy to use in this cell # ... YOUR CODE FOR TASK 1 ... import numpy as np # import Image from PIL so we can use it later # ... YOUR CODE FOR TASK 1 ... from PIL import Image # generate test_data # ... YOUR CODE FOR TASK 1 ... test_data = np.random.beta(a=1, b=1, size=(100, 100, 3)) # display the test_data # ... YOUR CODE FOR TASK 1 ... plt.imshow(test_data) . &lt;matplotlib.image.AxesImage at 0x7f9bf3021b38&gt; . 2. Opening images with PIL . Now that we have all of our imports ready, it is time to work with some real images. . Pillow is a very flexible image loading and manipulation library. It works with many different image formats, for example, .png, .jpg, .gif and more. For most image data, one can work with images using the Pillow library (which is imported as PIL). . Now we want to load an image, display it in the notebook, and print out the dimensions of the image. By dimensions, we mean the width of the image and the height of the image. These are measured in pixels. The documentation for Image in Pillow gives a comprehensive view of what this object can do. . img = Image.open(&#39;datasets/bee_1.jpg&#39;) # Get the image size img_size = img.size print(&quot;The image size is: {}&quot;.format(img_size)) # Just having the image as the last line in the cell will display it in the notebook img . The image size is: (100, 100) . 3. Image manipulation with PIL . Pillow has a number of common image manipulation tasks built into the library. For example, one may want to resize an image so that the file size is smaller. Or, perhaps, convert an image to black-and-white instead of color. Operations that Pillow provides include: . resizing | cropping | rotating | flipping | converting to greyscale (or other color modes) | . Often, these kinds of manipulations are part of the pipeline for turning a small number of images into more images to create training data for machine learning algorithms. This technique is called data augmentation, and it is a common technique for image classification. . We&#39;ll try a couple of these operations and look at the results. . img_cropped = img.crop((25, 25, 75, 75)) display(img_cropped) # rotate the image by 45 degrees img_rotated = img.rotate(45, expand=25) display(img_rotated) # flip the image left to right img_flipped = img.transpose(Image.FLIP_LEFT_RIGHT) display(img_flipped) . 4. Images as arrays of data . What is an image? So far, PIL has handled loading images and displaying them. However, if we&#39;re going to use images as data, we need to understand what that data looks like. . Most image formats have three color &quot;channels&quot;: red, green, and blue (some images also have a fourth channel called &quot;alpha&quot; that controls transparency). For each pixel in an image, there is a value for every channel. . . The way this is represented as data is as a three-dimensional matrix. The width of the matrix is the width of the image, the height of the matrix is the height of the image, and the depth of the matrix is the number of channels. So, as we saw, the height and width of our image are both 100 pixels. This means that the underlying data is a matrix with the dimensions 100x100x3. . img_data = np.asarray(img) # get the shape of the resulting array img_data_shape = img_data.shape print(&quot;Our NumPy array has the shape: {}&quot;.format(img_data_shape)) # plot the data with `imshow` # ... YOUR CODE FOR TASK 4 ... plt.show() # plot the red channel plt.imshow(img_data[:, :, 0], cmap=plt.cm.Reds_r) plt.show() # plot the green channel plt.imshow(img_data[:, :, 1], cmap=plt.cm.Greens_r) plt.show() # plot the blue channel plt.imshow(img_data[:, :, 2], cmap=plt.cm.Blues_r) plt.show() . Our NumPy array has the shape: (100, 100, 3) . 5. Explore the color channels . Color channels can help provide more information about an image. A picture of the ocean will be more blue, whereas a picture of a field will be more green. This kind of information can be useful when building models or examining the differences between images. . We&#39;ll look at the kernel density estimate for each of the color channels on the same plot so that we can understand how they differ. . When we make this plot, we&#39;ll see that a shape that appears further to the right means more of that color, whereas further to the left means less of that color. . def plot_kde(channel, color): &quot;&quot;&quot; Plots a kernel density estimate for the given data. `channel` must be a 2d array `color` must be a color string, e.g. &#39;r&#39;, &#39;g&#39;, or &#39;b&#39; &quot;&quot;&quot; data = channel.flatten() return pd.Series(data).plot.density(c=color) # create the list of channels channels = [&#39;r&#39;, &#39;g&#39;, &#39;b&#39;] def plot_rgb(image_data): # use enumerate to loop over colors and indexes for ix, color in enumerate(channels): # ... YOUR CODE FOR TASK 5 ... plot_kde(image_data[:, :, ix], color) plt.show() plot_rgb(img_data) . 6. Honey bees and bumble bees (i) . Now we&#39;ll look at two different images and some of the differences between them. The first image is of a honey bee, and the second image is of a bumble bee. . First, let&#39;s look at the honey bee. . # ... YOUR CODE FOR TASK 6 ... honey = Image.open(&#39;datasets/bee_12.jpg&#39;) # display the honey bee image display(honey) # NumPy array of the honey bee image data # ... YOUR CODE FOR TASK 6 ... honey_data = np.asarray(honey) # plot the rgb densities for the honey bee image plot_rgb(honey_data) . 7. Honey bees and bumble bees (ii) . Now let&#39;s look at the bumble bee. . When one compares these images, it is clear how different the colors are. The honey bee image above, with a blue flower, has a strong peak on the right-hand side of the blue channel. The bumble bee image, which has a lot of yellow for the bee and the background, has almost perfect overlap between the red and green channels (which together make yellow). . # ... YOUR CODE FOR TASK 7 ... bumble = Image.open(&#39;datasets/bee_3.jpg&#39;) # display the bumble bee image display(bumble) # NumPy array of the bumble bee image data # ... YOUR CODE FOR TASK 7 ... bumble_data = np.asarray(bumble) # plot the rgb densities for the bumble bee image plot_rgb(bumble_data) . 8. Simplify, simplify, simplify . While sometimes color information is useful, other times it can be distracting. In this examples where we are looking at bees, the bees themselves are very similar colors. On the other hand, the bees are often on top of different color flowers. We know that the colors of the flowers may be distracting from separating honey bees from bumble bees, so let&#39;s convert these images to black-and-white, or &quot;grayscale.&quot; . Grayscale is just one of the modes that Pillow supports. Switching between modes is done with the .convert() method, which is passed a string for the new mode. . Because we change the number of color &quot;channels,&quot; the shape of our array changes with this change. It also will be interesting to look at how the KDE of the grayscale version compares to the RGB version above. . honey_bw = honey.convert(&quot;L&quot;) display(honey_bw) # convert the image to a NumPy array honey_bw_arr = np.asarray(honey_bw) # get the shape of the resulting array honey_bw_arr_shape = honey_bw_arr.shape print(&quot;Our NumPy array has the shape: {}&quot;.format(honey_bw_arr_shape)) # plot the array using matplotlib plt.imshow(honey_bw_arr, cmap=plt.cm.gray) plt.show() # plot the kde of the new black and white array plot_kde(honey_bw_arr, &#39;k&#39;) . Our NumPy array has the shape: (100, 100) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f9be7320588&gt; . 9. Save your work! . We&#39;ve been talking this whole time about making changes to images and the manipulations that might be useful as part of a machine learning pipeline. To use these images in the future, we&#39;ll have to save our work after we&#39;ve made changes. . Now, we&#39;ll make a couple changes to the Image object from Pillow and save that. We&#39;ll flip the image left-to-right, just as we did with the color version. Then, we&#39;ll change the NumPy version of the data by clipping it. Using the np.maximum function, we can take any number in the array smaller than 100 and replace it with 100. Because this reduces the range of values, it will increase the contrast of the image. We&#39;ll then convert that back to an Image and save the result. . # ... YOUR CODE FOR TASK 9 ... honey_bw_flip = honey_bw.transpose(Image.FLIP_LEFT_RIGHT) # show the flipped image display(honey_bw_flip) # save the flipped image # ... YOUR CODE FOR TASK 9 ... honey_bw_flip.save(&#39;saved_images/bw_flipped.jpg&#39;) # create higher contrast by reducing range # ... YOUR CODE FOR TASK 9 ... honey_hc_arr = np.maximum(honey_bw_arr, 100) # show the higher contrast version plt.imshow(honey_hc_arr, cmap=plt.cm.gray) # convert the NumPy array of high contrast to an Image # ... YOUR CODE FOR TASK 9 ... honey_bw_hc = Image.fromarray(honey_hc_arr) # save the high contrast version # ... YOUR CODE FOR TASK 9 ... honey_bw_hc.save(&#39;saved_images/bw_hc.jpg&#39;) . 10. Make a pipeline . Now it&#39;s time to create an image processing pipeline. We have all the tools in our toolbox to load images, transform them, and save the results. . In this pipeline we will do the following: . Load the image with Image.open and create paths to save our images to | Convert the image to grayscale | Save the grayscale image | Rotate, crop, and zoom in on the image and save the new image | . image_paths = [&#39;datasets/bee_1.jpg&#39;, &#39;datasets/bee_12.jpg&#39;, &#39;datasets/bee_2.jpg&#39;, &#39;datasets/bee_3.jpg&#39;] def process_image(path): img = Image.open(path) # create paths to save files to bw_path = &quot;saved_images/bw_{}.jpg&quot;.format(path.stem) rcz_path = &quot;saved_images/rcz_{}.jpg&quot;.format(path.stem) print(&quot;Creating grayscale version of {} and saving to {}.&quot;.format(path, bw_path)) bw = img.convert(&quot;L&quot;) # ... YOUR CODE FOR TASK 10 ... bw.save(bw_path) print(&quot;Creating rotated, cropped, and zoomed version of {} and saving to {}.&quot;.format(path, rcz_path)) rcz = # ... YOUR CODE FOR TASK 10 ... # for loop over image paths for img_path in image_paths: process_image(Path(img_path)) . Creating grayscale version of datasets/bee_1.jpg and saving to saved_images/bw_bee_1.jpg. Creating rotated, cropped, and zoomed version of datasets/bee_1.jpg and saving to saved_images/rcz_bee_1.jpg. Creating grayscale version of datasets/bee_12.jpg and saving to saved_images/bw_bee_12.jpg. Creating rotated, cropped, and zoomed version of datasets/bee_12.jpg and saving to saved_images/rcz_bee_12.jpg. Creating grayscale version of datasets/bee_2.jpg and saving to saved_images/bw_bee_2.jpg. Creating rotated, cropped, and zoomed version of datasets/bee_2.jpg and saving to saved_images/rcz_bee_2.jpg. Creating grayscale version of datasets/bee_3.jpg and saving to saved_images/bw_bee_3.jpg. Creating rotated, cropped, and zoomed version of datasets/bee_3.jpg and saving to saved_images/rcz_bee_3.jpg. .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/29/Naive-Bees-Image-Loading-and-Processing.html",
            "relUrl": "/datacamp/projects/python/2021/03/29/Naive-Bees-Image-Loading-and-Processing.html",
            "date": " • Mar 29, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "Naive Bees Deep Learning with Images",
            "content": "1. Import Python libraries . A honey bee (Apis). . Can a machine identify a bee as a honey bee or a bumble bee? These bees have different behaviors and appearances, but given the variety of backgrounds, positions, and image resolutions, it can be a challenge for machines to tell them apart. . Being able to identify bee species from images is a task that ultimately would allow researchers to more quickly and effectively collect field data. Pollinating bees have critical roles in both ecology and agriculture, and diseases like colony collapse disorder threaten these species. Identifying different species of bees in the wild means that we can better understand the prevalence and growth of these important insects. . A bumble bee (Bombus). . This notebook walks through building a simple deep learning model that can automatically detect honey bees and bumble bees and then loads a pre-trained model for evaluation. . import pickle from pathlib import Path from skimage import io import pandas as pd import numpy as np import matplotlib.pyplot as plt %matplotlib inline from sklearn.preprocessing import StandardScaler from sklearn.model_selection import train_test_split from sklearn.metrics import classification_report # import keras library # ... YOUR CODE FOR TASK 1 ... import keras # import Sequential from the keras models module # ... YOUR CODE FOR TASK 1 ... from keras.models import Sequential # import Dense, Dropout, Flatten, Conv2D, MaxPooling2D from the keras layers module from keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D . 2. Load image labels . Now that we have all of our imports ready, it is time to look at the labels for our data. We will load our labels.csv file into a DataFrame called labels, where the index is the image name (e.g. an index of 1036 refers to an image named 1036.jpg) and the genus column tells us the bee type. genus takes the value of either 0.0 (Apis or honey bee) or 1.0 (Bombus or bumble bee). . labels = pd.read_csv(&#39;datasets/labels.csv&#39;, index_col=0) # print value counts for genus print(labels[&#39;genus&#39;].value_counts()) # assign the genus label values to y y = labels[&#39;genus&#39;].values . 0.0 827 1.0 827 Name: genus, dtype: int64 . 3. Examine RGB values in an image matrix . Image data can be represented as a matrix. The width of the matrix is the width of the image, the height of the matrix is the height of the image, and the depth of the matrix is the number of channels. Most image formats have three color channels: red, green, and blue. . For each pixel in an image, there is a value for every channel. The combination of the three values corresponds to the color, as per the RGB color model. Values for each color can range from 0 to 255, so a purely blue pixel would show up as (0, 0, 255). . . Let&#39;s explore the data for a sample image. . example_image = io.imread(&#39;datasets/{}.jpg&#39;.format(labels.index[0])) # show image # ... YOUR CODE FOR TASK 3 ... plt.imshow(example_image) # print shape print(&#39;Example image has shape: &#39;, example_image.shape) # print color channel values for top left pixel print(&#39;RGB values for the top left pixel are:&#39;, example_image[0, 0, :]) . Example image has shape: (50, 50, 3) RGB values for the top left pixel are: [127 108 95] . 4. Normalize image data . Now we need to normalize our image data. Normalization is a general term that means changing the scale of our data so it is consistent. . In this case, we want each feature to have a similar range so our neural network can learn effectively across all the features. As explained in the sklearn docs, &quot;If a feature has a variance that is orders of magnitude larger than others, it might dominate the objective function and make the estimator unable to learn from other features correctly as expected.&quot; . We will scale our data so that it has a mean of 0 and standard deviation of 1. We&#39;ll use sklearn&#39;s StandardScaler to do the math for us, which entails taking each value, subtracting the mean, and then dividing by the standard deviation. We need to do this for each color channel (i.e. each feature) individually. . ss = StandardScaler() image_list = [] for i in labels.index: # load image img = io.imread(&#39;datasets/{}.jpg&#39;.format(i)).astype(np.float64) # for each channel, apply standard scaler&#39;s fit_transform method for channel in range(img.shape[2]): img[:, :, channel] = ss.fit_transform(img[:, :, channel]) # append to list of all images image_list.append(img) # convert image list to single array X = np.array(image_list) # print shape of X print(X.shape) . (1654, 50, 50, 3) . 5. Split into train, test, and evaluation sets . Now that we have our big image data matrix, X, as well as our labels, y, we can split our data into train, test, and evaluation sets. To do this, we&#39;ll first allocate 20% of the data into our evaluation, or holdout, set. This is data that the model never sees during training and will be used to score our trained model. . We will then split the remaining data, 60/40, into train and test sets just like in supervised machine learning models. We will pass both the train and test sets into the neural network. . x_interim, x_eval, y_interim, y_eval = train_test_split(X, y, test_size=0.2, random_state=52) # split remaining data into train and test sets # ... YOUR CODE FOR TASK 5 ... x_train, x_test, y_train, y_test = train_test_split(x_interim, y_interim, test_size=0.4, random_state=52) # examine number of samples in train, test, and validation sets print(&#39;x_train shape:&#39;, x_train.shape) print(len(y_train), &#39;train samples&#39;) print(x_test.shape[0], &#39;test samples&#39;) print(x_eval.shape[0], &#39;eval samples&#39;) . x_train shape: (793, 50, 50, 3) 793 train samples 530 test samples 331 eval samples . 6. Model building (part i) . It&#39;s time to start building our deep learning model, a convolutional neural network (CNN). CNNs are a specific kind of artificial neural network that is very effective for image classification because they are able to take into account the spatial coherence of the image, i.e., that pixels close to each other are often related. . Building a CNN begins with specifying the model type. In our case, we&#39;ll use a Sequential model, which is a linear stack of layers. We&#39;ll then add two convolutional layers. To understand convolutional layers, imagine a flashlight being shown over the top left corner of the image and slowly sliding across all the areas of the image, moving across the image in the same way your eyes move across words on a page. Convolutional layers pass a kernel (a sliding window) over the image and perform element-wise matrix multiplication between the kernel values and the pixel values in the image. . num_classes = 1 # define model as Sequential model = Sequential() # first convolutional layer with 32 filters model.add(Conv2D(32, kernel_size=(3, 3), activation=&#39;relu&#39;, input_shape=(50, 50, 3))) # add a second 2D convolutional layer with 64 filters # ... YOUR CODE FOR TASK 6 ... model.add(Conv2D(64, kernel_size=(3, 3), activation=&#39;relu&#39;)) . 7. Model building (part ii) . Let&#39;s continue building our model. So far our model has two convolutional layers. However, those are not the only layers that we need to perform our task. A complete neural network architecture will have a number of other layers that are designed to play a specific role in the overall functioning of the network. Much deep learning research is about how to structure these layers into coherent systems. . We&#39;ll add the following layers: . MaxPooling. This passes a (2, 2) moving window over the image and downscales the image by outputting the maximum value within the window. | Conv2D. This adds a third convolutional layer since deeper models, i.e. models with more convolutional layers, are better able to learn features from images. | Dropout. This prevents the model from overfitting, i.e. perfectly remembering each image, by randomly setting 25% of the input units to 0 at each update during training. | Flatten. As its name suggests, this flattens the output from the convolutional part of the CNN into a one-dimensional feature vector which can be passed into the following fully connected layers. | Dense. Fully connected layer where every input is connected to every output (see image below). | Dropout. Another dropout layer to safeguard against overfitting, this time with a rate of 50%. | Dense. Final layer which calculates the probability the image is either a bumble bee or honey bee. | . To take a look at how it all stacks up, we&#39;ll print the model summary. Notice that our model has a whopping 3,669,249 paramaters. These are the different weights that the model learns through training and what are used to generate predictions on a new image. . . model.add(MaxPooling2D(pool_size=(2, 2))) # third convolutional layer with 64 filters model.add(Conv2D(64, kernel_size=(3, 3), activation=&#39;relu&#39;)) # add dropout to prevent over fitting model.add(Dropout(0.25)) # necessary flatten step preceeding dense layer model.add(Flatten()) # fully connected layer model.add(Dense(128, activation=&#39;relu&#39;)) # add additional dropout to prevent overfitting # ... YOUR CODE FOR TASK 7 ... model.add(Dropout(0.5)) # prediction layers model.add(Dense(num_classes, activation=&#39;sigmoid&#39;, name=&#39;preds&#39;)) # show model summary # ... YOUR CODE FOR TASK 7 ... model.summary() . Model: &#34;sequential&#34; _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d (Conv2D) (None, 48, 48, 32) 896 _________________________________________________________________ conv2d_1 (Conv2D) (None, 46, 46, 64) 18496 _________________________________________________________________ max_pooling2d (MaxPooling2D) (None, 23, 23, 64) 0 _________________________________________________________________ conv2d_2 (Conv2D) (None, 21, 21, 64) 36928 _________________________________________________________________ dropout (Dropout) (None, 21, 21, 64) 0 _________________________________________________________________ flatten (Flatten) (None, 28224) 0 _________________________________________________________________ dense (Dense) (None, 128) 3612800 _________________________________________________________________ dropout_1 (Dropout) (None, 128) 0 _________________________________________________________________ preds (Dense) (None, 1) 129 ================================================================= Total params: 3,669,249 Trainable params: 3,669,249 Non-trainable params: 0 _________________________________________________________________ . 8. Compile and train model . Now that we&#39;ve specified the model architecture, we will compile the model for training. For this we need to specify the loss function (what we&#39;re trying to minimize), the optimizer (how we want to go about minimizing the loss), and the metric (how we&#39;ll judge the performance of the model). . Then, we&#39;ll call .fit to begin the trainig the process. . &quot;Neural networks are trained iteratively using optimization techniques like gradient descent. After each cycle of training, an error metric is calculated based on the difference between prediction and target…Each neuron’s coefficients (weights) are then adjusted relative to how much they contributed to the total error. This process is repeated iteratively.&quot; ML Cheatsheet . Since training is computationally intensive, we&#39;ll do a &#39;mock&#39; training to get the feel for it, using just the first 10 images in the train and test sets and training for just 5 epochs. Epochs refer to the number of iterations over the data. Typically, neural networks will train for hundreds if not thousands of epochs. . Take a look at the printout for each epoch and note the loss on the train set (loss), the accuracy on the train set (acc), and loss on the test set (val_loss) and the accuracy on the test set (val_acc). We&#39;ll explore this more in a later step. . model.compile( # set the loss as binary_crossentropy loss=keras.losses.binary_crossentropy, # set the optimizer as stochastic gradient descent optimizer=keras.optimizers.SGD(lr=0.001), # set the metric as accuracy metrics=[&#39;accuracy&#39;] ) # mock-train the model using the first ten observations of the train and test sets model.fit( x_train[:10, :, :, :], y_train[:10], epochs=5, verbose=1, validation_data=(x_test[:10, :, :, :], y_test[:10]) ) . Epoch 1/5 1/1 [==============================] - 2s 2s/step - loss: 0.6402 - accuracy: 0.7000 - val_loss: 0.6825 - val_accuracy: 0.5000 Epoch 2/5 1/1 [==============================] - 0s 99ms/step - loss: 0.7146 - accuracy: 0.7000 - val_loss: 0.6835 - val_accuracy: 0.5000 Epoch 3/5 1/1 [==============================] - 0s 98ms/step - loss: 0.6180 - accuracy: 0.8000 - val_loss: 0.6820 - val_accuracy: 0.5000 Epoch 4/5 1/1 [==============================] - 0s 128ms/step - loss: 0.6396 - accuracy: 0.8000 - val_loss: 0.6816 - val_accuracy: 0.5000 Epoch 5/5 1/1 [==============================] - 0s 138ms/step - loss: 0.5663 - accuracy: 0.8000 - val_loss: 0.6820 - val_accuracy: 0.5000 . &lt;tensorflow.python.keras.callbacks.History at 0x7fc5506b9160&gt; . 9. Load pre-trained model and score . Now we&#39;ll load a pre-trained model that has the architecture we specified above and was trained for 200 epochs on the full train and test sets we created above. . Let&#39;s use the evaluate method to see how well the model did at classifying bumble bees and honey bees for the test and validation sets. Recall that accuracy is the number of correct predictions divided by the total number of predictions. Given that our classes are balanced, a model that predicts 1.0 for every image would get an accuracy around 0.5. . Note: it may take a few seconds to load the model. Recall that our model has over 3 million parameters (weights), which are what&#39;s being loaded. . pretrained_cnn = keras.models.load_model(&#39;datasets/pretrained_model.h5&#39;) # evaluate model on test set score = pretrained_cnn.evaluate(x_test, y_test, verbose=0) print(&#39;Test loss:&#39;, score[0]) print(&#39;Test accuracy:&#39;, score[1]) print(&quot;&quot;) # evaluate model on holdout set eval_score = pretrained_cnn.evaluate(x_eval, y_eval, verbose=0) # print loss score print(&#39;Eval loss:&#39;, eval_score[0]) # print accuracy score print(&#39;Eval accuracy:&#39;, eval_score[1]) . WARNING:tensorflow:Error in loading the saved optimizer state. As a result, your model is starting with a freshly initialized optimizer. Test loss: 0.6423928737640381 Test accuracy: 0.6641509532928467 Eval loss: 0.654895007610321 Eval accuracy: 0.6495468020439148 . 10. Visualize model training history . In addition to scoring the final iteration of the pre-trained model as we just did, we can also see the evolution of scores throughout training thanks to the History object. We&#39;ll use the pickle library to load the model history and then plot it. . Notice how the accuracy improves over time, eventually leveling off. Correspondingly, the loss decreases over time. Plots like these can help diagnose overfitting. If we had seen an upward curve in the validation loss as times goes on (a U shape in the plot), we&#39;d suspect that the model was starting to memorize the test set and would not generalize well to new data. . with open(&#39;datasets/model_history.pkl&#39;, &#39;rb&#39;) as f: pretrained_cnn_history = pickle.load(f) # print keys for pretrained_cnn_history dict print(pretrained_cnn_history) fig = plt.figure(1) plt.subplot(211) # plot the validation accuracy plt.plot(pretrained_cnn_history[&#39;val_acc&#39;]) plt.title(&#39;Validation accuracy and loss&#39;) plt.ylabel(&#39;Accuracy&#39;) plt.subplot(212) # plot the validation loss plt.plot(pretrained_cnn_history[&#39;val_loss&#39;], &#39;r&#39;) plt.xlabel(&#39;Epoch&#39;) plt.ylabel(&#39;Loss value&#39;); . {&#39;val_loss&#39;: [0.6973548315606027, 0.6949519305858972, 0.6938502622100542, 0.6938419162102465, 0.6921774981156835, 0.691008841316655, 0.6904466395108205, 0.6908388506691411, 0.690298109234504, 0.6896439885193447, 0.6890573636540827, 0.6878997674528158, 0.6877660085570138, 0.687450434126944, 0.6864860181538563, 0.6857865929603577, 0.6854122814142479, 0.6852205658858677, 0.6844912373794699, 0.6839377567453204, 0.6835917376122385, 0.6830667650924539, 0.68289057038865, 0.6822199160197996, 0.681749959036989, 0.6813096154410884, 0.6808326183624988, 0.680350206258162, 0.6798245346771097, 0.6794466407793873, 0.6790301604090997, 0.6786370871202001, 0.6780787004614776, 0.6774498498664712, 0.6773286668759472, 0.6768853522696585, 0.6764395120008937, 0.6764187572137365, 0.6755043072520562, 0.6755023447972424, 0.6747962701995418, 0.6748723560909056, 0.6741743521870307, 0.6736826048707062, 0.6730284241010558, 0.6731890658162675, 0.6724795757599596, 0.6720847644895878, 0.671594364013312, 0.6708701347405056, 0.6702886750113289, 0.6700042987769504, 0.6692965521002715, 0.6689484994366484, 0.6692490910584072, 0.6684379280738111, 0.6680986305452743, 0.6672339358419742, 0.666900885105133, 0.6669266691747702, 0.666627643468245, 0.6668524751123392, 0.666532779639622, 0.6660595893859863, 0.6663234141637694, 0.6640820010653082, 0.6647802271932925, 0.6644656390514014, 0.6646909866692885, 0.6635346293449402, 0.6620154612469223, 0.661884997475822, 0.6612221713336008, 0.6607731328820282, 0.6604519014088612, 0.6599598081606739, 0.6594767844901894, 0.6595204045187752, 0.6589159349225602, 0.6580378401954219, 0.657763165347981, 0.6577120792190984, 0.6575329078818267, 0.6575919214284645, 0.6567454367313745, 0.6560180893484152, 0.6556380136957708, 0.6553035230006812, 0.6548657367814262, 0.6558716839214541, 0.6542430731485475, 0.6548173274634019, 0.6558191562598606, 0.6545853187453072, 0.6537650699885387, 0.6536643808742739, 0.6533196827150741, 0.6523577777844555, 0.6521409934421756, 0.6530955406854737, 0.651645087296108, 0.6512778952436628, 0.6513771554209151, 0.6514387459125159, 0.6538986905565801, 0.6531333945832163, 0.650129293495754, 0.6499695532726791, 0.6503407127452346, 0.650624522398103, 0.65003444653637, 0.6515556463655435, 0.6493381648693445, 0.6494280959075351, 0.6493060352667323, 0.6492863889010447, 0.6502830435644905, 0.6489436887345224, 0.6491816480204744, 0.6502597858320992, 0.6487753449745898, 0.6473832699487794, 0.647148665617097, 0.646953526532875, 0.6469740089380516, 0.6467888254039692, 0.6467267315342741, 0.6470954229246896, 0.6465090409764703, 0.6459426726935045, 0.6457727976565091, 0.645441040227998, 0.6455394717882265, 0.6455985195231888, 0.6491911600220878, 0.646003349322193, 0.6484261967101187, 0.645657229423523, 0.6448964737496286, 0.6450504766320283, 0.6448395852772695, 0.6452005343617133, 0.64511269938271, 0.6451621759612606, 0.6450724945878082, 0.6446082796690599, 0.6447435415016031, 0.6443353270584682, 0.6451325706715854, 0.6462242702268205, 0.6450359981015044, 0.6447009635421465, 0.6459125586275785, 0.6466515871713746, 0.6458257216327595, 0.6439035474129443, 0.6433645165191506, 0.6434951532561825, 0.645443630443429, 0.643107929769552, 0.6426359475783582, 0.642248886036423, 0.6439068164465562, 0.642824750351456, 0.6428220254070354, 0.6424781943267246, 0.6425938871671568, 0.642436413719969, 0.6431071866233394, 0.6423645194971337, 0.642575939646307, 0.6423488088373868, 0.6437250643406274, 0.6419217568523479, 0.6417660033927773, 0.6420647160062251, 0.6419619839146452, 0.647363669242499, 0.643349750986639, 0.643465511753874, 0.643357885333727, 0.6419335916357221, 0.641562087805766, 0.6432529512441383, 0.642104346347305, 0.641738914993574, 0.6426482614481224, 0.6429501128646563, 0.6422279301679359, 0.6441797362183624, 0.6428858093495639, 0.643737822883534, 0.6434570618395535, 0.6422331533342037, 0.6422527115300016, 0.6465478762140814, 0.642058812447314, 0.6425080216155862, 0.6423455717428675, 0.6423929070526699], &#39;val_acc&#39;: [0.4811320752467749, 0.49056603751092587, 0.49056603751092587, 0.48679245372988145, 0.5150943405223343, 0.5358490575034663, 0.5471698122204475, 0.5037735846807372, 0.5169811327502413, 0.5245283016618693, 0.53207547147319, 0.5603773582656428, 0.5339622639260202, 0.5377358488316806, 0.5660377365238262, 0.5679245289766564, 0.5584905667125054, 0.5566037733599825, 0.5584905667125054, 0.5584905667125054, 0.5622641516181658, 0.5660377365238262, 0.5679245289766564, 0.5698113214294865, 0.5754716987879771, 0.5811320761464677, 0.5886792459577884, 0.5792452839185607, 0.5773584903411145, 0.5792452839185607, 0.5867924535049582, 0.5830188685992979, 0.5792452827939447, 0.5811320752467749, 0.5905660384106186, 0.584905661052128, 0.5867924526052655, 0.5924528297388328, 0.5962264146444932, 0.584905661052128, 0.5981132082219394, 0.594339623316279, 0.6000000006747696, 0.592452829963756, 0.5886792452830188, 0.6037735855804299, 0.5943396235412022, 0.5867924528301887, 0.5924528301886792, 0.5981132073222466, 0.5962264148694164, 0.5962264148694164, 0.5962264148694164, 0.5943396235412022, 0.6113207553917507, 0.5962264148694164, 0.6018867933525229, 0.5962264148694164, 0.6075471695863975, 0.6150943393977183, 0.6132075469448881, 0.6037735855804299, 0.6094339620392277, 0.6113207544920579, 0.6075471695863975, 0.6150943393977183, 0.6094339629389205, 0.6113207553917507, 0.6075471695863975, 0.6094339629389205, 0.6169811318505485, 0.622641509209039, 0.6207547167562089, 0.6207547178808248, 0.6283018865675296, 0.6132075469448881, 0.6339622639260202, 0.6264150950143922, 0.6264150941146994, 0.622641510333655, 0.6283018876921456, 0.6358490563788504, 0.6339622639260202, 0.6207547176559016, 0.6301886790203598, 0.6377358499562965, 0.6377358499562965, 0.6377358488316806, 0.6396226412845107, 0.6169811327502412, 0.6339622639260202, 0.6320754723728828, 0.6226415101087318, 0.6301886799200526, 0.6377358497313733, 0.6320754723728828, 0.6358490572785431, 0.6396226412845107, 0.6415094348619569, 0.6301886799200526, 0.6433962270898639, 0.6452830195426941, 0.6415094346370337, 0.6339622648257129, 0.6264150950143922, 0.6264150950143922, 0.6452830195426941, 0.6415094346370337, 0.6377358497313733, 0.6396226421842035, 0.6433962270898639, 0.6339622648257129, 0.6396226421842035, 0.6415094346370337, 0.6415094346370337, 0.6433962270898639, 0.6377358497313733, 0.6377358497313733, 0.6415094346370337, 0.6377358497313733, 0.6377358497313733, 0.6396226412845107, 0.6396226412845107, 0.6396226412845107, 0.6396226421842035, 0.6396226421842035, 0.6377358497313733, 0.6415094346370337, 0.6339622648257129, 0.6433962261901711, 0.6415094337373409, 0.6433962261901711, 0.6528301893540148, 0.6415094346370337, 0.6377358497313733, 0.6358490572785431, 0.6320754723728828, 0.6396226421842035, 0.6471698119955243, 0.6415094346370337, 0.6452830195426941, 0.6471698110958315, 0.6415094346370337, 0.6415094346370337, 0.6433962270898639, 0.6490566035486617, 0.6415094346370337, 0.6471698119955243, 0.6452830195426941, 0.6396226421842035, 0.6433962270898639, 0.6415094346370337, 0.6339622648257129, 0.6396226421842035, 0.6396226421842035, 0.6528301884543221, 0.6509433969011846, 0.6471698119955243, 0.6433962270898639, 0.6452830195426941, 0.6566037742596752, 0.6528301893540148, 0.6433962270898639, 0.6509433969011846, 0.6528301893540148, 0.6566037742596752, 0.6471698119955243, 0.6509433969011846, 0.6433962270898639, 0.6433962270898639, 0.6452830195426941, 0.6452830195426941, 0.6415094346370337, 0.6452830195426941, 0.6433962270898639, 0.6528301893540148, 0.6622641516181658, 0.6358490572785431, 0.6415094346370337, 0.6415094346370337, 0.6433962270898639, 0.6433962270898639, 0.6566037742596752, 0.6415094346370337, 0.6471698119955243, 0.6584905667125054, 0.6471698119955243, 0.654716981806845, 0.6566037742596752, 0.6377358497313733, 0.6528301893540148, 0.6471698119955243, 0.6490566044483544, 0.6660377365238261, 0.664150944070996, 0.6415094346370337, 0.6584905667125054, 0.6603773591653356, 0.664150944070996, 0.664150944070996], &#39;loss&#39;: [0.69763381393981, 0.7105913674846424, 0.6981844531482586, 0.6908804896049211, 0.7002310421397677, 0.6890532414970302, 0.69824444360721, 0.6925303032539532, 0.6882943342643006, 0.6847970917877303, 0.6892719542393919, 0.6811439971454808, 0.6804057132701705, 0.6962115321153349, 0.690611312022576, 0.6841962133049213, 0.6866795372542036, 0.6801165358115264, 0.6866726247690064, 0.6759685026892798, 0.6863591304192176, 0.6773401813729564, 0.6787760719224755, 0.6762892521946007, 0.6749107879768554, 0.6734781117186721, 0.6806472305391655, 0.6796143139145263, 0.6746330553616431, 0.672908148654322, 0.6722468303100759, 0.6770635078112686, 0.6666129841028817, 0.6671468047295963, 0.6698146642832858, 0.6700134639631755, 0.6683179240058379, 0.6779207236228645, 0.6643883649067199, 0.6650336900394772, 0.6696022650482977, 0.6614861129812455, 0.6600286917006984, 0.658476460175436, 0.651583011935067, 0.6634568578809086, 0.6586981167709091, 0.6611106627224974, 0.6577388405198558, 0.6600017563391753, 0.6549731925937898, 0.6607008828190807, 0.648250998494604, 0.6523348943131869, 0.6567776120475682, 0.6565243668694514, 0.6454335395505119, 0.6487699701235845, 0.6457342886533893, 0.648123957244926, 0.6571452222285324, 0.6447995707937628, 0.6410667152903871, 0.648511490034125, 0.6413717778754264, 0.6411334361885715, 0.6383996775742588, 0.6369847764283381, 0.6404116564861312, 0.6337847475897319, 0.6443416303373676, 0.6443707319105709, 0.63334813597524, 0.6325182960583613, 0.644397125117866, 0.6382584153177759, 0.6337508021808061, 0.6429568907201365, 0.6289279573652212, 0.6258862121559181, 0.6261933187368087, 0.6220835613422706, 0.6342826009848981, 0.6247802379002035, 0.6279644746648108, 0.6283307004846811, 0.6256605759544902, 0.6217865353123687, 0.6224836437278257, 0.6191687452387239, 0.6243988964777125, 0.6270894629206664, 0.6257247989445286, 0.6237024566414678, 0.6189798515050439, 0.6149748739649038, 0.6257139176769184, 0.6176760356032382, 0.6276540018120149, 0.6174791526674172, 0.619012543788323, 0.6106568153238237, 0.6193357128062735, 0.6225488496307767, 0.6149553010923715, 0.604280179039978, 0.6226016235682282, 0.60585598874964, 0.615926036167265, 0.5998287342235089, 0.6156509514865178, 0.6121839409668238, 0.6092188401901707, 0.6055421651837805, 0.5941866580655265, 0.6019582847628888, 0.6077927731325167, 0.6002118931742665, 0.5953195139408712, 0.5982312272205329, 0.6059641718563787, 0.5947810216779817, 0.5969902821928075, 0.5942135366034538, 0.5936596707768579, 0.5954421294141387, 0.6033372079288825, 0.5962651069047021, 0.5853695799543759, 0.5837327086309166, 0.5885515291934356, 0.5971618210532776, 0.5978993003034652, 0.5922351438190417, 0.5812147997817656, 0.5956043443944385, 0.5938164893946462, 0.5986057903246501, 0.5866343139249169, 0.5980406838738151, 0.582888429657959, 0.5848387156579112, 0.5950872894343633, 0.5880918234473971, 0.6022420950224541, 0.5841102724869044, 0.5885366174341902, 0.5770780989832115, 0.581971282014931, 0.586966152524888, 0.5831243059072939, 0.5824071075696813, 0.5852913161244098, 0.5744164795773327, 0.5830465313916249, 0.5751700151011743, 0.5795485738848076, 0.5775529757273603, 0.5733420762408427, 0.5730965090128693, 0.5781392470885345, 0.5767807905640909, 0.5743001880591634, 0.5669449113807341, 0.5652631724918024, 0.5751946515123, 0.5611410435632078, 0.5710295546250265, 0.5677784168705212, 0.5701494404827662, 0.5722405681994944, 0.5636668739673619, 0.575879023550137, 0.5608540414861893, 0.5681426379298803, 0.5614112029310132, 0.569335764060255, 0.5594246730978822, 0.5643792042666095, 0.560409062672383, 0.5510438877577138, 0.5599546730894158, 0.5587624121283523, 0.5680901284927378, 0.5534953542645612, 0.5614012778932781, 0.5437359361901108, 0.5572455290512359, 0.5504018927432249, 0.5644353377112524, 0.5447469376600705, 0.5559871595864939, 0.5486648840381098, 0.5518640301943126, 0.5540478557987141, 0.5455840836181617, 0.5499462104234539, 0.52293714486335, 0.5501674566262907, 0.5585674545052374], &#39;acc&#39;: [0.5233291300744156, 0.4854981078476202, 0.4930643128116074, 0.5321563691239038, 0.504413619242881, 0.5321563682971054, 0.5119798228539254, 0.5245901638592627, 0.5359394704408633, 0.5510718786024957, 0.5561160147941728, 0.5674653223153171, 0.5624211861236399, 0.5145018914759084, 0.5485498115965277, 0.5435056740519078, 0.5346784358667996, 0.5548549818361241, 0.5548549804831814, 0.5800756615918943, 0.5498108445545764, 0.566204286914455, 0.5687263551606206, 0.5737704927052405, 0.5926860027099768, 0.5926860025972316, 0.5725094579808498, 0.5498108444418311, 0.5813366957525588, 0.5775535933457286, 0.581336696015631, 0.5510718791662219, 0.5977301396157071, 0.5977301389392358, 0.5813366957525588, 0.5977301389392358, 0.5813366968424293, 0.5624211847706971, 0.5964691054174608, 0.6103404792681016, 0.5674653211127013, 0.6166456501841695, 0.6116015127898766, 0.6242118534193964, 0.645649432609842, 0.5838587649382679, 0.6368221945750608, 0.595208070279671, 0.6040353086526878, 0.6153846156101058, 0.6343001258027509, 0.6279949567657701, 0.635561161053286, 0.6166456488312267, 0.6065573778008152, 0.6040353083520339, 0.641866330616411, 0.6557377043167248, 0.617906683029473, 0.6292559906633625, 0.6103404785916303, 0.6242118534193964, 0.6355611603768145, 0.6229508197472946, 0.6481715008184258, 0.6380832283223261, 0.6380832277961818, 0.6506935696283175, 0.6582597739158332, 0.6406052964181648, 0.6418663312928824, 0.6544766712459309, 0.6544766716217484, 0.6532156368973577, 0.6380832289987975, 0.6431273641006041, 0.6481715015324788, 0.6292559890849293, 0.6658259775268776, 0.6721311482926184, 0.6645649441554297, 0.6708701142446992, 0.6595208066108097, 0.6595208074376081, 0.6456494327225871, 0.6519546023232939, 0.6595208071369542, 0.6708701137185548, 0.6519546023232939, 0.6582597737655063, 0.6557377058199946, 0.6696090803471069, 0.6746532158623126, 0.6544766705694596, 0.6746532158623126, 0.6746532165387841, 0.6633039087545677, 0.6645649428024869, 0.6481715013821518, 0.6645649436292853, 0.6645649436292853, 0.675914249910232, 0.6494325343777824, 0.6519546024736209, 0.6834804535212763, 0.6948297613054928, 0.6733921823405378, 0.6973518292510044, 0.6771752846346226, 0.6860025229700577, 0.6645649433286314, 0.6746532158623126, 0.6607818414855274, 0.6872635558153611, 0.6872635561911786, 0.6633039089048947, 0.675914249910232, 0.6948297604786944, 0.7061790660080062, 0.6683480447959178, 0.6696090801967799, 0.6759142490834336, 0.6796973513775184, 0.6973518280483886, 0.6885245897129535, 0.6860025217298602, 0.6796973527304612, 0.6834804540474207, 0.6960907940004692, 0.7074401005820699, 0.6935687259046307, 0.691046657959119, 0.6746532158623126, 0.6986128627727792, 0.7049180336888471, 0.682219419623684, 0.6960907948272677, 0.6847414875691956, 0.7061790666844776, 0.6872635564918326, 0.7074401004317429, 0.693568726581102, 0.6935687257543037, 0.6872635563415056, 0.6847414875691956, 0.6998738974971699, 0.696090795203085, 0.7150063053957301, 0.7099621686779085, 0.7074401016343587, 0.6986128634492507, 0.69482975995255, 0.708701135832605, 0.7225725096832458, 0.6986128627727792, 0.7301387139707616, 0.7087011351561335, 0.7023959638642483, 0.7112232027258277, 0.7162673389175049, 0.7250945779294113, 0.7187894082159593, 0.7263556118270037, 0.7061790665341506, 0.7200504415874073, 0.6973518280483886, 0.7276166465513944, 0.7175283734915686, 0.6973518280483886, 0.7124842371495645, 0.708701135832605, 0.7225725095329188, 0.6973518288751869, 0.7200504409109358, 0.7099621697301973, 0.7250945779294113, 0.7087011353064605, 0.7238335433553477, 0.7200504415874073, 0.706179067210622, 0.7213114753346725, 0.7200504414370803, 0.73518284911015, 0.7124842366234201, 0.7200504415874073, 0.7137452713478107, 0.7250945779294113, 0.7288776795470249, 0.7326607820666001, 0.7049180330123757, 0.7238335426788763, 0.7225725103597171, 0.738965952982668, 0.7162673389175049, 0.7288776805993137, 0.75283732578102, 0.7351828508389101, 0.7717528382285697, 0.7313997481690079, 0.7250945784555558]} . 11. Generate predictions . Previously, we calculated an overall score for our pre-trained model on the validation set. To end this notebook, let&#39;s access probabilities and class predictions for individual images using the .predict() method and np.round(). . We now have a deep learning model that can be used to identify honey bees and bumble bees in images! The next step is to explore transfer learning, which harnesses the prediction power of models that have been trained on far more images than the mere 1600 in our dataset. . # ... YOUR CODE FOR TASK 11 ... y_proba = pretrained_cnn.predict(x_eval) print(&quot;First five probabilities:&quot;) print(y_proba[:5]) print(&quot;&quot;) # predicted classes for x_eval # ... YOUR CODE FOR TASK 11 ... y_pred = np.round(y_proba).astype(&#39;int&#39;) print(&quot;First five class predictions:&quot;) print(y_pred[:5]) print(&quot;&quot;) . First five probabilities: [[0.4059349 ] [0.39441615] [0.3882965 ] [0.39129484] [0.42224088]] First five class predictions: [[0] [0] [0] [0] [0]] .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/29/Naive-Bees-Deep-Learning-with-Images.html",
            "relUrl": "/datacamp/projects/python/2021/03/29/Naive-Bees-Deep-Learning-with-Images.html",
            "date": " • Mar 29, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "Comparing Search Interest with Google Trends",
            "content": "1. The sisters and Google Trends . While I&#39;m not a fan nor a hater of the Kardashians and Jenners, the polarizing family intrigues me. Why? Their marketing prowess. Say what you will about them and what they stand for, they are great at the hype game. Everything they touch turns to content. . The sisters in particular over the past decade have been especially productive in this regard. Let&#39;s get some facts straight. I consider the &quot;sisters&quot; to be the following daughters of Kris Jenner. Three from her first marriage to lawyer Robert Kardashian: . Kourtney Kardashian (daughter of Robert Kardashian, born in 1979) | Kim Kardashian (daughter of Robert Kardashian, born in 1980) | Khloé Kardashian (daughter of Robert Kardashian, born in 1984) | . And two from her second marriage to Olympic gold medal-winning decathlete, Caitlyn Jenner (formerly Bruce): . Kendall Jenner (daughter of Caitlyn Jenner, born in 1995) | Kylie Jenner (daughter of Caitlyn Jenner, born in 1997) | . . This family tree can be confusing, but we aren&#39;t here to explain it. We&#39;re here to explore the data underneath the hype, and we&#39;ll do it using search interest data from Google Trends. We&#39;ll recreate the Google Trends plot to visualize their ups and downs over time, then make a few custom plots of our own. And we&#39;ll answer the big question: is Kim even the most famous sister anymore? . First, let&#39;s load and inspect our Google Trends data, which was downloaded in CSV form. The query parameters: each of the sisters, worldwide search data, 2007 to present day. (2007 was the year Kim became &quot;active&quot; according to Wikipedia.) . # ... YOUR CODE FOR TASK 1 ... import pandas as pd # Read in dataset trends = pd.read_csv(&#39;datasets/trends_kj_sisters.csv&#39;) # Inspect data # ... YOUR CODE FOR TASK 1 ... trends.head() . Month Kim Kardashian: (Worldwide) Khloé Kardashian: (Worldwide) Kourtney Kardashian: (Worldwide) Kendall Jenner: (Worldwide) Kylie Jenner: (Worldwide) . 0 2007-01 | 2 | &lt;1 | &lt;1 | &lt;1 | 2 | . 1 2007-02 | 12 | &lt;1 | &lt;1 | &lt;1 | 2 | . 2 2007-03 | 9 | &lt;1 | &lt;1 | &lt;1 | 1 | . 3 2007-04 | 6 | &lt;1 | &lt;1 | &lt;1 | 1 | . 4 2007-05 | 6 | &lt;1 | &lt;1 | &lt;1 | 2 | . 2. Better &quot;kolumn&quot; names . So we have a column for each month since January 2007 and a column for the worldwide search interest for each of the sisters each month. By the way, Google defines the values of search interest as: . Numbers represent search interest relative to the highest point on the chart for the given region and time. A value of 100 is the peak popularity for the term. A value of 50 means that the term is half as popular. A score of 0 means there was not enough data for this term. . Okay, that&#39;s great Google, but you are not making this data easily analyzable for us. I see a few things. Let&#39;s do the column names first. A column named &quot;Kim Kardashian: (Worldwide)&quot; is not the most usable for coding purposes. Let&#39;s shorten those so we can access their values better. Might as well standardize all column formats, too. I like lowercase, short column names. . # ... YOUR CODE FOR TASK 2 ... trends.columns = [&#39;month&#39;, &#39;kim&#39;, &#39;khloe&#39;, &#39;kourtney&#39;, &#39;kendall&#39;, &#39;kylie&#39;] # Inspect data # ... YOUR CODE FOR TASK 2 ... trends.head() . month kim khloe kourtney kendall kylie . 0 2007-01 | 2 | &lt;1 | &lt;1 | &lt;1 | 2 | . 1 2007-02 | 12 | &lt;1 | &lt;1 | &lt;1 | 2 | . 2 2007-03 | 9 | &lt;1 | &lt;1 | &lt;1 | 1 | . 3 2007-04 | 6 | &lt;1 | &lt;1 | &lt;1 | 1 | . 4 2007-05 | 6 | &lt;1 | &lt;1 | &lt;1 | 2 | . 3. Pesky data types . That&#39;s better. We don&#39;t need to scroll our eyes across the table to read the values anymore since it is much less wide. And seeing five columns that all start with the letter &quot;k&quot; … the aesthetics … we should call them &quot;kolumns&quot; now! (Bad joke.) . The next thing I see that is going to be an issue is that &quot;&lt;&quot; sign. If &quot;a score of 0 means there was not enough data for this term,&quot; &quot;&lt;1&quot; must mean it is between 0 and 1 and Google does not want to give us the fraction from google.trends.com for whatever reason. That&#39;s fine, but this &quot;&lt;&quot; sign means we won&#39;t be able to analyze or visualize our data right away because those column values aren&#39;t going to be represented as numbers in our data structure. Let&#39;s confirm that by inspecting our data types. . # ... YOUR CODE FOR TASK 3 ... trends.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 147 entries, 0 to 146 Data columns (total 6 columns): month 147 non-null object kim 147 non-null int64 khloe 147 non-null object kourtney 147 non-null object kendall 147 non-null object kylie 147 non-null int64 dtypes: int64(2), object(4) memory usage: 7.0+ KB . 4. From object to integer . Yes, okay, the khloe, kourtney, and kendall columns aren&#39;t integers like the kim and kylie columns are. Again, because of the &quot;&lt;&quot; sign that indicates a search interest value between zero and one. Is this an early hint at the hierarchy of sister popularity? We&#39;ll see shortly. Before that, we&#39;ll need to remove that pesky &quot;&lt;&quot; sign. Then we can change the type of those columns to integer. . # ... YOUR CODE FOR TASK 4 ... for col in trends.columns: # Only modify columns that have the &quot;&lt;&quot; sign if &quot;&lt;&quot; in trends[col].to_string(): # ... YOUR CODE FOR TASK 4 ... # Remove &quot;&lt;&quot; and convert dtype to integer # ... YOUR CODE FOR TASK 4 ... # ... YOUR CODE FOR TASK 4 ... trends[col] = pd.to_numeric(trends[col].str.replace(&quot;&lt;&quot;, &quot;&quot;)) # Inspect data types and data trends.info() trends.head() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 147 entries, 0 to 146 Data columns (total 6 columns): month 147 non-null object kim 147 non-null int64 khloe 147 non-null int64 kourtney 147 non-null int64 kendall 147 non-null int64 kylie 147 non-null int64 dtypes: int64(5), object(1) memory usage: 7.0+ KB . month kim khloe kourtney kendall kylie . 0 2007-01 | 2 | 1 | 1 | 1 | 2 | . 1 2007-02 | 12 | 1 | 1 | 1 | 2 | . 2 2007-03 | 9 | 1 | 1 | 1 | 1 | . 3 2007-04 | 6 | 1 | 1 | 1 | 1 | . 4 2007-05 | 6 | 1 | 1 | 1 | 2 | . 5. From object to datetime . Okay, great, no more &quot;&lt;&quot; signs. All the sister columns are of integer type. . Now let&#39;s convert our month column from type object to datetime to make our date data more accessible. . # ... YOUR CODE FOR TASK 5 ... trends[&#39;month&#39;] = pd.to_datetime(trends[&#39;month&#39;]) # Inspect data types and data # ... YOUR CODE FOR TASK 5 ... trends.info() # ... YOUR CODE FOR TASK 5 ... trends.head() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 147 entries, 0 to 146 Data columns (total 6 columns): month 147 non-null datetime64[ns] kim 147 non-null int64 khloe 147 non-null int64 kourtney 147 non-null int64 kendall 147 non-null int64 kylie 147 non-null int64 dtypes: datetime64[ns](1), int64(5) memory usage: 7.0 KB . month kim khloe kourtney kendall kylie . 0 2007-01-01 | 2 | 1 | 1 | 1 | 2 | . 1 2007-02-01 | 12 | 1 | 1 | 1 | 2 | . 2 2007-03-01 | 9 | 1 | 1 | 1 | 1 | . 3 2007-04-01 | 6 | 1 | 1 | 1 | 1 | . 4 2007-05-01 | 6 | 1 | 1 | 1 | 2 | . 6. Set month as index . And finally, let&#39;s set the month column as our index to wrap our data cleaning. Having month as index rather than the zero-based row numbers will allow us to write shorter lines of code to create plots, where month will represent our x-axis. . trends = trends.set_index(&#39;month&#39;, drop=True) # Inspect the data trends.head() . kim khloe kourtney kendall kylie . month . 2007-01-01 2 | 1 | 1 | 1 | 2 | . 2007-02-01 12 | 1 | 1 | 1 | 2 | . 2007-03-01 9 | 1 | 1 | 1 | 1 | . 2007-04-01 6 | 1 | 1 | 1 | 1 | . 2007-05-01 6 | 1 | 1 | 1 | 2 | . 7. The early Kim hype . Okay! So our data is ready to plot. Because we cleaned our data, we only need one line of code (and just thirteen characters!) to remake the Google Trends chart, plus another line to make the plot show up in our notebook. . # ... YOUR CODE FOR TASK 7 ... %matplotlib inline # ... YOUR CODE FOR TASK 7 ... trends.plot(y=&#39;kim&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f26bd6cb0f0&gt; . 8. Kylie&#39;s rise . Oh my! There is so much to make sense of here. Kim&#39;s sharp rise in 2007, with the beginning of Keeping Up with the Kardashians, among other things. There was no significant search interest for the other four sisters until mid-2009 when Kourtney and Khloé launched the reality television series, Kourtney and Khloé Take Miami. Then there was Kim&#39;s rise from famous to literally more famous than God in 2011. This Cosmopolitan article covers the timeline that includes the launch of music videos, fragrances, iPhone and Android games, another television series, joining Instagram, and more. Then there was Kim&#39;s ridiculous spike in December 2014: posing naked on the cover of Paper Magazine in a bid to break the internet will do that for you. . A curious thing starts to happen after that bid as well. Let&#39;s zoom in… . # ... YOUR CODE FOR TASK 8 ... trends.loc[&#39;01-01-2014&#39;:&#39;01-03-2019&#39;, :].plot() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f26bb512668&gt; . 9. Smooth out the fluctuations with rolling means . It looks like my suspicion may be true: Kim is not always the most searched Kardashian or Jenner sister. Since late-2016, at various months, Kylie overtakes Kim. Two big spikes where she smashed Kim&#39;s search interest: in September 2017 when it was reported that Kylie was expecting her first child with rapper Travis Scott and in February 2018 when she gave birth to her daughter, Stormi Webster. The continued success of Kylie Cosmetics has kept her in the news, not to mention making her the &quot;The Youngest Self-Made Billionaire Ever&quot; according to Forbes. . These fluctuations are descriptive but do not really help us answer our question: is Kim even the most famous sister anymore? We can use rolling means to smooth out short-term fluctuations in time series data and highlight long-term trends. Let&#39;s make the window twelve months a.k.a. one year. . # ... YOUR CODE FOR TASK 9 ... trends.rolling(window=12).mean().plot() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f26bb342a90&gt; . 10. Who&#39;s more famous? The Kardashians or the Jenners? . Whoa, okay! So by this metric, Kim is still the most famous sister despite Kylie being close and nearly taking her crown. Honestly, the biggest takeaway from this whole exercise might be Kendall not showing up that much. It makes sense, though, despite her wildly successful modeling career. Some have called her &quot;the only normal one in her family&quot; as she tends to shy away from the more dramatic and controversial parts of the media limelight that generate oh so many clicks. . Let&#39;s end this analysis with one last plot. In it, we will plot (pun!) the Kardashian sisters against the Jenner sisters to see which family line is more popular now. We will use average search interest to make things fair, i.e., total search interest divided by the number of sisters in the family line. . The answer? Since 2015, it has been a toss-up. And in the future? With this family and their penchant for big events, who knows? . # ... YOUR CODE FOR TASK 10 ... trends[&#39;kardashian&#39;] = (trends[&#39;kim&#39;] + trends[&#39;khloe&#39;] + trends[&#39;kourtney&#39;]) / 3 # ... YOUR CODE FOR TASK 10 ... trends[&#39;jenner&#39;] = (trends[&#39;kendall&#39;] + trends[&#39;kylie&#39;]) / 2 # Plot average family line search interest vs. month # ... YOUR CODE FOR TASK 10 ... trends[[&#39;kardashian&#39;, &#39;jenner&#39;]].plot() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f26bb3f5438&gt; .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/29/Comparing-Search-Interest-with-Google-Trends.html",
            "relUrl": "/datacamp/projects/python/2021/03/29/Comparing-Search-Interest-with-Google-Trends.html",
            "date": " • Mar 29, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "A Visual History of Nobel Prize Winners",
            "content": "1. The most Nobel of Prizes . The Nobel Prize is perhaps the world&#39;s most well known scientific award. Except for the honor, prestige and substantial prize money the recipient also gets a gold medal showing Alfred Nobel (1833 - 1896) who established the prize. Every year it&#39;s given to scientists and scholars in the categories chemistry, literature, physics, physiology or medicine, economics, and peace. The first Nobel Prize was handed out in 1901, and at that time the Prize was very Eurocentric and male-focused, but nowadays it&#39;s not biased in any way whatsoever. Surely. Right? . Well, we&#39;re going to find out! The Nobel Foundation has made a dataset available of all prize winners from the start of the prize, in 1901, to 2016. Let&#39;s load it in and take a look. . # ... YOUR CODE FOR TASK 1 ... import numpy as np import pandas as pd import seaborn as sns # Reading in the Nobel Prize data nobel = pd.read_csv(&#39;datasets/nobel.csv&#39;) # Taking a look at the first several winners # ... YOUR CODE FOR TASK 1 ... nobel.head(6) . year category prize motivation prize_share laureate_id laureate_type full_name birth_date birth_city birth_country sex organization_name organization_city organization_country death_date death_city death_country . 0 1901 | Chemistry | The Nobel Prize in Chemistry 1901 | &quot;in recognition of the extraordinary services ... | 1/1 | 160 | Individual | Jacobus Henricus van &#39;t Hoff | 1852-08-30 | Rotterdam | Netherlands | Male | Berlin University | Berlin | Germany | 1911-03-01 | Berlin | Germany | . 1 1901 | Literature | The Nobel Prize in Literature 1901 | &quot;in special recognition of his poetic composit... | 1/1 | 569 | Individual | Sully Prudhomme | 1839-03-16 | Paris | France | Male | NaN | NaN | NaN | 1907-09-07 | Châtenay | France | . 2 1901 | Medicine | The Nobel Prize in Physiology or Medicine 1901 | &quot;for his work on serum therapy, especially its... | 1/1 | 293 | Individual | Emil Adolf von Behring | 1854-03-15 | Hansdorf (Lawice) | Prussia (Poland) | Male | Marburg University | Marburg | Germany | 1917-03-31 | Marburg | Germany | . 3 1901 | Peace | The Nobel Peace Prize 1901 | NaN | 1/2 | 462 | Individual | Jean Henry Dunant | 1828-05-08 | Geneva | Switzerland | Male | NaN | NaN | NaN | 1910-10-30 | Heiden | Switzerland | . 4 1901 | Peace | The Nobel Peace Prize 1901 | NaN | 1/2 | 463 | Individual | Frédéric Passy | 1822-05-20 | Paris | France | Male | NaN | NaN | NaN | 1912-06-12 | Paris | France | . 5 1901 | Physics | The Nobel Prize in Physics 1901 | &quot;in recognition of the extraordinary services ... | 1/1 | 1 | Individual | Wilhelm Conrad Röntgen | 1845-03-27 | Lennep (Remscheid) | Prussia (Germany) | Male | Munich University | Munich | Germany | 1923-02-10 | Munich | Germany | . 2. So, who gets the Nobel Prize? . Just looking at the first couple of prize winners, or Nobel laureates as they are also called, we already see a celebrity: Wilhelm Conrad Röntgen, the guy who discovered X-rays. And actually, we see that all of the winners in 1901 were guys that came from Europe. But that was back in 1901, looking at all winners in the dataset, from 1901 to 2016, which sex and which country is the most commonly represented? . (For country, we will use the birth_country of the winner, as the organization_country is NaN for all shared Nobel Prizes.) . # out between 1901 and 2016 # ... YOUR CODE FOR TASK 2 ... display(nobel[nobel[&#39;prize_share&#39;] != &#39;1/1&#39;]) # Display the number of prizes won by male and female recipients. # ... YOUR CODE FOR TASK 2 ... display(nobel[&#39;sex&#39;].value_counts()) # Display the number of prizes won by the top 10 nationalities. # ... YOUR CODE FOR TASK 2 ... nobel[&#39;birth_country&#39;].value_counts().head(10) . year category prize motivation prize_share laureate_id laureate_type full_name birth_date birth_city birth_country sex organization_name organization_city organization_country death_date death_city death_country . 3 1901 | Peace | The Nobel Peace Prize 1901 | NaN | 1/2 | 462 | Individual | Jean Henry Dunant | 1828-05-08 | Geneva | Switzerland | Male | NaN | NaN | NaN | 1910-10-30 | Heiden | Switzerland | . 4 1901 | Peace | The Nobel Peace Prize 1901 | NaN | 1/2 | 463 | Individual | Frédéric Passy | 1822-05-20 | Paris | France | Male | NaN | NaN | NaN | 1912-06-12 | Paris | France | . 9 1902 | Peace | The Nobel Peace Prize 1902 | NaN | 1/2 | 464 | Individual | Élie Ducommun | 1833-02-19 | Geneva | Switzerland | Male | NaN | NaN | NaN | 1906-12-07 | Bern | Switzerland | . 10 1902 | Peace | The Nobel Peace Prize 1902 | NaN | 1/2 | 465 | Individual | Charles Albert Gobat | 1843-05-21 | Tramelan | Switzerland | Male | NaN | NaN | NaN | 1914-03-16 | Bern | Switzerland | . 11 1902 | Physics | The Nobel Prize in Physics 1902 | &quot;in recognition of the extraordinary service t... | 1/2 | 2 | Individual | Hendrik Antoon Lorentz | 1853-07-18 | Arnhem | Netherlands | Male | Leiden University | Leiden | Netherlands | 1928-02-04 | NaN | Netherlands | . 12 1902 | Physics | The Nobel Prize in Physics 1902 | &quot;in recognition of the extraordinary service t... | 1/2 | 3 | Individual | Pieter Zeeman | 1865-05-25 | Zonnemaire | Netherlands | Male | Amsterdam University | Amsterdam | Netherlands | 1943-10-09 | Amsterdam | Netherlands | . 17 1903 | Physics | The Nobel Prize in Physics 1903 | &quot;in recognition of the extraordinary services ... | 1/2 | 4 | Individual | Antoine Henri Becquerel | 1852-12-15 | Paris | France | Male | École Polytechnique | Paris | France | 1908-08-25 | NaN | France | . 18 1903 | Physics | The Nobel Prize in Physics 1903 | &quot;in recognition of the extraordinary services ... | 1/4 | 5 | Individual | Pierre Curie | 1859-05-15 | Paris | France | Male | École municipale de physique et de chimie indu... | Paris | France | 1906-04-19 | Paris | France | . 19 1903 | Physics | The Nobel Prize in Physics 1903 | &quot;in recognition of the extraordinary services ... | 1/4 | 6 | Individual | Marie Curie, née Sklodowska | 1867-11-07 | Warsaw | Russian Empire (Poland) | Female | NaN | NaN | NaN | 1934-07-04 | Sallanches | France | . 21 1904 | Literature | The Nobel Prize in Literature 1904 | &quot;in recognition of the fresh originality and t... | 1/2 | 573 | Individual | Frédéric Mistral | 1830-09-08 | Maillane | France | Male | NaN | NaN | NaN | 1914-03-25 | Maillane | France | . 22 1904 | Literature | The Nobel Prize in Literature 1904 | &quot;in recognition of the numerous and brilliant ... | 1/2 | 574 | Individual | José Echegaray y Eizaguirre | 1832-04-19 | Madrid | Spain | Male | NaN | NaN | NaN | 1916-09-04 | Madrid | Spain | . 33 1906 | Medicine | The Nobel Prize in Physiology or Medicine 1906 | &quot;in recognition of their work on the structure... | 1/2 | 298 | Individual | Camillo Golgi | 1843-07-07 | Corteno | Italy | Male | Pavia University | Pavia | Italy | 1926-01-21 | Pavia | Italy | . 34 1906 | Medicine | The Nobel Prize in Physiology or Medicine 1906 | &quot;in recognition of their work on the structure... | 1/2 | 299 | Individual | Santiago Ramón y Cajal | 1852-05-01 | Petilla de Aragó | Spain | Male | Madrid University | Madrid | Spain | 1934-10-17 | Madrid | Spain | . 40 1907 | Peace | The Nobel Peace Prize 1907 | NaN | 1/2 | 471 | Individual | Ernesto Teodoro Moneta | 1833-09-20 | Milan | Austrian Empire (Italy) | Male | NaN | NaN | NaN | 1918-02-10 | Milan | Italy | . 41 1907 | Peace | The Nobel Peace Prize 1907 | NaN | 1/2 | 472 | Individual | Louis Renault | 1843-05-21 | Autun | France | Male | Sorbonne University | Paris | France | 1918-02-08 | Barbizon | France | . 45 1908 | Medicine | The Nobel Prize in Physiology or Medicine 1908 | &quot;in recognition of their work on immunity&quot; | 1/2 | 301 | Individual | Ilya Ilyich Mechnikov | 1845-05-15 | Kharkov (Kharkiv) | Russian Empire (Ukraine) | Male | Institut Pasteur | Paris | France | 1916-07-15 | Paris | France | . 46 1908 | Medicine | The Nobel Prize in Physiology or Medicine 1908 | &quot;in recognition of their work on immunity&quot; | 1/2 | 302 | Individual | Paul Ehrlich | 1854-03-14 | Strehlen (Strzelin) | Prussia (Poland) | Male | Goettingen University | Göttingen | Germany | 1915-08-20 | Bad Homburg vor der Höhe | Germany | . 47 1908 | Peace | The Nobel Peace Prize 1908 | NaN | 1/2 | 473 | Individual | Klas Pontus Arnoldson | 1844-10-27 | Gothenburg | Sweden | Male | NaN | NaN | NaN | 1916-02-20 | Stockholm | Sweden | . 48 1908 | Peace | The Nobel Peace Prize 1908 | NaN | 1/2 | 474 | Individual | Fredrik Bajer | 1837-04-21 | Næstved | Denmark | Male | NaN | NaN | NaN | 1922-01-22 | Copenhagen | Denmark | . 53 1909 | Peace | The Nobel Peace Prize 1909 | NaN | 1/2 | 475 | Individual | Auguste Marie François Beernaert | 1829-07-26 | Ostend | Belgium | Male | NaN | NaN | NaN | 1912-10-06 | Lucerne | Switzerland | . 54 1909 | Peace | The Nobel Peace Prize 1909 | NaN | 1/2 | 476 | Individual | Paul Henri Benjamin Balluet d&#39;Estournelles de ... | 1852-11-22 | La Flèche | France | Male | NaN | NaN | NaN | 1924-05-15 | Paris | France | . 55 1909 | Physics | The Nobel Prize in Physics 1909 | &quot;in recognition of their contributions to the ... | 1/2 | 13 | Individual | Guglielmo Marconi | 1874-04-25 | Bologna | Italy | Male | Marconi Wireless Telegraph Co. Ltd. | London | United Kingdom | 1937-07-20 | Rome | Italy | . 56 1909 | Physics | The Nobel Prize in Physics 1909 | &quot;in recognition of their contributions to the ... | 1/2 | 14 | Individual | Karl Ferdinand Braun | 1850-06-06 | Fulda | Hesse-Kassel (Germany) | Male | Strasbourg University | Strasbourg | Alsace (then Germany, now France) | 1918-04-20 | Brooklyn, NY | United States of America | . 65 1911 | Peace | The Nobel Peace Prize 1911 | NaN | 1/2 | 478 | Individual | Tobias Michael Carel Asser | 1838-04-28 | Amsterdam | Netherlands | Male | NaN | NaN | NaN | 1913-07-29 | the Hague | Netherlands | . 66 1911 | Peace | The Nobel Peace Prize 1911 | NaN | 1/2 | 479 | Individual | Alfred Hermann Fried | 1864-11-11 | Vienna | Austria | Male | NaN | NaN | NaN | 1921-05-05 | Vienna | Austria | . 68 1912 | Chemistry | The Nobel Prize in Chemistry 1912 | &quot;for the discovery of the so-called Grignard r... | 1/2 | 172 | Individual | Victor Grignard | 1871-05-06 | Cherbourg | France | Male | Nancy University | Nancy | France | 1935-12-13 | Lyon | France | . 69 1912 | Chemistry | The Nobel Prize in Chemistry 1912 | &quot;for his method of hydrogenating organic compo... | 1/2 | 173 | Individual | Paul Sabatier | 1854-11-05 | Carcassonne | France | Male | Toulouse University | Toulouse | France | 1941-08-14 | Toulouse | France | . 84 1915 | Physics | The Nobel Prize in Physics 1915 | &quot;for their services in the analysis of crystal... | 1/2 | 20 | Individual | Sir William Henry Bragg | 1862-07-02 | Wigton | United Kingdom | Male | University College | London | United Kingdom | 1942-03-12 | London | United Kingdom | . 85 1915 | Physics | The Nobel Prize in Physics 1915 | &quot;for their services in the analysis of crystal... | 1/2 | 21 | Individual | William Lawrence Bragg | 1890-03-31 | Adelaide | Australia | Male | Victoria University | Manchester | United Kingdom | 1971-07-01 | Ipswich | United Kingdom | . 87 1917 | Literature | The Nobel Prize in Literature 1917 | &quot;for his varied and rich poetry, which is insp... | 1/2 | 586 | Individual | Karl Adolph Gjellerup | 1857-06-02 | Roholte | Denmark | Male | NaN | NaN | NaN | 1919-10-11 | Klotzsche | Germany | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 872 2013 | Medicine | The Nobel Prize in Physiology or Medicine 2013 | &quot;for their discoveries of machinery regulating... | 1/3 | 886 | Individual | Thomas C. Südhof | 1955-12-22 | Göttingen | Germany | Male | Stanford University | Stanford, CA | United States of America | NaN | NaN | NaN | . 874 2013 | Physics | The Nobel Prize in Physics 2013 | &quot;for the theoretical discovery of a mechanism ... | 1/2 | 887 | Individual | François Englert | 1932-11-06 | Etterbeek | Belgium | Male | Université Libre de Bruxelles | Brussels | Belgium | NaN | NaN | NaN | . 875 2013 | Physics | The Nobel Prize in Physics 2013 | &quot;for the theoretical discovery of a mechanism ... | 1/2 | 888 | Individual | Peter W. Higgs | 1929-05-29 | Newcastle upon Tyne | United Kingdom | Male | University of Edinburgh | Edinburgh | United Kingdom | NaN | NaN | NaN | . 876 2014 | Chemistry | The Nobel Prize in Chemistry 2014 | &quot;for the development of super-resolved fluores... | 1/3 | 909 | Individual | Eric Betzig | 1960-01-13 | Ann Arbor, MI | United States of America | Male | Janelia Research Campus, Howard Hughes Medical... | Ashburn, VA | United States of America | NaN | NaN | NaN | . 877 2014 | Chemistry | The Nobel Prize in Chemistry 2014 | &quot;for the development of super-resolved fluores... | 1/3 | 910 | Individual | Stefan W. Hell | 1962-12-23 | Arad | Romania | Male | Max Planck Institute for Biophysical Chemistry | Göttingen | Germany | NaN | NaN | NaN | . 878 2014 | Chemistry | The Nobel Prize in Chemistry 2014 | &quot;for the development of super-resolved fluores... | 1/3 | 911 | Individual | William E. Moerner | 1953-06-24 | Pleasanton, CA | United States of America | Male | Stanford University | Stanford, CA | United States of America | NaN | NaN | NaN | . 881 2014 | Medicine | The Nobel Prize in Physiology or Medicine 2014 | &quot;for their discoveries of cells that constitut... | 1/2 | 903 | Individual | John O&#39;Keefe | 1939-11-18 | New York, NY | United States of America | Male | University College | London | United Kingdom | NaN | NaN | NaN | . 882 2014 | Medicine | The Nobel Prize in Physiology or Medicine 2014 | &quot;for their discoveries of cells that constitut... | 1/4 | 904 | Individual | May-Britt Moser | 1963-01-04 | Fosnavåg | Norway | Female | Norwegian University of Science and Technology... | Trondheim | Norway | NaN | NaN | NaN | . 883 2014 | Medicine | The Nobel Prize in Physiology or Medicine 2014 | &quot;for their discoveries of cells that constitut... | 1/4 | 905 | Individual | Edvard I. Moser | 1962-04-27 | Ålesund | Norway | Male | Norwegian University of Science and Technology... | Trondheim | Norway | NaN | NaN | NaN | . 884 2014 | Peace | The Nobel Peace Prize 2014 | &quot;for their struggle against the suppression of... | 1/2 | 913 | Individual | Kailash Satyarthi | 1954-01-11 | Vidisha | India | Male | NaN | NaN | NaN | NaN | NaN | NaN | . 885 2014 | Peace | The Nobel Peace Prize 2014 | &quot;for their struggle against the suppression of... | 1/2 | 914 | Individual | Malala Yousafzai | 1997-07-12 | Mingora | Pakistan | Female | NaN | NaN | NaN | NaN | NaN | NaN | . 886 2014 | Physics | The Nobel Prize in Physics 2014 | &quot;for the invention of efficient blue light-emi... | 1/3 | 906 | Individual | Isamu Akasaki | 1929-01-30 | Chiran | Japan | Male | Meijo University | Nagoya | Japan | NaN | NaN | NaN | . 887 2014 | Physics | The Nobel Prize in Physics 2014 | &quot;for the invention of efficient blue light-emi... | 1/3 | 907 | Individual | Hiroshi Amano | 1960-09-11 | Hamamatsu | Japan | Male | Nagoya University | Nagoya | Japan | NaN | NaN | NaN | . 888 2014 | Physics | The Nobel Prize in Physics 2014 | &quot;for the invention of efficient blue light-emi... | 1/3 | 908 | Individual | Shuji Nakamura | 1954-05-22 | Ikata | Japan | Male | University of California | Santa Barbara, CA | United States of America | NaN | NaN | NaN | . 889 2015 | Chemistry | The Nobel Prize in Chemistry 2015 | &quot;for mechanistic studies of DNA repair&quot; | 1/3 | 921 | Individual | Tomas Lindahl | 1938-01-28 | Stockholm | Sweden | Male | Francis Crick Institute | Hertfordshire | United Kingdom | NaN | NaN | NaN | . 890 2015 | Chemistry | The Nobel Prize in Chemistry 2015 | &quot;for mechanistic studies of DNA repair&quot; | 1/3 | 922 | Individual | Paul Modrich | 1946-06-13 | Raton, NM | United States of America | Male | Howard Hughes Medical Institute | Durham, NC | United States of America | NaN | NaN | NaN | . 891 2015 | Chemistry | The Nobel Prize in Chemistry 2015 | &quot;for mechanistic studies of DNA repair&quot; | 1/3 | 923 | Individual | Aziz Sancar | 1946-09-08 | Savur | Turkey | Male | University of North Carolina | Chapel Hill, NC | United States of America | NaN | NaN | NaN | . 894 2015 | Medicine | The Nobel Prize in Physiology or Medicine 2015 | &quot;for their discoveries concerning a novel ther... | 1/4 | 916 | Individual | William C. Campbell | 1930-06-28 | Ramelton | Ireland | Male | Drew University | Madison, NJ | United States of America | NaN | NaN | NaN | . 895 2015 | Medicine | The Nobel Prize in Physiology or Medicine 2015 | &quot;for their discoveries concerning a novel ther... | 1/4 | 917 | Individual | Satoshi Ōmura | 1935-07-12 | Yamanashi Prefecture | Japan | Male | Kitasato University | Tokyo | Japan | NaN | NaN | NaN | . 896 2015 | Medicine | The Nobel Prize in Physiology or Medicine 2015 | &quot;for her discoveries concerning a novel therap... | 1/2 | 918 | Individual | Youyou Tu | 1930-12-30 | Zhejiang Ningbo | China | Female | China Academy of Traditional Chinese Medicine | Beijing | China | NaN | NaN | NaN | . 898 2015 | Physics | The Nobel Prize in Physics 2015 | &quot;for the discovery of neutrino oscillations, w... | 1/2 | 919 | Individual | Takaaki Kajita | 1959-03-09 | Higashimatsuyama | Japan | Male | University of Tokyo | Kashiwa | Japan | NaN | NaN | NaN | . 899 2015 | Physics | The Nobel Prize in Physics 2015 | &quot;for the discovery of neutrino oscillations, w... | 1/2 | 920 | Individual | Arthur B. McDonald | 1943-08-29 | Sydney | Canada | Male | Queen&#39;s University | Kingston | Canada | NaN | NaN | NaN | . 900 2016 | Chemistry | The Nobel Prize in Chemistry 2016 | &quot;for the design and synthesis of molecular mac... | 1/3 | 931 | Individual | Jean-Pierre Sauvage | 1944-10-21 | Paris | France | Male | University of Strasbourg | Strasbourg | France | NaN | NaN | NaN | . 901 2016 | Chemistry | The Nobel Prize in Chemistry 2016 | &quot;for the design and synthesis of molecular mac... | 1/3 | 932 | Individual | Sir J. Fraser Stoddart | 1942-05-24 | Edinburgh | United Kingdom | Male | Northwestern University | Evanston, IL | United States of America | NaN | NaN | NaN | . 902 2016 | Chemistry | The Nobel Prize in Chemistry 2016 | &quot;for the design and synthesis of molecular mac... | 1/3 | 933 | Individual | Bernard L. Feringa | 1951-05-18 | Barger-Compascuum | Netherlands | Male | University of Groningen | Groningen | Netherlands | NaN | NaN | NaN | . 903 2016 | Economics | The Sveriges Riksbank Prize in Economic Scienc... | &quot;for their contributions to contract theory&quot; | 1/2 | 935 | Individual | Oliver Hart | 1948-10-09 | London | United Kingdom | Male | Harvard University | Cambridge, MA | United States of America | NaN | NaN | NaN | . 904 2016 | Economics | The Sveriges Riksbank Prize in Economic Scienc... | &quot;for their contributions to contract theory&quot; | 1/2 | 936 | Individual | Bengt Holmström | 1949-04-18 | Helsinki | Finland | Male | Massachusetts Institute of Technology (MIT) | Cambridge, MA | United States of America | NaN | NaN | NaN | . 908 2016 | Physics | The Nobel Prize in Physics 2016 | &quot;for theoretical discoveries of topological ph... | 1/2 | 928 | Individual | David J. Thouless | 1934-09-21 | Bearsden | United Kingdom | Male | University of Washington | Seattle, WA | United States of America | NaN | NaN | NaN | . 909 2016 | Physics | The Nobel Prize in Physics 2016 | &quot;for theoretical discoveries of topological ph... | 1/4 | 929 | Individual | F. Duncan M. Haldane | 1951-09-14 | London | United Kingdom | Male | Princeton University | Princeton, NJ | United States of America | NaN | NaN | NaN | . 910 2016 | Physics | The Nobel Prize in Physics 2016 | &quot;for theoretical discoveries of topological ph... | 1/4 | 930 | Individual | J. Michael Kosterlitz | 1943-06-22 | Aberdeen | United Kingdom | Male | Brown University | Providence, RI | United States of America | NaN | NaN | NaN | . 567 rows × 18 columns . Male 836 Female 49 Name: sex, dtype: int64 . United States of America 259 United Kingdom 85 Germany 61 France 51 Sweden 29 Japan 24 Canada 18 Netherlands 18 Italy 17 Russia 17 Name: birth_country, dtype: int64 . 3. USA dominance . Not so surprising perhaps: the most common Nobel laureate between 1901 and 2016 was a man born in the United States of America. But in 1901 all the winners were European. When did the USA start to dominate the Nobel Prize charts? . nobel[&#39;usa_born_winner&#39;] = nobel[&#39;birth_country&#39;] == &quot;United States of America&quot; nobel[&#39;decade&#39;] = np.floor((nobel[&#39;year&#39;] - 1910)/10 + 1).astype(&#39;int64&#39;) prop_usa_winners = nobel.groupby(&#39;decade&#39;, as_index=False).agg({&#39;usa_born_winner&#39;: &#39;mean&#39;}) # Display the proportions of USA born winners per decade # ... YOUR CODE FOR TASK 3 ... display(prop_usa_winners) . decade usa_born_winner . 0 0 | 0.017544 | . 1 1 | 0.075000 | . 2 2 | 0.074074 | . 3 3 | 0.250000 | . 4 4 | 0.302326 | . 5 5 | 0.291667 | . 6 6 | 0.265823 | . 7 7 | 0.317308 | . 8 8 | 0.319588 | . 9 9 | 0.403846 | . 10 10 | 0.422764 | . 11 11 | 0.292683 | . 4. USA dominance, visualized . A table is OK, but to see when the USA started to dominate the Nobel charts we need a plot! . sns.set() # and setting the size of all plots. import matplotlib.pyplot as plt plt.rcParams[&#39;figure.figsize&#39;] = [11, 7] # Plotting USA born winners ax = sns.lineplot(x=&#39;decade&#39;, y=&#39;usa_born_winner&#39;, data=nobel) # Adding %-formatting to the y-axis from matplotlib.ticker import PercentFormatter # ... YOUR CODE FOR TASK 4 ... ax.yaxis.set_major_formatter(PercentFormatter()) . 5. What is the gender of a typical Nobel Prize winner? . So the USA became the dominating winner of the Nobel Prize first in the 1930s and had kept the leading position ever since. But one group that was in the lead from the start, and never seems to let go, are men. Maybe it shouldn&#39;t come as a shock that there is some imbalance between how many male and female prize winners there are, but how significant is this imbalance? And is it better or worse within specific prize categories like physics, medicine, literature, etc.? . nobel[&#39;female_winner&#39;] = nobel[&#39;sex&#39;] == &quot;Female&quot; prop_female_winners = nobel.groupby([&#39;decade&#39;, &#39;category&#39;], as_index=False).agg({&#39;female_winner&#39;: &#39;mean&#39;}) # Plotting USA born winners with % winners on the y-axis # ... YOUR CODE FOR TASK 5 ... ax = sns.lineplot(x=&#39;decade&#39;, y=&#39;female_winner&#39;, hue=&#39;category&#39;, data=nobel) # Adding %-formatting to the y-axis from matplotlib.ticker import PercentFormatter # ... YOUR CODE FOR TASK 4 ... ax.yaxis.set_major_formatter(PercentFormatter()) . 6. The first woman to win the Nobel Prize . The plot above is a bit messy as the lines are overplotting. But it does show some interesting trends and patterns. Overall the imbalance is pretty large with physics, economics, and chemistry having the largest imbalance. Medicine has a somewhat positive trend, and since the 1990s the literature prize is also now more balanced. The big outlier is the peace prize during the 2010s, but keep in mind that this just covers the years 2010 to 2016. . Given this imbalance, who was the first woman to receive a Nobel Prize? And in what category? . # ... YOUR CODE FOR TASK 5 ... nobel[nobel[&#39;sex&#39;] == &quot;Female&quot;].nsmallest(1, &#39;year&#39;) . year category prize motivation prize_share laureate_id laureate_type full_name birth_date birth_city ... sex organization_name organization_city organization_country death_date death_city death_country usa_born_winner decade female_winner . 19 1903 | Physics | The Nobel Prize in Physics 1903 | &quot;in recognition of the extraordinary services ... | 1/4 | 6 | Individual | Marie Curie, née Sklodowska | 1867-11-07 | Warsaw | ... | Female | NaN | NaN | NaN | 1934-07-04 | Sallanches | France | False | 0 | True | . 1 rows × 21 columns . 7. Repeat laureates . For most scientists/writers/activists a Nobel Prize would be the crowning achievement of a long career. But for some people, one is just not enough, and few have gotten it more than once. Who are these lucky few? (Having won no Nobel Prize myself, I&#39;ll assume it&#39;s just about luck.) . # ... YOUR CODE FOR TASK 5 ... nobel.groupby(&#39;full_name&#39;).filter(lambda x: x[&#39;year&#39;].count() &gt;= 2) . year category prize motivation prize_share laureate_id laureate_type full_name birth_date birth_city ... sex organization_name organization_city organization_country death_date death_city death_country usa_born_winner decade female_winner . 19 1903 | Physics | The Nobel Prize in Physics 1903 | &quot;in recognition of the extraordinary services ... | 1/4 | 6 | Individual | Marie Curie, née Sklodowska | 1867-11-07 | Warsaw | ... | Female | NaN | NaN | NaN | 1934-07-04 | Sallanches | France | False | 0 | True | . 62 1911 | Chemistry | The Nobel Prize in Chemistry 1911 | &quot;in recognition of her services to the advance... | 1/1 | 6 | Individual | Marie Curie, née Sklodowska | 1867-11-07 | Warsaw | ... | Female | Sorbonne University | Paris | France | 1934-07-04 | Sallanches | France | False | 1 | True | . 89 1917 | Peace | The Nobel Peace Prize 1917 | NaN | 1/1 | 482 | Organization | Comité international de la Croix Rouge (Intern... | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | False | 1 | False | . 215 1944 | Peace | The Nobel Peace Prize 1944 | NaN | 1/1 | 482 | Organization | Comité international de la Croix Rouge (Intern... | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | False | 4 | False | . 278 1954 | Chemistry | The Nobel Prize in Chemistry 1954 | &quot;for his research into the nature of the chemi... | 1/1 | 217 | Individual | Linus Carl Pauling | 1901-02-28 | Portland, OR | ... | Male | California Institute of Technology (Caltech) | Pasadena, CA | United States of America | 1994-08-19 | Big Sur, CA | United States of America | True | 5 | False | . 283 1954 | Peace | The Nobel Peace Prize 1954 | NaN | 1/1 | 515 | Organization | Office of the United Nations High Commissioner... | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | False | 5 | False | . 298 1956 | Physics | The Nobel Prize in Physics 1956 | &quot;for their researches on semiconductors and th... | 1/3 | 66 | Individual | John Bardeen | 1908-05-23 | Madison, WI | ... | Male | University of Illinois | Urbana, IL | United States of America | 1991-01-30 | Boston, MA | United States of America | True | 5 | False | . 306 1958 | Chemistry | The Nobel Prize in Chemistry 1958 | &quot;for his work on the structure of proteins, es... | 1/1 | 222 | Individual | Frederick Sanger | 1918-08-13 | Rendcombe | ... | Male | University of Cambridge | Cambridge | United Kingdom | 2013-11-19 | Cambridge | United Kingdom | False | 5 | False | . 340 1962 | Peace | The Nobel Peace Prize 1962 | NaN | 1/1 | 217 | Individual | Linus Carl Pauling | 1901-02-28 | Portland, OR | ... | Male | California Institute of Technology (Caltech) | Pasadena, CA | United States of America | 1994-08-19 | Big Sur, CA | United States of America | True | 6 | False | . 348 1963 | Peace | The Nobel Peace Prize 1963 | NaN | 1/2 | 482 | Organization | Comité international de la Croix Rouge (Intern... | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | False | 6 | False | . 424 1972 | Physics | The Nobel Prize in Physics 1972 | &quot;for their jointly developed theory of superco... | 1/3 | 66 | Individual | John Bardeen | 1908-05-23 | Madison, WI | ... | Male | University of Illinois | Urbana, IL | United States of America | 1991-01-30 | Boston, MA | United States of America | True | 7 | False | . 505 1980 | Chemistry | The Nobel Prize in Chemistry 1980 | &quot;for their contributions concerning the determ... | 1/4 | 222 | Individual | Frederick Sanger | 1918-08-13 | Rendcombe | ... | Male | MRC Laboratory of Molecular Biology | Cambridge | United Kingdom | 2013-11-19 | Cambridge | United Kingdom | False | 8 | False | . 523 1981 | Peace | The Nobel Peace Prize 1981 | NaN | 1/1 | 515 | Organization | Office of the United Nations High Commissioner... | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | False | 8 | False | . 13 rows × 21 columns . 8. How old are you when you get the prize? . The list of repeat winners contains some illustrious names! We again meet Marie Curie, who got the prize in physics for discovering radiation and in chemistry for isolating radium and polonium. John Bardeen got it twice in physics for transistors and superconductivity, Frederick Sanger got it twice in chemistry, and Linus Carl Pauling got it first in chemistry and later in peace for his work in promoting nuclear disarmament. We also learn that organizations also get the prize as both the Red Cross and the UNHCR have gotten it twice. . But how old are you generally when you get the prize? . nobel[&#39;birth_date&#39;] = pd.to_datetime(nobel[&#39;birth_date&#39;], format=&#39;%Y-%m-%d&#39;) # Calculating the age of Nobel Prize winners nobel[&#39;age&#39;] = nobel[&#39;year&#39;] - nobel[&#39;birth_date&#39;].dt.year # Plotting the age of Nobel Prize winners sns.lmplot(x=&#39;year&#39;, y=&#39;age&#39;, data=nobel, lowess=True, aspect=2, line_kws={&#39;color&#39;: &#39;black&#39;}) . &lt;seaborn.axisgrid.FacetGrid at 0x7f181c5ffe10&gt; . 9. Age differences between prize categories . The plot above shows us a lot! We see that people use to be around 55 when they received the price, but nowadays the average is closer to 65. But there is a large spread in the laureates&#39; ages, and while most are 50+, some are very young. . We also see that the density of points is much high nowadays than in the early 1900s -- nowadays many more of the prizes are shared, and so there are many more winners. We also see that there was a disruption in awarded prizes around the Second World War (1939 - 1945). . Let&#39;s look at age trends within different prize categories. . # ... YOUR CODE FOR TASK 9 ... sns.lmplot(x=&#39;year&#39;, y=&#39;age&#39;, data=nobel, row=&#39;category&#39;) . &lt;seaborn.axisgrid.FacetGrid at 0x7f181c5edfd0&gt; . 10. Oldest and youngest winners . More plots with lots of exciting stuff going on! We see that both winners of the chemistry, medicine, and physics prize have gotten older over time. The trend is strongest for physics: the average age used to be below 50, and now it&#39;s almost 70. Literature and economics are more stable. We also see that economics is a newer category. But peace shows an opposite trend where winners are getting younger! . In the peace category we also a winner around 2010 that seems exceptionally young. This begs the questions, who are the oldest and youngest people ever to have won a Nobel Prize? . # ... YOUR CODE FOR TASK 10 ... display(nobel.nlargest(1, &#39;age&#39;)) # The youngest winner of a Nobel Prize as of 2016 # ... YOUR CODE FOR TASK 10 ... display(nobel.nsmallest(1, &#39;age&#39;)) . year category prize motivation prize_share laureate_id laureate_type full_name birth_date birth_city ... organization_name organization_city organization_country death_date death_city death_country usa_born_winner decade female_winner age . 793 2007 | Economics | The Sveriges Riksbank Prize in Economic Scienc... | &quot;for having laid the foundations of mechanism ... | 1/3 | 820 | Individual | Leonid Hurwicz | 1917-08-21 | Moscow | ... | University of Minnesota | Minneapolis, MN | United States of America | 2008-06-24 | Minneapolis, MN | United States of America | False | 10 | False | 90.0 | . 1 rows × 22 columns . year category prize motivation prize_share laureate_id laureate_type full_name birth_date birth_city ... organization_name organization_city organization_country death_date death_city death_country usa_born_winner decade female_winner age . 885 2014 | Peace | The Nobel Peace Prize 2014 | &quot;for their struggle against the suppression of... | 1/2 | 914 | Individual | Malala Yousafzai | 1997-07-12 | Mingora | ... | NaN | NaN | NaN | NaN | NaN | NaN | False | 11 | True | 17.0 | . 1 rows × 22 columns . 11. You get a prize! . Hey! You get a prize for making it to the very end of this notebook! It might not be a Nobel Prize, but I made it myself in paint so it should count for something. But don&#39;t despair, Leonid Hurwicz was 90 years old when he got his prize, so it might not be too late for you. Who knows. . Before you leave, what was again the name of the youngest winner ever who in 2014 got the prize for &quot;[her] struggle against the suppression of children and young people and for the right of all children to education&quot;? . youngest_winner = &#39;Malala Yousafzai&#39; .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/29/A-Visual-History-of-Nobel-Prize-Winners.html",
            "relUrl": "/datacamp/projects/python/2021/03/29/A-Visual-History-of-Nobel-Prize-Winners.html",
            "date": " • Mar 29, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "The GitHub History of the Scala Language",
            "content": "1. Scala&#39;s real-world project repository data . With almost 30k commits and a history spanning over ten years, Scala is a mature programming language. It is a general-purpose programming language that has recently become another prominent language for data scientists. . Scala is also an open source project. Open source projects have the advantage that their entire development histories -- who made changes, what was changed, code reviews, etc. -- are publicly available. . We&#39;re going to read in, clean up, and visualize the real world project repository of Scala that spans data from a version control system (Git) as well as a project hosting site (GitHub). We will find out who has had the most influence on its development and who are the experts. . The dataset we will use, which has been previously mined and extracted from GitHub, is comprised of three files: . pulls_2011-2013.csv contains the basic information about the pull requests, and spans from the end of 2011 up to (but not including) 2014. | pulls_2014-2018.csv contains identical information, and spans from 2014 up to 2018. | pull_files.csv contains the files that were modified by each pull request. | # ... YOUR CODE FOR TASK 1 ... import pandas as pd # Loading in the data pulls_one = pd.read_csv(&#39;datasets/pulls_2011-2013.csv&#39;) pulls_two = pd.read_csv(&#39;datasets/pulls_2014-2018.csv&#39;) pull_files = pd.read_csv(&#39;datasets/pull_files.csv&#39;) . 2. Preparing and cleaning the data . First, we will need to combine the data from the two separate pull DataFrames. . Next, the raw data extracted from GitHub contains dates in the ISO8601 format. However, pandas imports them as regular strings. To make our analysis easier, we need to convert the strings into Python&#39;s DateTime objects. DateTime objects have the important property that they can be compared and sorted. . The pull request times are all in UTC (also known as Coordinated Universal Time). The commit times, however, are in the local time of the author with time zone information (number of hours difference from UTC). To make comparisons easy, we should convert all times to UTC. . pulls = pulls_one.append(pulls_two) # Convert the date for the pulls object pulls[&#39;date&#39;] = pd.to_datetime(pulls[&#39;date&#39;], utc=True) . 3. Merging the DataFrames . The data extracted comes in two separate files. Merging the two DataFrames will make it easier for us to analyze the data in the future tasks. . data = pulls.merge(pull_files, on=&#39;pid&#39;) . 4. Is the project still actively maintained? . The activity in an open source project is not very consistent. Some projects might be active for many years after the initial release, while others can slowly taper out into oblivion. Before committing to contributing to a project, it is important to understand the state of the project. Is development going steadily, or is there a drop? Has the project been abandoned altogether? . The data used in this project was collected in January of 2018. We are interested in the evolution of the number of contributions up to that date. . For Scala, we will do this by plotting a chart of the project&#39;s activity. We will calculate the number of pull requests submitted each (calendar) month during the project&#39;s lifetime. We will then plot these numbers to see the trend of contributions. . A helpful reminder of how to access various components of a date can be found in this exercise of Data Manipulation with pandas . | Additionally, recall that you can group by multiple variables by passing a list to groupby(). This video from Data Manipulation with pandas should help! . | . %matplotlib inline # Create a column that will store the month data[&#39;month&#39;] = data[&#39;date&#39;].dt.month # Create a column that will store the year data[&#39;year&#39;] = data[&#39;date&#39;].dt.year # Group by the month and year and count the pull requests counts = data.groupby([&#39;month&#39;, &#39;year&#39;]).agg({&#39;pid&#39;: &#39;count&#39;}) # Plot the results counts.plot(kind=&#39;bar&#39;, figsize = (12,4)) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7ff55e0f81d0&gt; . 5. Is there camaraderie in the project? . The organizational structure varies from one project to another, and it can influence your success as a contributor. A project that has a very small community might not be the best one to start working on. The small community might indicate a high barrier of entry. This can be caused by several factors, including a community that is reluctant to accept pull requests from &quot;outsiders,&quot; that the code base is hard to work with, etc. However, a large community can serve as an indicator that the project is regularly accepting pull requests from new contributors. Such a project would be a good place to start. . In order to evaluate the dynamics of the community, we will plot a histogram of the number of pull requests submitted by each user. A distribution that shows that there are few people that only contribute a small number of pull requests can be used as in indicator that the project is not welcoming of new contributors. . %matplotlib inline # Group by the submitter by_user = data.groupby(&#39;user&#39;).agg({&#39;pid&#39;: &#39;count&#39;}) # Plot the histogram # ... YOUR CODE FOR TASK 5 ... by_user.plot(kind=&#39;hist&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7ff55e0c9cc0&gt; . 6. What files were changed in the last ten pull requests? . Choosing the right place to make a contribution is as important as choosing the project to contribute to. Some parts of the code might be stable, some might be dead. Contributing there might not have the most impact. Therefore it is important to understand the parts of the system that have been recently changed. This allows us to pinpoint the &quot;hot&quot; areas of the code where most of the activity is happening. Focusing on those parts might not the most effective use of our times. . last_10 = pulls.nlargest(10, &#39;pid&#39;, keep=&#39;last&#39;) # Join the two data sets joined_pr = last_10.merge(pull_files, on=&#39;pid&#39;) # Identify the unique files files = set(joined_pr[&#39;file&#39;]) # Print the results files . {&#39;LICENSE&#39;, &#39;doc/LICENSE.md&#39;, &#39;doc/License.rtf&#39;, &#39;project/VersionUtil.scala&#39;, &#39;src/compiler/scala/reflect/reify/phases/Calculate.scala&#39;, &#39;src/compiler/scala/tools/nsc/backend/jvm/BCodeHelpers.scala&#39;, &#39;src/compiler/scala/tools/nsc/backend/jvm/PostProcessor.scala&#39;, &#39;src/compiler/scala/tools/nsc/backend/jvm/analysis/BackendUtils.scala&#39;, &#39;src/compiler/scala/tools/nsc/profile/AsyncHelper.scala&#39;, &#39;src/compiler/scala/tools/nsc/profile/Profiler.scala&#39;, &#39;src/compiler/scala/tools/nsc/symtab/classfile/ClassfileParser.scala&#39;, &#39;src/compiler/scala/tools/nsc/typechecker/Contexts.scala&#39;, &#39;src/library/scala/Predef.scala&#39;, &#39;src/library/scala/concurrent/Lock.scala&#39;, &#39;src/library/scala/util/Properties.scala&#39;, &#39;src/reflect/scala/reflect/internal/pickling/ByteCodecs.scala&#39;, &#39;src/reflect/scala/reflect/internal/tpe/GlbLubs.scala&#39;, &#39;src/scaladoc/scala/tools/nsc/doc/html/page/Entity.scala&#39;, &#39;src/scalap/decoder.properties&#39;, &#39;test/files/neg/leibniz-liskov.check&#39;, &#39;test/files/neg/leibniz-liskov.scala&#39;, &#39;test/files/pos/leibniz-liskov.scala&#39;, &#39;test/files/pos/leibniz_liskov.scala&#39;, &#39;test/files/pos/parallel-classloader.scala&#39;, &#39;test/files/pos/t10568/Converter.java&#39;, &#39;test/files/pos/t10568/Impl.scala&#39;, &#39;test/files/pos/t10686.scala&#39;, &#39;test/files/pos/t5638/Among.java&#39;, &#39;test/files/pos/t5638/Usage.scala&#39;, &#39;test/files/pos/t9291.scala&#39;, &#39;test/files/run/t8348.check&#39;, &#39;test/files/run/t8348/TableColumn.java&#39;, &#39;test/files/run/t8348/TableColumnImpl.java&#39;, &#39;test/files/run/t8348/Test.scala&#39;} . 7. Who made the most pull requests to a given file? . When contributing to a project, we might need some guidance. We might find ourselves needing some information regarding the codebase. It is important direct any questions to the right person. Contributors to open source projects generally have other day jobs, so their time is limited. It is important to address our questions to the right people. One way to identify the right target for our inquiries is by using their contribution history. . We identified src/compiler/scala/reflect/reify/phases/Calculate.scala as being recently changed. We are interested in the top 3 developers who changed that file. Those developers are the ones most likely to have the best understanding of the code. . file = &#39;src/compiler/scala/reflect/reify/phases/Calculate.scala&#39; # Identify the commits that changed the file file_pr = data[data[&#39;file&#39;] == file] # Count the number of changes made by each developer author_counts = file_pr.groupby(&#39;user&#39;).agg({&#39;user&#39;: &#39;count&#39;}) # Print the top 3 developers # ... YOUR CODE FOR TASK 7 ... author_counts.nlargest(3, &#39;user&#39;, keep=&#39;first&#39;) . user . user . xeno-by 11 | . retronym 5 | . soc 4 | . 8. Who made the last ten pull requests on a given file? . Open source projects suffer from fluctuating membership. This makes the problem of finding the right person more challenging: the person has to be knowledgeable and still be involved in the project. A person that contributed a lot in the past might no longer be available (or willing) to help. To get a better understanding, we need to investigate the more recent history of that particular part of the system. . Like in the previous task, we will look at the history of src/compiler/scala/reflect/reify/phases/Calculate.scala. . file = &#39;src/compiler/scala/reflect/reify/phases/Calculate.scala&#39; # Select the pull requests that changed the target file file_pr = data[data[&#39;file&#39;] == file] # Merge the obtained results with the pulls DataFrame joined_pr = file_pr.merge(pulls, on=&#39;pid&#39;) # Find the users of the last 10 most recent pull requests users_last_10 = set(joined_pr.sort_values(by=&#39;date_x&#39;, ascending=False)[&#39;user_x&#39;][:10]) # Printing the results users_last_10 . {&#39;bjornregnell&#39;, &#39;retronym&#39;, &#39;soc&#39;, &#39;starblood&#39;, &#39;xeno-by&#39;, &#39;zuvizudar&#39;} . 9. The pull requests of two special developers . Now that we have identified two potential contacts in the projects, we need to find the person who was most involved in the project in recent times. That person is most likely to answer our questions. For each calendar year, we are interested in understanding the number of pull requests the authors submitted. This will give us a high-level image of their contribution trend to the project. . %matplotlib inline # The developers we are interested in authors = [&#39;xeno-by&#39;, &#39;soc&#39;] # Get all the developers&#39; pull requests by_author = pulls[pulls[&#39;user&#39;].isin(authors)] # Count the number of pull requests submitted each year counts = by_author.groupby([&#39;user&#39;, by_author.date.dt.year]).agg({&#39;pid&#39;: &#39;count&#39;}).reset_index() # Convert the table to a wide format counts_wide = counts.pivot_table(index=&#39;date&#39;, columns=&#39;user&#39;, values=&#39;pid&#39;, fill_value=0) # Plot the results # ... YOUR CODE FOR TASK 9 ... counts_wide.plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7ff55bcbaac8&gt; . 10. Visualizing the contributions of each developer . As mentioned before, it is important to make a distinction between the global expertise and contribution levels and the contribution levels at a more granular level (file, submodule, etc.) In our case, we want to see which of our two developers of interest have the most experience with the code in a given file. We will measure experience by the number of pull requests submitted that affect that file and how recent those pull requests were submitted. . authors = [&#39;xeno-by&#39;, &#39;soc&#39;] file = &#39;src/compiler/scala/reflect/reify/phases/Calculate.scala&#39; # Select the pull requests submitted by the authors, from the `data` DataFrame by_author = data[data[&#39;user&#39;].isin(authors)] # Select the pull requests that affect the file by_file = by_author[by_author[&#39;file&#39;] == file] # Group and count the number of PRs done by each user each year grouped = by_file.groupby([&#39;user&#39;, by_file[&#39;date&#39;].dt.year]).count()[&#39;pid&#39;].reset_index() # Transform the data into a wide format by_file_wide = grouped.pivot_table(values=[&#39;pid&#39;], index=[&#39;date&#39;], columns=[&#39;user&#39;], fill_value=0) # Plot the results by_file_wide.plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7ff55badabe0&gt; .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/28/The-GitHub-History-of-the-Scala-Language.html",
            "relUrl": "/datacamp/projects/python/2021/03/28/The-GitHub-History-of-the-Scala-Language.html",
            "date": " • Mar 28, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "Who's Tweeting? Trump or Trudeau?",
            "content": "1. Tweet classification: Trump vs. Trudeau . So you think you can classify text? How about tweets? In this notebook, we&#39;ll take a dive into the world of social media text classification by investigating how to properly classify tweets from two prominent North American politicians: Donald Trump and Justin Trudeau. . . Photo Credit: Executive Office of the President of the United States . Tweets pose specific problems to NLP, including the fact they are shorter texts. There are also plenty of platform-specific conventions to give you hassles: mentions, #hashtags, emoji, links and short-hand phrases (ikr?). Can we overcome those challenges and build a useful classifier for these two tweeters? Yes! Let&#39;s get started. . To begin, we will import all the tools we need from scikit-learn. We will need to properly vectorize our data (CountVectorizer and TfidfVectorizer). And we will also want to import some models, including MultinomialNB from the naive_bayes module, LinearSVC from the svm module and PassiveAggressiveClassifier from the linear_model module. Finally, we&#39;ll need sklearn.metrics and train_test_split and GridSearchCV from the model_selection module to evaluate and optimize our model. . import random; random.seed(53) # Import all we need from sklearn from sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer from sklearn.model_selection import train_test_split from sklearn.naive_bayes import MultinomialNB from sklearn.svm import LinearSVC from sklearn import metrics . 2. Transforming our collected data . To begin, let&#39;s start with a corpus of tweets which were collected in November 2017. They are available in CSV format. We&#39;ll use a Pandas DataFrame to help import the data and pass it to scikit-learn for further processing. . Since the data has been collected via the Twitter API and not split into test and training sets, we&#39;ll need to do this. Let&#39;s use train_test_split() with random_state=53 and a test size of 0.33, just as we did in the DataCamp course. This will ensure we have enough test data and we&#39;ll get the same results no matter where or when we run this code. . import pandas as pd # Load data tweet_df = pd.read_csv(&#39;datasets/tweets.csv&#39;) # Create target y = tweet_df[&#39;author&#39;] # Split training and testing data X_train, X_test, y_train, y_test = train_test_split(tweet_df[&#39;status&#39;], y, test_size=0.33, random_state=53) . 3. Vectorize the tweets . We have the training and testing data all set up, but we need to create vectorized representations of the tweets in order to apply machine learning. . To do so, we will utilize the CountVectorizer and TfidfVectorizer classes which we will first need to fit to the data. . Once this is complete, we can start modeling with the new vectorized tweets! . count_vectorizer = CountVectorizer(min_df=0.05, max_df=0.9, stop_words=&#39;english&#39;) # Create count train and test variables count_train = count_vectorizer.fit_transform(X_train, y_train) count_test = count_vectorizer.transform(X_test) # Initialize tfidf vectorizer tfidf_vectorizer = TfidfVectorizer(min_df=0.05, max_df=0.9, stop_words=&#39;english&#39;) # Create tfidf train and test variables tfidf_train = tfidf_vectorizer.fit_transform(X_train, y_train) tfidf_test = tfidf_vectorizer.transform(X_test) . 4. Training a multinomial naive Bayes model . Now that we have the data in vectorized form, we can train the first model. Investigate using the Multinomial Naive Bayes model with both the CountVectorizer and TfidfVectorizer data. Which do will perform better? How come? . To assess the accuracies, we will print the test sets accuracy scores for both models. . tfidf_nb = MultinomialNB() # ... Train your model here ... tfidf_nb.fit(tfidf_train, y_train) # Run predict on your TF-IDF test data to get your predictions tfidf_nb_pred = tfidf_nb.predict(tfidf_test) # Calculate the accuracy of your predictions tfidf_nb_score = metrics.accuracy_score(tfidf_nb_pred, y_test) # Create a MulitnomialNB model count_nb = MultinomialNB() # ... Train your model here ... count_nb.fit(count_train, y_train) # Run predict on your count test data to get your predictions count_nb_pred = count_nb.predict(count_test) # Calculate the accuracy of your predictions count_nb_score = metrics.accuracy_score(count_nb_pred, y_test) print(&#39;NaiveBayes Tfidf Score: &#39;, tfidf_nb_score) print(&#39;NaiveBayes Count Score: &#39;, count_nb_score) . NaiveBayes Tfidf Score: 0.803030303030303 NaiveBayes Count Score: 0.7954545454545454 . 5. Evaluating our model using a confusion matrix . We see that the TF-IDF model performs better than the count-based approach. Based on what we know from the NLP fundamentals course, why might that be? We know that TF-IDF allows unique tokens to have a greater weight - perhaps tweeters are using specific important words that identify them! Let&#39;s continue the investigation. . For classification tasks, an accuracy score doesn&#39;t tell the whole picture. A better evaluation can be made if we look at the confusion matrix, which shows the number correct and incorrect classifications based on each class. We can use the metrics, True Positives, False Positives, False Negatives, and True Negatives, to determine how well the model performed on a given class. How many times was Trump misclassified as Trudeau? . %matplotlib inline from datasets.helper_functions import plot_confusion_matrix # Calculate the confusion matrices for the tfidf_nb model and count_nb models tfidf_nb_cm = metrics.confusion_matrix(y_test, tfidf_nb_pred) count_nb_cm = metrics.confusion_matrix(y_test, count_nb_pred) # Plot the tfidf_nb_cm confusion matrix plot_confusion_matrix(tfidf_nb_cm, classes=[&#39;Donald J. Trump&#39;, &#39;Justin Trudeau&#39;], title=&quot;TF-IDF NB Confusion Matrix&quot;) # Plot the count_nb_cm confusion matrix without overwriting the first plot plot_confusion_matrix(count_nb_cm, classes=[&#39;Donald J. Trump&#39;, &#39;Justin Trudeau&#39;], title=&#39;Count NB Confusion Matrix&#39;, figure=1) . Confusion matrix, without normalization Confusion matrix, without normalization . 6. Trying out another classifier: Linear SVC . So the Bayesian model only has one prediction difference between the TF-IDF and count vectorizers -- fairly impressive! Interestingly, there is some confusion when the predicted label is Trump but the actual tweeter is Trudeau. If we were going to use this model, we would want to investigate what tokens are causing the confusion in order to improve the model. . Now that we&#39;ve seen what the Bayesian model can do, how about trying a different approach? LinearSVC is another popular choice for text classification. Let&#39;s see if using it with the TF-IDF vectors improves the accuracy of the classifier! . tfidf_svc = LinearSVC() # ... Train your model here ... tfidf_svc.fit(tfidf_train, y_train) # Run predict on your tfidf test data to get your predictions tfidf_svc_pred = tfidf_svc.predict(tfidf_test) # Calculate your accuracy using the metrics module tfidf_svc_score = metrics.accuracy_score(y_test, tfidf_svc_pred) print(&quot;LinearSVC Score: %0.3f&quot; % tfidf_svc_score) # Calculate the confusion matrices for the tfidf_svc model svc_cm = metrics.confusion_matrix(y_test, tfidf_svc_pred) # Plot the confusion matrix using the plot_confusion_matrix function plot_confusion_matrix(svc_cm, classes=[&#39;Donald J. Trump&#39;, &#39;Justin Trudeau&#39;], title=&quot;TF-IDF LinearSVC Confusion Matrix&quot;) . LinearSVC Score: 0.841 Confusion matrix, without normalization . 7. Introspecting our top model . Wow, the LinearSVC model is even better than the Multinomial Bayesian one. Nice work! Via the confusion matrix we can see that, although there is still some confusion where Trudeau&#39;s tweets are classified as Trump&#39;s, the False Positive rate is better than the previous model. So, we have a performant model, right? . We might be able to continue tweaking and improving all of the previous models by learning more about parameter optimization or applying some better preprocessing of the tweets. . Now let&#39;s see what the model has learned. Using the LinearSVC Classifier with two classes (Trump and Trudeau) we can sort the features (tokens), by their weight and see the most important tokens for both Trump and Trudeau. What are the most Trump-like or Trudeau-like words? Did the model learn something useful to distinguish between these two men? . from datasets.helper_functions import plot_and_return_top_features # Import pprint from pprint from pprint import pprint # Get the top features using the plot_and_return_top_features function and your top model and tfidf vectorizer top_features = plot_and_return_top_features(tfidf_svc, tfidf_vectorizer) # pprint the top features pprint(top_features) . [(-0.3959833401279692, &#39;great&#39;), (-0.2464547956603081, &#39;thank&#39;), (0.06257214986426195, &#39;president&#39;), (0.4821433892566958, &#39;https&#39;), (0.5960516251036668, &#39;vietnam&#39;), (0.6155435311174133, &#39;amp&#39;), (0.7725820577742512, &#39;le&#39;), (0.8213755080211748, &#39;les&#39;), (0.828645048415816, &#39;today&#39;), (1.186904175420195, &#39;du&#39;), (1.3143501017089494, &#39;pour&#39;), (1.4122570307203528, &#39;nous&#39;), (1.4612760758725967, &#39;rt&#39;), (1.4991787853910419, &#39;et&#39;), (1.505644948934579, &#39;la&#39;), (1.6567929436620206, &#39;canada&#39;)] . 8. Bonus: can you write a Trump or Trudeau tweet? . So, what did our model learn? It seems like it learned that Trudeau tweets in French! . I challenge you to write your own tweet using the knowledge gained to trick the model! Use the printed list or plot above to make some inferences about what words will classify your text as Trump or Trudeau. Can you fool the model into thinking you are Trump or Trudeau? . If you can write French, feel free to make your Trudeau-impersonation tweet in French! As you may have noticed, these French words are common words, or, &quot;stop words&quot;. You could remove both English and French stop words from the tweets as a preprocessing step, but that might decrease the accuracy of the model because Trudeau is the only French-speaker in the group. If you had a dataset with more than one French speaker, this would be a useful preprocessing step. . Future work on this dataset could involve: . Add extra preprocessing (such as removing URLs or French stop words) and see the effects | Use GridSearchCV to improve both your Bayesian and LinearSVC models by finding the optimal parameters | Introspect your Bayesian model to determine what words are more Trump- or Trudeau- like | Add more recent tweets to your dataset using tweepy and retrain | . Good luck writing your impersonation tweets -- feel free to share them on Twitter! . trump_tweet = &quot;I don&#39;t want any americans to die&quot; trudeau_tweet = &quot;Je ne peux pas croire que tu as déjà 12 ans. Bonne fête, Xav!&quot; # Vectorize each tweet using the TF-IDF vectorizer&#39;s transform method # Note: `transform` needs the string in a list object (i.e. [trump_tweet]) trump_tweet_vectorized = tfidf_vectorizer.transform([trump_tweet]) trudeau_tweet_vectorized = tfidf_vectorizer.transform([trudeau_tweet]) # Call the predict method on your vectorized tweets trump_tweet_pred = tfidf_svc.predict(trump_tweet_vectorized) trudeau_tweet_pred = tfidf_svc.predict(trudeau_tweet_vectorized) print(&quot;Predicted Trump tweet&quot;, trump_tweet_pred) print(&quot;Predicted Trudeau tweet&quot;, trudeau_tweet_pred) . Predicted Trump tweet [&#39;Donald J. Trump&#39;] Predicted Trudeau tweet [&#39;Donald J. Trump&#39;] .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/16/Whos-Tweeting-Trump-or-Trudeau.html",
            "relUrl": "/datacamp/projects/python/2021/03/16/Whos-Tweeting-Trump-or-Trudeau.html",
            "date": " • Mar 16, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "Reducing Traffic Mortality in the USA",
            "content": "1. The raw data files and their format . While the rate of fatal road accidents has been decreasing steadily since the 80s, the past ten years have seen a stagnation in this reduction. Coupled with the increase in number of miles driven in the nation, the total number of traffic related-fatalities has now reached a ten year high and is rapidly increasing. . Per request of the US Department of Transportation, we are currently investigating how to derive a strategy to reduce the incidence of road accidents across the nation. By looking at the demographics of traﬃc accident victims for each US state, we find that there is a lot of variation between states. Now we want to understand if there are patterns in this variation in order to derive suggestions for a policy action plan. In particular, instead of implementing a costly nation-wide plan we want to focus on groups of states with similar profiles. How can we find such groups in a statistically sound way and communicate the result effectively? . To accomplish these tasks, we will make use of data wrangling, plotting, dimensionality reduction, and unsupervised clustering. . The data given to us was originally collected by the National Highway Traffic Safety Administration and the National Association of Insurance Commissioners. This particular dataset was compiled and released as a CSV-file by FiveThirtyEight under the CC-BY4.0 license. . current_dir = !pwd print(current_dir) # List all files in this folder file_list = !ls print(file_list) # List all files in the datasets directory dataset_list = !ls datasets print(dataset_list) # View the first 20 lines of datasets/road-accidents.csv accidents_head = !head -20 datasets/road-accidents.csv accidents_head . [&#39;/home/repl&#39;] [&#39;datasets&#39;] [&#39;miles-driven.csv&#39;, &#39;road-accidents.csv&#39;] . [&#39;##### LICENSE #####&#39;, &#39;# This data set is modified from the original at fivethirtyeight (https://github.com/fivethirtyeight/data/tree/master/bad-drivers)&#39;, &#39;# and it is released under CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/)&#39;, &#39;##### COLUMN ABBREVIATIONS #####&#39;, &#39;# drvr_fatl_col_bmiles = Number of drivers involved in fatal collisions per billion miles (2011)&#39;, &#39;# perc_fatl_speed = Percentage Of Drivers Involved In Fatal Collisions Who Were Speeding (2009)&#39;, &#39;# perc_fatl_alcohol = Percentage Of Drivers Involved In Fatal Collisions Who Were Alcohol-Impaired (2011)&#39;, &#39;# perc_fatl_1st_time = Percentage Of Drivers Involved In Fatal Collisions Who Had Not Been Involved In Any Previous Accidents (2011)&#39;, &#39;##### DATA BEGIN #####&#39;, &#39;state|drvr_fatl_col_bmiles|perc_fatl_speed|perc_fatl_alcohol|perc_fatl_1st_time&#39;, &#39;Alabama|18.8|39|30|80&#39;, &#39;Alaska|18.1|41|25|94&#39;, &#39;Arizona|18.6|35|28|96&#39;, &#39;Arkansas|22.4|18|26|95&#39;, &#39;California|12|35|28|89&#39;, &#39;Colorado|13.6|37|28|95&#39;, &#39;Connecticut|10.8|46|36|82&#39;, &#39;Delaware|16.2|38|30|99&#39;, &#39;District of Columbia|5.9|34|27|100&#39;, &#39;Florida|17.9|21|29|94&#39;] . 2. Read in and get an overview of the data . Next, we will orient ourselves to get to know the data with which we are dealing. . # ... YOUR CODE FOR TASK 2 ... import pandas as pd # Read in `road-accidents.csv` car_acc = pd.read_csv(&#39;datasets/road-accidents.csv&#39;, comment=&#39;#&#39;, sep=&#39;|&#39;) # Save the number of rows columns as a tuple rows_and_cols = car_acc.shape print(&#39;There are {} rows and {} columns. n&#39;.format( rows_and_cols[0], rows_and_cols[1])) # Generate an overview of the DataFrame car_acc_information = car_acc.info() print(car_acc_information) # Display the last five rows of the DataFrame car_acc.tail() . There are 51 rows and 5 columns. &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 51 entries, 0 to 50 Data columns (total 5 columns): state 51 non-null object drvr_fatl_col_bmiles 51 non-null float64 perc_fatl_speed 51 non-null int64 perc_fatl_alcohol 51 non-null int64 perc_fatl_1st_time 51 non-null int64 dtypes: float64(1), int64(3), object(1) memory usage: 2.1+ KB None . state drvr_fatl_col_bmiles perc_fatl_speed perc_fatl_alcohol perc_fatl_1st_time . 46 Virginia | 12.7 | 19 | 27 | 88 | . 47 Washington | 10.6 | 42 | 33 | 86 | . 48 West Virginia | 23.8 | 34 | 28 | 87 | . 49 Wisconsin | 13.8 | 36 | 33 | 84 | . 50 Wyoming | 17.4 | 42 | 32 | 90 | . 3. Create a textual and a graphical summary of the data . We now have an idea of what the dataset looks like. To further familiarize ourselves with this data, we will calculate summary statistics and produce a graphical overview of the data. The graphical overview is good to get a sense for the distribution of variables within the data and could consist of one histogram per column. It is often a good idea to also explore the pairwise relationship between all columns in the data set by using a using pairwise scatter plots (sometimes referred to as a &quot;scatterplot matrix&quot;). . import seaborn as sns %matplotlib inline # Compute the summary statistics of all columns in the `car_acc` DataFrame sum_stat_car = car_acc.describe() print(sum_stat_car) # Create a pairwise scatter plot to explore the data # ... YOUR CODE FOR TASK 3 ... sns.pairplot(car_acc) . drvr_fatl_col_bmiles perc_fatl_speed perc_fatl_alcohol count 51.000000 51.000000 51.000000 mean 15.790196 31.725490 30.686275 std 4.122002 9.633438 5.132213 min 5.900000 13.000000 16.000000 25% 12.750000 23.000000 28.000000 50% 15.600000 34.000000 30.000000 75% 18.500000 38.000000 33.000000 max 23.900000 54.000000 44.000000 perc_fatl_1st_time count 51.00000 mean 88.72549 std 6.96011 min 76.00000 25% 83.50000 50% 88.00000 75% 95.00000 max 100.00000 . &lt;seaborn.axisgrid.PairGrid at 0x7fdb01c86978&gt; . 4. Quantify the association of features and accidents . We can already see some potentially interesting relationships between the target variable (the number of fatal accidents) and the feature variables (the remaining three columns). . To quantify the pairwise relationships that we observed in the scatter plots, we can compute the Pearson correlation coefficient matrix. The Pearson correlation coefficient is one of the most common methods to quantify correlation between variables, and by convention, the following thresholds are usually used: . 0.2 = weak | 0.5 = medium | 0.8 = strong | 0.9 = very strong | . corr_columns = car_acc.corr() corr_columns . drvr_fatl_col_bmiles perc_fatl_speed perc_fatl_alcohol perc_fatl_1st_time . drvr_fatl_col_bmiles 1.000000 | -0.029080 | 0.199426 | -0.017942 | . perc_fatl_speed -0.029080 | 1.000000 | 0.286244 | 0.014066 | . perc_fatl_alcohol 0.199426 | 0.286244 | 1.000000 | -0.245455 | . perc_fatl_1st_time -0.017942 | 0.014066 | -0.245455 | 1.000000 | . 5. Fit a multivariate linear regression . From the correlation table, we see that the amount of fatal accidents is most strongly correlated with alcohol consumption (first row). But in addition, we also see that some of the features are correlated with each other, for instance, speeding and alcohol consumption are positively correlated. We, therefore, want to compute the association of the target with each feature while adjusting for the effect of the remaining features. This can be done using multivariate linear regression. . Both the multivariate regression and the correlation measure how strongly the features are associated with the outcome (fatal accidents). When comparing the regression coefficients with the correlation coefficients, we will see that they are slightly different. The reason for this is that the multiple regression computes the association of a feature with an outcome, given the association with all other features, which is not accounted for when calculating the correlation coefficients. . A particularly interesting case is when the correlation coefficient and the regression coefficient of the same feature have opposite signs. How can this be? For example, when a feature A is positively correlated with the outcome Y but also positively correlated with a different feature B that has a negative effect on Y, then the indirect correlation (A-&gt;B-&gt;Y) can overwhelm the direct correlation (A-&gt;Y). In such a case, the regression coefficient of feature A could be positive, while the correlation coefficient is negative. This is sometimes called a masking relationship. Let’s see if the multivariate regression can reveal such a phenomenon. . from sklearn import linear_model # Create the features and target DataFrames features = car_acc.loc[:, [&#39;perc_fatl_speed&#39;, &#39;perc_fatl_alcohol&#39;, &#39;perc_fatl_1st_time&#39;]] target = car_acc[&#39;drvr_fatl_col_bmiles&#39;] # Create a linear regression object reg = linear_model.LinearRegression() # Fit a multivariate linear regression model # ... YOUR CODE FOR TASK 5 ... reg.fit(features, target) # Retrieve the regression coefficients fit_coef = reg.coef_ fit_coef . array([-0.04180041, 0.19086404, 0.02473301]) . 6. Perform PCA on standardized data . We have learned that alcohol consumption is weakly associated with the number of fatal accidents across states. This could lead us to conclude that alcohol consumption should be a focus for further investigations and maybe strategies should divide states into high versus low alcohol consumption in accidents. But there are also associations between alcohol consumptions and the other two features, so it might be worth trying to split the states in a way that accounts for all three features. . One way of clustering the data is to use PCA to visualize data in reduced dimensional space where we can try to pick up patterns by eye. PCA uses the absolute variance to calculate the overall variance explained for each principal component, so it is important that the features are on a similar scale (unless we would have a particular reason that one feature should be weighted more). . We&#39;ll use the appropriate scaling function to standardize the features to be centered with mean 0 and scaled with standard deviation 1. . from sklearn.preprocessing import StandardScaler scaler = StandardScaler() features_scaled = scaler.fit_transform(features) # Import the PCA class function from sklearn # ... YOUR CODE FOR TASK 6 ... from sklearn.decomposition import PCA pca = PCA() # Fit the standardized data to the pca # ... YOUR CODE FOR TASK 6 ... pca.fit(features_scaled) # Plot the proportion of variance explained on the y-axis of the bar plot import matplotlib.pyplot as plt plt.bar(range(1, pca.n_components_ + 1), pca.explained_variance_ratio_) plt.xlabel(&#39;Principal component #&#39;) plt.ylabel(&#39;Proportion of variance explained&#39;) plt.xticks([1, 2, 3]) # Compute the cumulative proportion of variance explained by the first two principal components two_first_comp_var_exp = pca.explained_variance_ratio_[0].cumsum()[0] + pca.explained_variance_ratio_[1].cumsum()[0] print(&quot;The cumulative variance of the first two principal components is {}&quot;.format( round(two_first_comp_var_exp, 5))) . The cumulative variance of the first two principal components is 0.7947 . 7. Visualize the first two principal components . The first two principal components enable visualization of the data in two dimensions while capturing a high proportion of the variation (79%) from all three features: speeding, alcohol influence, and first-time accidents. This enables us to use our eyes to try to discern patterns in the data with the goal to find groups of similar states. Although clustering algorithms are becoming increasingly efficient, human pattern recognition is an easily accessible and very efficient method of assessing patterns in data. . We will create a scatter plot of the first principle components and explore how the states cluster together in this visualization. . pca = PCA(n_components=2) p_comps = pca.fit_transform(features_scaled) # Extract the first and second component to use for the scatter plot p_comp1 = p_comps[:, 0] p_comp2 = p_comps[:, 1] # Plot the first two principal components in a scatter plot # ... YOUR CODE FOR TASK 7 ... plt.scatter(p_comp1, p_comp2) . &lt;matplotlib.collections.PathCollection at 0x7fdb01e9d2b0&gt; . 8. Find clusters of similar states in the data . It was not entirely clear from the PCA scatter plot how many groups in which the states cluster. To assist with identifying a reasonable number of clusters, we can use KMeans clustering by creating a scree plot and finding the &quot;elbow&quot;, which is an indication of when the addition of more clusters does not add much explanatory power. . # ... YOUR CODE FOR TASK 8 ... from sklearn.cluster import KMeans # A loop will be used to plot the explanatory power for up to 10 KMeans clusters ks = range(1, 10) inertias = [] for k in ks: # Initialize the KMeans object using the current number of clusters (k) km = KMeans(n_clusters=k, random_state=8) # Fit the scaled features to the KMeans object km.fit(features_scaled) # Append the inertia for `km` to the list of inertias inertias.append(km.inertia_) # Plot the results in a line plot plt.plot(ks, inertias, marker=&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x7fdb01afa0f0&gt;] . 9. KMeans to visualize clusters in the PCA scatter plot . Since there wasn&#39;t a clear elbow in the scree plot, assigning the states to either two or three clusters is a reasonable choice, and we will resume our analysis using three clusters. Let&#39;s see how the PCA scatter plot looks if we color the states according to the cluster to which they are assigned. . km = KMeans(n_clusters=3, random_state=8) # Fit the data to the `km` object # ... YOUR CODE FOR TASK 9 ... km.fit(features_scaled) # Create a scatter plot of the first two principal components # and color it according to the KMeans cluster assignment # ... YOUR CODE FOR TASK 9 ... colors = {0: &#39;red&#39;, 1: &#39;blue&#39;, 2: &#39;green&#39;} plt.scatter(p_comp1, p_comp2, color=[colors[c] for c in km.labels_]) . &lt;matplotlib.collections.PathCollection at 0x7fdb01cd66a0&gt; . 10. Visualize the feature differences between the clusters . Thus far, we have used both our visual interpretation of the data and the KMeans clustering algorithm to reveal patterns in the data, but what do these patterns mean? . Remember that the information we have used to cluster the states into three distinct groups are the percentage of drivers speeding, under alcohol influence and that has not previously been involved in an accident. We used these clusters to visualize how the states group together when considering the first two principal components. This is good for us to understand structure in the data, but not always easy to understand, especially not if the findings are to be communicated to a non-specialist audience. . A reasonable next step in our analysis is to explore how the three clusters are different in terms of the three features that we used for clustering. Instead of using the scaled features, we return to using the unscaled features to help us interpret the differences. . car_acc[&#39;cluster&#39;] = km.labels_ # Reshape the DataFrame to the long format melt_car = pd.melt(car_acc, id_vars=[&#39;cluster&#39;], value_name=&#39;percent&#39;, var_name=&#39;measurement&#39;, value_vars=[&#39;perc_fatl_speed&#39;, &#39;perc_fatl_alcohol&#39;,&#39;perc_fatl_1st_time&#39;]) # Create a violin plot splitting and coloring the results according to the km-clusters sns.violinplot(x=&#39;percent&#39;, y=&#39;measurement&#39;, hue=&#39;cluster&#39;, data=melt_car) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fdb01c33080&gt; . 11. Compute the number of accidents within each cluster . Now it is clear that different groups of states may require different interventions. Since resources and time are limited, it is useful to start off with an intervention in one of the three groups first. Which group would this be? To determine this, we will include data on how many miles are driven in each state, because this will help us to compute the total number of fatal accidents in each state. Data on miles driven is available in another tab-delimited text file. We will assign this new information to a column in the DataFrame and create a violin plot for how many total fatal traffic accidents there are within each state cluster. . miles_driven = pd.read_csv(&#39;datasets/miles-driven.csv&#39;, sep=&#39;|&#39;) # Merge the `car_acc` DataFrame with the `miles_driven` DataFrame car_acc_miles = car_acc.merge(miles_driven, on=&#39;state&#39;) # Create a new column for the number of drivers involved in fatal accidents car_acc_miles[&#39;num_drvr_fatl_col&#39;] = car_acc_miles[&#39;drvr_fatl_col_bmiles&#39;] * car_acc_miles[&#39;million_miles_annually&#39;] * 1000 # Create a barplot of the total number of accidents per cluster sns.barplot(x=&#39;cluster&#39;, y=&#39;num_drvr_fatl_col&#39;, data=car_acc_miles, estimator=sum, ci=None) # Calculate the number of states in each cluster and their &#39;num_drvr_fatl_col&#39; mean and sum. count_mean_sum = car_acc_miles.agg([len, &#39;mean&#39;, sum]) count_mean_sum . drvr_fatl_col_bmiles perc_fatl_speed perc_fatl_alcohol perc_fatl_1st_time cluster million_miles_annually num_drvr_fatl_col . len 51.000000 | 51.00000 | 51.000000 | 51.00000 | 51.000000 | 5.100000e+01 | 5.100000e+01 | . mean 15.790196 | 31.72549 | 30.686275 | 88.72549 | 1.078431 | 5.785102e+04 | 8.948080e+08 | . sum 805.300000 | 1618.00000 | 1565.000000 | 4525.00000 | 55.000000 | 2.950402e+06 | 4.563521e+10 | . 12. Make a decision when there is no clear right choice . As we can see, there is no obvious correct choice regarding which cluster is the most important to focus on. Yet, we can still argue for a certain cluster and motivate this using our findings above. Which cluster do you think should be a focus for policy intervention and further investigation? . cluster_num = 1 .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/16/Reducing-Traffic-Mortality-in-the-USA.html",
            "relUrl": "/datacamp/projects/python/2021/03/16/Reducing-Traffic-Mortality-in-the-USA.html",
            "date": " • Mar 16, 2021"
        }
        
    
  
    
        ,"post19": {
            "title": "Recreating John Snow's Ghost Map",
            "content": "1. Dr. John Snow . Dr. John Snow (1813-1858) was a famous British physician and is widely recognized as a legendary figure in the history of public health and a leading pioneer in the development of anesthesia. Some even say one of the greatest physicians of all time. . As a leading advocate of both anesthesia and hygienic practices in medicine, he not only experimented with ether and chloroform but also designed a mask and method how to administer it. He personally administered chloroform to Queen Victoria during the births of her eighth and ninth children, in 1853 and 1857, which assured a growing public acceptance of the use of anesthetics during childbirth. . But, as we will show later, not all his life was just a success. John Snow is now also recognized as one of the founders of modern epidemiology (some also consider him as the founder of data visualization, spatial analysis, data science in general, and many other related fields) for his scientific and pretty modern data approach in identifying the source of a cholera outbreak in Soho, London in 1854, but it wasn&#39;t always like this. In fact, for a long time, he was simply ignored by the scientific community and currently is very often mythified. . In this notebook, we&#39;re not only going to rediscover his &quot;data story&quot;, but reanalyze the data that he collected in 1854 and recreate his famous map (also called The Ghost Map). . # ... YOUR CODE FOR TASK 1 ... import pandas as pd # Reading in the data deaths = pd.read_csv(&#39;datasets/deaths.csv&#39;) # Print out the shape of the dataset # ... YOUR CODE FOR TASK 1 ... print(deaths.shape) # Printing out the first 5 rows # ... YOUR CODE FOR TASK 1 ... deaths.head() . (489, 3) . Death X coordinate Y coordinate . 0 1 | 51.513418 | -0.137930 | . 1 1 | 51.513418 | -0.137930 | . 2 1 | 51.513418 | -0.137930 | . 3 1 | 51.513361 | -0.137883 | . 4 1 | 51.513361 | -0.137883 | . 2. Cholera attacks! . Prior to John Snow&#39;s discovery cholera was a regular visitor to London’s overcrowded and unsanitary streets. During the time of the third cholera outbreak, it was one of the most studied subjects (between years 1839-1856 over 700 studies and essays were published in London alone) and nearly all of the authors believed the outbreaks were due to miasma or &quot;bad air&quot;. . It was John Snow&#39;s pioneering work with anesthesia and gases that made him doubt the miasma model of the disease. Originally he formulated and published his theory that cholera is spread by water or food in an essay On the Mode of Communication of Cholera (before the outbreak in 1849). The essay received negative reviews in the Lancet and the London Medical Gazette. . We know now that he was right, but Dr. Snow&#39;s dilemma was how to prove it? His first step to getting there was checking the data. Our dataset has 489 rows of data in 3 columns but to work with dataset more easily we will first make few changes. . # ... YOUR CODE FOR TASK 2 ... deaths.info() # Define the new names of your columns newcols = { &#39;Death&#39;: &#39;death_count&#39;, &#39;X coordinate&#39;: &#39;x_latitude&#39;, &#39;Y coordinate&#39;: &#39;y_longitude&#39; } # Rename your columns # ... YOUR CODE FOR TASK 2 ... deaths.rename(newcols) # Describe the dataset # ... YOUR CODE FOR TASK 2 ... deaths.describe() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 489 entries, 0 to 488 Data columns (total 3 columns): Death 489 non-null int64 X coordinate 489 non-null float64 Y coordinate 489 non-null float64 dtypes: float64(2), int64(1) memory usage: 11.5 KB . Death X coordinate Y coordinate . count 489.0 | 489.000000 | 489.000000 | . mean 1.0 | 51.513398 | -0.136403 | . std 0.0 | 0.000705 | 0.001503 | . min 1.0 | 51.511856 | -0.140074 | . 25% 1.0 | 51.512964 | -0.137562 | . 50% 1.0 | 51.513359 | -0.136226 | . 75% 1.0 | 51.513875 | -0.135344 | . max 1.0 | 51.515834 | -0.132933 | . 3. You know nothing, John Snow! . It was somehow unthinkable that one man could debunk the miasma theory and prove that all the others got it wrong, so his work was mostly ignored. His medical colleagues simply said: &quot;You know nothing, John Snow!&quot; . As already mentioned John Snow&#39;s first attempt to debunk the &quot;miasma&quot; theory ended with negative reviews. However, a reviewer made a helpful suggestion in terms of what evidence would be compelling: the crucial natural experiment would be to find people living side by side with lifestyles similar in all respects except for the water source. The cholera outbreak in Soho, London in 1854 gave Snow the opportunity not only to save lives this time but also to further test and improve his theory. But what about the final proof that he was right? . We now know how John Snow did it, so let&#39;s get the data right first. . locations = deaths[[&#39;x_latitude&#39;, &#39;y_longitude&#39;]] # Create `deaths_list` by transforming the DataFrame to list of lists deaths_list = locations.values.tolist() # Check the length of the list # ... YOUR CODE FOR TASK 3 ... print(len(deaths_list)) . 489 . 4. The Ghost Map . . His original map, unfortunately, is not available (it might never even existed). We can see the famous one that he drew about a year later in 1855, though, and it is displayed in this cell. Because the map depicts and visualizes the deaths sometimes it is called also The Ghost Map. . We now know how John Snow did it and have the data too, so let&#39;s recreate his map using modern techniques. . import folium map = folium.Map(location=[51.5132119,-0.13666], tiles=&#39;Stamen Toner&#39;, zoom_start=17) for point in range(0, len(deaths)): folium.CircleMarker(deaths_list[point], radius=8, color=&#39;red&#39;, fill=True, fill_color=&#39;red&#39;, opacity = 0.4).add_to(map) map . Make this Notebook Trusted to load map: File -&gt; Trust Notebook&lt;iframe src=&quot;about:blank&quot; style=&quot;position:absolute;width:100%;height:100%;left:0;top:0;border:none !important;&quot; data-html=PCFET0NUWVBFIGh0bWw+CjxoZWFkPiAgICAKICAgIDxtZXRhIGh0dHAtZXF1aXY9ImNvbnRlbnQtdHlwZSIgY29udGVudD0idGV4dC9odG1sOyBjaGFyc2V0PVVURi04IiAvPgogICAgPHNjcmlwdD5MX1BSRUZFUl9DQU5WQVMgPSBmYWxzZTsgTF9OT19UT1VDSCA9IGZhbHNlOyBMX0RJU0FCTEVfM0QgPSBmYWxzZTs8L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2FqYXguZ29vZ2xlYXBpcy5jb20vYWpheC9saWJzL2pxdWVyeS8xLjExLjEvanF1ZXJ5Lm1pbi5qcyI+PC9zY3JpcHQ+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvanMvYm9vdHN0cmFwLm1pbi5qcyI+PC9zY3JpcHQ+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvTGVhZmxldC5hd2Vzb21lLW1hcmtlcnMvMi4wLjIvbGVhZmxldC5hd2Vzb21lLW1hcmtlcnMuanMiPjwvc2NyaXB0PgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9jc3MvYm9vdHN0cmFwLm1pbi5jc3MiLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzIi8+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLzQuNi4zL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9MZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy8yLjAuMi9sZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy5jc3MiLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9yYXdnaXQuY29tL3B5dGhvbi12aXN1YWxpemF0aW9uL2ZvbGl1bS9tYXN0ZXIvZm9saXVtL3RlbXBsYXRlcy9sZWFmbGV0LmF3ZXNvbWUucm90YXRlLmNzcyIvPgogICAgPHN0eWxlPmh0bWwsIGJvZHkge3dpZHRoOiAxMDAlO2hlaWdodDogMTAwJTttYXJnaW46IDA7cGFkZGluZzogMDt9PC9zdHlsZT4KICAgIDxzdHlsZT4jbWFwIHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtib3R0b206MDtyaWdodDowO2xlZnQ6MDt9PC9zdHlsZT4KICAgIAogICAgICAgICAgICA8c3R5bGU+ICNtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYgewogICAgICAgICAgICAgICAgcG9zaXRpb24gOiByZWxhdGl2ZTsKICAgICAgICAgICAgICAgIHdpZHRoIDogMTAwLjAlOwogICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAuMCU7CiAgICAgICAgICAgICAgICBsZWZ0OiAwLjAlOwogICAgICAgICAgICAgICAgdG9wOiAwLjAlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICA8L3N0eWxlPgogICAgICAgIAo8L2hlYWQ+Cjxib2R5PiAgICAKICAgIAogICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb2xpdW0tbWFwIiBpZD0ibWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2IiA+PC9kaXY+CiAgICAgICAgCjwvYm9keT4KPHNjcmlwdD4gICAgCiAgICAKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IG51bGw7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5NiA9IEwubWFwKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5NicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2VudGVyOiBbNTEuNTEzMjExOSwtMC4xMzY2Nl0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tOiAxNywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEJvdW5kczogYm91bmRzLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzOiBbXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkQ29weUp1bXA6IGZhbHNlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JzOiBMLkNSUy5FUFNHMzg1NwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHRpbGVfbGF5ZXJfNWEwZmE4MjlkNjc0NDAwNjk4NTVhMGIzMTAzYWFkOTIgPSBMLnRpbGVMYXllcigKICAgICAgICAgICAgICAgICdodHRwczovL3N0YW1lbi10aWxlcy17c30uYS5zc2wuZmFzdGx5Lm5ldC90b25lci97en0ve3h9L3t5fS5wbmcnLAogICAgICAgICAgICAgICAgewogICJhdHRyaWJ1dGlvbiI6IG51bGwsCiAgImRldGVjdFJldGluYSI6IGZhbHNlLAogICJtYXhab29tIjogMTgsCiAgIm1pblpvb20iOiAxLAogICJub1dyYXAiOiBmYWxzZSwKICAic3ViZG9tYWlucyI6ICJhYmMiCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NzYyOWY4Nzc1YTM0MWRkYWNjYjAzMTM1MGU0Nzk5MiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQxOCwtMC4xMzc5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iN2Q0NWI2ZWJmZGM0MDgxODMyMTVmYTc1ZDljOWYzNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQxOCwtMC4xMzc5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xMTNhMjc1ODc0NjQ0ZmQ2YmJhMzMxNzBjOGY4ODI1ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQxOCwtMC4xMzc5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83YTg1Y2YxNDlmNGQ0M2YxODNjYTM4M2EzMDQ0NzUyYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzM2MDk5OTk5OTk5NiwtMC4xMzc4ODNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjI0MzFmYzlhY2NhNDgxMmFjMmEzY2U4N2ZjNjUwNWQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzNjA5OTk5OTk5OTYsLTAuMTM3ODgzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2E1NjVmZDM3MGUwNDQwY2JhNjFiNTQ1ZmM5OGUyNTJiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMzE3LC0wLjEzNzg1M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNzY1YjNjODQ4ZDk0NTI4YTQxZDZkOWQ5NmQ3YjYzZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzI2MiwtMC4xMzc4MTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMWU3ZTZhMmMzODM3NDNhM2EwODBjY2I0MWNlN2NjMmQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMDM5OTk5OTk5OTUsLTAuMTM3NzY3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzBlM2ZhNWFhMDY0ZTRiYTY5NWQ3ZjU3YTE2ZTAwMjQ2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjAzOTk5OTk5OTk1LC0wLjEzNzc2N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NjQwZmFmNWZhNGQ0ZTlhODI3YzRjNzUyYTI5OGM3YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzIwMzk5OTk5OTk5NSwtMC4xMzc3NjddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzM3MjUwMWE0ZjFlNGJmYTg4YjNhNTNkY2NjNjE2OGUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMDM5OTk5OTk5OTUsLTAuMTM3NzY3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2UwNmU4ZmU4NTA2ZDQzMWM4MWUyYTdhMGM2ZWQzZTI3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTg0LC0wLjEzNzUzN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mNjhkMGE3ZTIyNmY0YzNlYTEyN2Y2ZGE2OWVhZTk4NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE4NCwtMC4xMzc1MzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDQ4ZWE3ZjhjMWI2NGI5ZDllZTk4N2I4NmJiMjJhOTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzNTksLTAuMTM4Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80MzhhZGVlNGY0NjE0NjFhOWY5Y2RkN2ExZGQ5YzQ1OSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzM1OSwtMC4xMzgyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzE2YjY4MWIzZTFhZjRiMWE5NTFkYjBjYzdiMjgzYzhhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMzI4LC0wLjEzODA0NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yMTI4ZjJhNTQwY2I0NDU5OTIyNWJjODc1Yjg3MzI5ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzMyOCwtMC4xMzgwNDVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzI5OTc5ZGNhYjVlNGU2NmJkMWI4MTMwODdkNDY0ZDYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzMjMsLTAuMTM4Mjc2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2I5Zjc4ZjNlOTI2MzRjNjc4NjJkOTYyZmE2ZDc0MTgzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMzIzLC0wLjEzODI3Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kYzFlNGE5ODMzYmY0NTBjYjkxYjU2MzI4ZGQyZDJjNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzMyMywtMC4xMzgyNzZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWIyOTNmMmY1NmYxNDAyMjhiYjNhYzI3MzQyNDkyZTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MjcsLTAuMTM4MjIzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2YwZjc5ZGNhMzcwMzRlZjA4YWU1NzczNDIyYjM4NWE0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDI3LC0wLjEzODIyM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82Yzg2MjUxMmU1Zjc0ODhmOGEwMWY4ZDBjYzZiZmMwZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzM4MSwtMC4xMzgzMzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYzAwZWNkNjJiMTIzNDE5MWEyZmY1MjRlZjBmNTczN2YgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzODEsLTAuMTM4MzM3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzllYmZmZDllZmU0ZDRkMzViOTI2YWM3MGJiNmJiN2Y4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDYyLC0wLjEzODU2MzAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzIwMGY4M2I4NWFhNDQzYTRhODQzNDMwMTUxY2RlNjA4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjE2LC0wLjEzODQyNl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xMTI3ZGY5ZGQxNTQ0MmY3OGE3MGM1NGRiNDEzMjZiNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzIxNiwtMC4xMzg0MjZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNTk2MjNiMjdiMWQ1NGQxMGJlMmJjNTI1ZTRhYjk5ZmIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMTYsLTAuMTM4NDI2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzEwYTU1ODU2MDI1NDQwOTJiNjEwNGYwNjI0YmJlNmIxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTY5LC0wLjEzODM3OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82ODUwODc3NzVkYTc0NWNjYWY5YjA3NzYwM2IyMDk2MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzExNiwtMC4xMzgzMzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDZhYWRkNjFhNmZmNGI4N2IzMzFmYmI4YTA1MDU4MjEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMxMTYsLTAuMTM4MzM3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzEyYzU3ZDc1YTEwMjRmZDA5OGFkMzhkNTI1NThiNzIxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTE2LC0wLjEzODMzN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NTk4Y2JiMTk0MTI0Y2Y5YjA5MmMzNWRmYzAxNmY4NCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzExNiwtMC4xMzgzMzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNjEzNjY2Y2FlZjFkNDBiNWI2NjI0ZTcwYjg1OTdlMzQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNCwtMC4xMzg2NDUwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81ZjM4YzI4YWEzNGE0YzZjYjc1YzJlNmMyYzNmMGZkMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2NCwtMC4xMzg2OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWJkZjM5ZmE1NGVjNGM5Zjg5ODZkMGU0YzA3NjE1MTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMxNzgsLTAuMTM3OTI0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzdmODVmM2IyN2VlNjQ4NTg4MmQyYzU4ZWMwMzM4ZDFjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTExLC0wLjEzNzg2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY4NmQ1ZjU4YzUzNDRkYjhhYTUzNWEwNmQyYjUwMzAxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTExLC0wLjEzNzg2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2MzNmY3NGIzZTk0MDQ2YmNiYzAxY2Y1MjI0ZmFlMzIzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTExLC0wLjEzNzg2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY0MWExMzg3MjhlODQyZDRiMDQ5NjNmN2M5NWZhMWRmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTExLC0wLjEzNzg2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzVjOGU5OGU3MGEwZDQ1ZTU5NzljM2FiOWU0ZjE4YTQ3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDU1LC0wLjEzNzgxMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNGYzN2NjMWZhYzE0ZTA0YWRhMWNkNDNiZGI0YTFkZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA1NSwtMC4xMzc4MTFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMmYwOWFmOTBiYTNhNDlhYjg5ODAxZmM2MTRkYWFiYzQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwNTUsLTAuMTM3ODExXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2UzMGRkOTcwZWUzNTQ4NmI5NjkwOWY5YTRjOTM3ZDE5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDQxLC0wLjEzODc2Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wMjc2Y2QyNjkxMjE0YzU5YjY0Yjk3MTAzOGJmMDAyZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQ0MSwtMC4xMzg3NjJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDNkMjk0NTIwNjIxNDA2ZThkMjM0MjdjZTA1NTNhYzEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM1OTE5OTk5OTk5OTYsLTAuMTM4Nzk5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzdkNDU0OTVhMTI3YTQzZTY5M2Y5ODhhODg3ZmY4NjExID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDAyLC0wLjEzOTA0NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lZDVkYzQ3YWMxNDI0Mzk1ODRmY2Y1NjliNzU2ODdmNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQwMiwtMC4xMzkwNDVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDhiYjI2ODFkMzZkNDMzMTg2YmZlMjZjNzE5ODQ4MWIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzOCwtMC4xMzg5N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NDE4ODkxMjlkMjk0YjVkYWQ1MTMxZGYwZjJiYTZjYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzM4LC0wLjEzODk3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2EzMmQzYmQ1MDNkZDRhYTFhMWMwZTc2MTMyYjY3NWYwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDExLC0wLjEzODg2MzAwMDAwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzgwMzI2OTQ5NTE3NzQzMWQ5ZjBjMjgwMzRhN2NhYWE2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDExLC0wLjEzODg2MzAwMDAwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzU1MWU2NjQ3ZTc0YjRkN2JhZmZkZmM0MDllMmE5Y2UzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjQxLC0wLjEzODc1Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83ZTUyMjVjODExYWI0Y2IwODY3NTliYmE1NTk5ZGJjYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzY5Mjk5OTk5OTk5NiwtMC4xMzg4MDhdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDZhNDRlYzAwMjM3NDQxM2EyNzU2MDQxOGJjY2FlMmEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3NDUsLTAuMTM4ODU2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzJhZjVjNGYxNDYxMDRjYTRiZmIxODQ2YTQzZDE1NDAyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzQ1LC0wLjEzODg1Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iN2IyYTk0YmU0YjU0YzE2YTNlMTI2ZmJjMTNmNDEwMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzc0NSwtMC4xMzg4NTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNjI5NzY0OGJmMDhmNGM3YjljZDUwY2Y2ZWNjZWNhYTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2NzYwMDAwMDAwMDQsLTAuMTM4ODg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDEwZWZiNjU2N2MzNGM3YWEyMDM5NjIxNDgyNjdlMmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM1OSwtMC4xMzkyMzldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmFlMTMxNTA1YTZkNDBmMGE2YTQ5NjQxMGE0N2QwMzggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2NjMsLTAuMTM5MzIxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzI5MzFjNDk5ZTEwODQ5ZmZhODRiNDdhZTNjM2RlMWI1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNTAyLC0wLjEzOTMxNl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81NzVmOTIxMzkwZWI0N2Q1YjUwM2Q3MGFlYjVhMjgwNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU4MzAwMDAwMDAwNCwtMC4xMzk2MTYwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iZGMxOTBiMGViMzg0M2RlODQwZDJmYmQ4YTE0MjQ3ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU4MzAwMDAwMDAwNCwtMC4xMzk2MTYwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84MDRkNDQ1ZjBjMjk0OTNmYTAxMjgzNmNiZWNmNjgyMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU0MSwtMC4xMzk3MTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjgyMTBiYWE4NGQ2NGU2M2I2M2E3ZDM1Zjg3YzgzMjcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM1NDEsLTAuMTM5NzE5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY1YjE2ZDM3ZjdiZTQyOTViZDM5ZTU5ZjA5MDgxMTkzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjk4LC0wLjE0MDA3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83YmEwMjIxZTc3MTE0NTY2YjVmZGJkZDkzNmVmZThjOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzI5MDk5OTk5OTk5NSwtMC4xMzkwOTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYmEzYTExNDQ5NTMwNGE1NWJiZTU4MDQyZjY4ZDI5ODUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwMTMsLTAuMTM5Njk3MDAwMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzcyN2U0YWRjYmZlNDZiYWEyNGI5Mjg3YmViMzY2M2EgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjUsLTAuMTM5MzI3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzVlYzQyNDJjZGFmYTRkZGViNzgyNDI2MmJiZWUzMmI0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyODkzLC0wLjEzOTMxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kMzk4OGFlMzEwYTM0NjljOThmNTU1NGUxYTUzYThmYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjg5MywtMC4xMzkzMTddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTdjZTY2NDliN2E1NGQxZGI0OGJiMzkwOWQyYzEzZjAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYmE0ODc0ZmFkOTJmNDEyZWE5NWNmZWMwYzJkMDViZDYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDMwYjRjOWU4MjgwNDE5Y2I4ZDk4ZmRjY2E4MzZkYTYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWMyNDZkMGNmNTEwNDcwOWI5NmRiZjM3YWZjN2JmZjYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTQ3ZDA5MmI0NTlhNDNiYzkyMzYyOTk2Mzc1ZjgyZjQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTUzZTM0YzhkMWY4NDc0YTlmNjQ5MTliNGYzMjQ1NDIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzJhOGMzMWY4ZTM3NGZlNjgzM2E2N2QyZDIyNGRkMzIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDkwNDQ0YjIyOTIzNGFmYjgzNDE5ZTFhZDdkZTFlMTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmIwN2FjYTFhY2NjNDQ4NWIxOGRiMzY0Mzc2YzFhNGYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwMjUsLTAuMTM5MDM2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzUxMDVmNDNkNzY1ZDRlZjg5MWUyYzFhNWMyNmYzYTFhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDI1LC0wLjEzOTAzNl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mNzYzZGQ5YjRlNjU0NzFkYTUwMDk1ODBmMjA2MzAwYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzAyNywtMC4xMzkyMDldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjUzZGRjZmQ3M2YwNGQ1ZTkyZjA2M2JmZDgxMDhjMjAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4MzEsLTAuMTM4NDI3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2QwMjk1YmJhNGJkMDRiNTM4Mzk1OTZjY2Q5NTBmYzExID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyODg1LC0wLjEzODYyNF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mZjNiOTI0YmU4MzU0MmFiOTc5YjM5NzdhZWIxMmY2MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUyNiwtMC4xMzgwOTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMGE3NWMzYzZiYjAyNDg2NDhlY2IyMDVkZjY1MzE3NzggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI0NjUsLTAuMTM4MDM1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2I5ZjczZjEzNWFlMzQ3OTRiNGJhNTE2ZTA5MGIyYzc0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDI4LC0wLjEzNzk4NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mZGY0NjZkZTVlOWM0MzM5YTcxNzIyOTU0MjkxNDdhOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjQyOCwtMC4xMzc5ODRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjE5ZDJhMWY1NzYzNDQyM2FjNDMzN2EyMDM2YTlkYTUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI0MjgsLTAuMTM3OTg0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg2OTJjMzY2YTIxOTRjNWM5MWFhNTdiMjg1Y2Y2NTk2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDI4LC0wLjEzNzk4NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82OTRlYmRmNDU2NmI0MDA0YWI3MTU3NzdiMjQyNzg5NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjQxNTAwMDAwMDAwNCwtMC4xMzgwNjUwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iNDMwMmU1YTdkMjY0YjVmYmQ0MDJlMWQ4NmIxN2Q0ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUxLC0wLjEzODE5NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mNTYyMzdlNzMxMzI0MmVhYmFiNTBkOWJmMmI3Mjk2ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjM3ODAwMDAwMDAwNSwtMC4xMzc4MThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjhhNDk5MmM3YTY4NDdjZWE1OWM1YzM1YmJmZjViMWMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI0NDY5OTk5OTk5OTUsLTAuMTM3NjU2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzMzYWMyYTJhYTYzMjQ2MjM4YmFlNDBhNjIyZjllNWYzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDkxLC0wLjEzNzU4Mzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2ZjYWU3ODQyZDRkNzQxNjBhYmU2MzZkNjU0ODE3YjJjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDkxLC0wLjEzNzU4Mzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzYzZmI1YzExZDE5ZTQwZWY5OTU0YzJmMDNjOTk0M2UzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDkxLC0wLjEzNzU4Mzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzJiNTg4NDA4Nzc3ZjQ5OTM5YjI5MjYzODFiOGM0ODQyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDkxLC0wLjEzNzU4Mzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2FhNzkxY2FlMmQ5MDQwM2ZiNDU2OTQyYTM5ZjllODA1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMzc0LC0wLjEzNzY1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzM5YjY1NDNlMTcwZjRiOWZhZDRkZmE1ZjBhYzMwOTkwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMzM5MDAwMDAwMDA0LC0wLjEzNzQ1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzJlOTgxOTQ4MzU1ODQ4MjdiN2NmNmMxMTM4YjQxMTVkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMzY0LC0wLjEzNzM3Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xMWU2MTZhNGE5Mjg0MTAzYTJlMjRlMWYzNjNiOGM5MiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjMxOSwtMC4xMzczMjddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjRkZDY4MWQxNzUyNDYwYTllNTdmMDRlYzc5ZmE3NDYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI1NCwtMC4xMzY5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hNTcwY2ZhNjg0Zjk0NTk1YjkzNjgyOGE5ZDg3Yzc5MSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY0ODk5OTk5OTk5NiwtMC4xMzcxOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zOWZmN2Y2YTU2NDk0YzQ5YjhhYzU0MGZiNWRhMmEwMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY0ODk5OTk5OTk5NiwtMC4xMzcxOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85ZjNkNjY5ZjM0ZDA0YzRhOWNjMjllMDhiMjhjYjIxOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY5MiwtMC4xMzcwNTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjdiMDIyZDdiOGUzNDNiNWJmZjE0NDc1OWZiM2I1ZjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NTcsLTAuMTM3Njk1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2QwZDU2NmNiZDc4MDQyY2RiZTI3YjcyZWI0YjYxZTk1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzY1LC0wLjEzNzUzM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hYTBkYTM4YjBiOTA0MDcwYjkwNzA4OWIxMjczMjRiMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjc4LC0wLjEzNzQxOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jYWM3ZWY0MWI2YWY0NmViOTQwNzdiNmY5ZTFkZjlkZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjc4LC0wLjEzNzQxOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85YmYwNzhhY2EwNjI0ZDU5ODk4ZDc1N2Q3ZDNlODEwOSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjcyNiwtMC4xMzczNjgwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mNzA2YTgwZTU2NTA0YzA2YjVkYjhiYzQ1OTE5MThkNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY4MSwtMC4xMzczMjVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjJhYWVhYjRkNTcwNDc2OTg5NzE3NDRjNzE4MDk5NzEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5MTQsLTAuMTM3NTMxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q0M2IyNjBmYjY1ZTQ5ODU4NjhkYzEwOWMyY2ExZjVlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyOTE0LC0wLjEzNzUzMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNzU3N2VjOGFmMTE0ZTNjOTU5MDBmNjk1YTUwNzdjMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA0NiwtMC4xMzc1NjJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjQwYWY1N2EwOGZhNDc4MTg0YzNmNzdmYTUyMmYyNjUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwNDYsLTAuMTM3NTYyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2NjMmJjNGZjMzU1YjRmMGQ4YjJlOTVmZGNhNzQyZmI4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDczOTk5OTk5OTk2LC0wLjEzNzQ2Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zZTMwYWZjN2UzZDY0ZjYyOWM1YTU3OGY5MmIzNWYzMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA4NywtMC4xMzczODU5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jYTQzMTZjZjQ5OTM0MWUxOGRiZTkzMTk1NGJhOTM0NCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA4NywtMC4xMzczODU5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iNTA5NjA0MGQ4MzA0NTgzOTMyMDI3ZjAzZmVmOGQ5MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEyMTk5OTk5OTk5NiwtMC4xMzczMDU5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lYjlkYTNiZTJlOTI0NTcyYWQ4MmI5NjgxNjM0YmM3ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEyMTk5OTk5OTk5NiwtMC4xMzczMDU5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zYWQ2MDg0Yzk3ZDc0NGVmYmY3NjI2ZWRmYjI3MDQ5YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEyMTk5OTk5OTk5NiwtMC4xMzczMDU5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82MGNiYTc0Y2E0ZGU0OWY1YTBlOGRiOGNiYTlhZDVjZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE4NywtMC4xMzcwODkwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mM2ZiZTZmZDI0YjU0MDMyOWY5MWQyZDBiOTRhZWJjYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzIxNDAwMDAwMDAwNSwtMC4xMzY5OTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTc2NWFhMzRhNTkxNDU5MGExYTkyMDEyMjNiNDkwNjQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMTQwMDAwMDAwMDUsLTAuMTM2OTk2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2RlYWYzYmE2N2JkMjQ2NTM5ZDc5OWFmY2VmMjc2NDM1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjE0MDAwMDAwMDA1LC0wLjEzNjk5Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83ZTUzNGEzMmFkMWI0YjA2YmM4YjdlMjBkODAwZjAzYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzIxNDAwMDAwMDAwNSwtMC4xMzY5OTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzA0YjQwMTJlNDdjNGU4OTkzZWM3NGRiOTNlZmNkMzEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzBhZWNkYjliZmNmNDc1YWJiNmRiNTU2ZTE4MmU0M2QgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYmQ0MDMyMmQ2NGQyNDExZTk3YzU5Nzg1YTM5NmQwY2MgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTk0ZGNkNTk3N2JjNDQ0MWJjMTIxY2ZjMGE3MTQzNTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWFjZDRkN2Y4OTUyNGRjNGE2MzFjOTNjMDlmMGMzODUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjY4ZGIzM2RiNjY5NDQ2NjllYjM3YzVjYjA1N2NhNjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjRmYmE2MzU2NDQxNGEyMzhlZjI5YzFlNGVhNjM0YjkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYzcwNjM5OGY2MjhiNDg4MWIxNTAyZDg1NGIxYmFlOGEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTY0OTFmZTVmN2JiNGRlMzk4ODNkZTAyOGU1ZDg4MTQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjA5MzJhY2QyN2RmNDI3MmExOWM1N2JlNzNkNmRiMTIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMGE4ZTBkYjg4ZmEwNDdmNWI3ZTM2MmJmYmI3MzBiNDQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDlhMjFjMzcxN2NiNDc4ZGJlMDRlNDQ1NDcyM2M4OTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTdmZTU5OTdjMzliNGI4ZGI0MjVmMzdmZmY2ZGI3OTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMGEyNzExMTllMDJlNDA5MTkxNzYwNzEwMWE2ZWYxMTUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMGNjMDNiMmE0YmZhNGJhMTlhZjMxMDZiMWVlNGQ2ZmIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfY2QwNTJiMzUyNDEwNDg3NGFiNWQzYTQxMWY1ZGE5ZTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNzEsLTAuMTM2Nzc4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzUyMGU1ZTRlOGQzNzQwYzE5NGQ3ZmNhZmI5M2FjOTRjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjcxLC0wLjEzNjc3OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84Zjg3ODk0ZTA5N2E0NzBiOGQyZjFmZWUwZDBmYWQ4ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzI3MSwtMC4xMzY3NzhdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGQ0MGUzM2FiNjE4NDE0MTg5OGYxMTNmMzBjMzBkOTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzLC0wLjEzNjcwNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yZjJmNGM4ZTAyOWQ0ZWY1YjU0M2Q4YjQxYzBkYWFhNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzMsLTAuMTM2NzA1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2VhZTZiNmY1ZDJhMjQ1MmU5YmVhMDYzZjJhZWYxNTM2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMywtMC4xMzY3MDVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNjQ0NmE3MDQyOTliNDA0MWFiYmY4ZjgwZTliNDViYmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzLC0wLjEzNjcwNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81NWE0ZTZmZDgxOWI0MmU3ODNmN2YxMzY0MjZjNDc4NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2LC0wLjEzNjQ5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mMWVjODZmOTNjZGQ0OGJhYWJlNjRhMTA5OGNmNTc4ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2LC0wLjEzNjQ5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wZmZmYzVkMzE4NWE0NGFkODg4ZGY1MjYyY2RiYjE3MiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2LC0wLjEzNjQ5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iNjdmM2M5ZjliZDM0Yjg4OWRiNmNmZjUzMjIyNjk0ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2LC0wLjEzNjQ5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jYTczZmU0NDBkNDA0MTQ4YTZiOTAzMTZjODFmYmExMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2LC0wLjEzNjQ5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85MjIwNjZiZDE0M2Y0NDk3YTEwN2Q3YzIxNWEwNTlmMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzAxNiwtMC4xMzYzM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wNjUzNTVjZjdjMzE0OTdiYTQxNzBkZDk4NzNjYmVhOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzAxNiwtMC4xMzYzM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hY2YyNTBkZDEwZDM0MThjODUzYjc5OWY0ZGY5NmEwNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjkyMSwtMC4xMzY0MjRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzA1ODMxNDQ4OTI2NDE3Zjg5ZTIyNmRhM2ZmM2I1NzUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4OTAwMDAwMDAwMDYsLTAuMTM2NTIzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzliMWM5MTQwMzMyZDRiMTViY2RjOGVjZmNjMDgyZjg5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyODkwMDAwMDAwMDA2LC0wLjEzNjUyM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zZDRmZjZlZGYzYWU0NTFhYTIwZGRjYmQxY2I3Zjk5ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjg1OTAwMDAwMDAwNiwtMC4xMzY1OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjY1MjY0NmIxNjM5NDdiY2E1ZjYzZjE3NTU5OWVmZWEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4MywtMC4xMzY2OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGNlZDQxODk0ZTMxNDZkMzkzNTM1ODRkZWFkNmJiMDcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI3ODIsLTAuMTM2ODE5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzMxN2Q0YmVmYjZkMzRkOTJhYjUxMWJmNDIwOWU4YzI5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzI5LC0wLjEzNjk3M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mOTU0MjFmNTRlMGI0MzNjODhkOTc1NzI4OWQyMmRhOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjg2OCwtMC4xMzYzNTc5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85MWZkYTE5YTE3ZmI0Mzk0OWZjMDg3NjM0MDE0YmE0MSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjcyMywtMC4xMzY2M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83Yjk1MTkzMWYxN2Y0NmE3YWY1MDAwYjUzN2Y0MjVhYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY1NCwtMC4xMzY1ODM5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yMTg1NGE4NjY1YzU0NDA5OTc0ZWJlNGZmNGUyOTIwNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjcxMywtMC4xMzY0MjNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjQyMzM4NTgwNGI5NGU2YmE1ZDI3MjMwNWRmZDUxYjMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI2MTUwMDAwMDAwMDQsLTAuMTM2MzQ1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzRmMjE0MGQxOWEzYjQxOGRiOWQ3YjNmMzM3YzA2ZDkxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDkxLC0wLjEzNjQzN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zMDU1OTk3ZDk1MDE0NWRhYTAxMTYwYzAyZWUyZjM4YiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjQ0OSwtMC4xMzYzNzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDQ1MDEyYzI5ZGJiNDVlNGIyYjUwMTI5ODQ4NGZmNzEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI0NjUsLTAuMTM2MTk3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzJmYmQ0MzIyOGE0ZTRlYzNiMThkYmY0MTJhNGQyZTZkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDEzLC0wLjEzNjE0Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lMWZlZDcyMWIwNjk0OGY1YjgyZTZmNjU1MDIwODRlYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjM1OCwtMC4xMzYxMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMWYzNTg1ZDI4MWU1NDMyMmE0NDQ4NzExMTMxZDhiNmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTIzNTgsLTAuMTM2MTAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzIxMjgyZWE0YWMzNjQ2NGY5MDlhNjUzZmI0ZTBlMjhkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMjcxMDAwMDAwMDA1LC0wLjEzNjAyOTk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzU0Y2MxYWE4ZTY3ZjRjMTc4ZWI0MWM4MTI2Njc0N2Y2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMzU1LC0wLjEzNjMxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzcyMjE2NDBlZTgyODQzZGI5YWJiNTQ1N2E4ZWE0YTgzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTExOTkwOTk5OTk5OTk1LC0wLjEzNTk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY5NTQ4NzdiYWUyYjQ0YzhiYzY2OGRkYThhNTU1YjM4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTExOTkwOTk5OTk5OTk1LC0wLjEzNTk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2ZkMTI3YTlkZDhiZTQ5NTk5YjM4OGIwOTY3YzYwMzQ0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTExOTkwOTk5OTk5OTk1LC0wLjEzNTk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzRmYTRlNjFiNzU5ZTRlYzViZjliNmNiMTFjODA0Njg3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTExOTkwOTk5OTk5OTk1LC0wLjEzNTk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2NlYjI3MDRjOWQxOTRkNGVhN2RhNGZmNzVkMzMxMTM2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMDgzMDAwMDAwMDA0LC0wLjEzNTg1OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iOTY2MjEwMTg0Mjc0NWI0OWIyZDZiNjg0Yzg2OGY0ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjA4MzAwMDAwMDAwNCwtMC4xMzU4NThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGVhODU4MDBhNjFkNGJiMjgyYzkwMzExYzc1MWE3MjEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTIwMzEsLTAuMTM1OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hNjI1MTA5OTkxZTI0ZDcyYTU5MjQ4YTkyMzlhYTNkZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTk3LC0wLjEzNTcxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iMTIxOWY4YjQxZTA0YjkxYWQwMDM2MjhiYjZjNTM2MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTk3LC0wLjEzNTcxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xY2UxMTc2YzBmZjQ0MzFhODBkMjI1NGJkZWRmMTcyNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTk3LC0wLjEzNTcxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNmJmODE0Mzc2YmY0NDJmOGUyODEyNjIxNDI0ZjdlNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTk3LC0wLjEzNTcxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kNWI3MjQ0MmQ1MjE0MWY3YjE5YTdiY2E0YjkxYzlkNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTg4MiwtMC4xMzUxMTkwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jYTA3YTE4NDc1Nzk0ZTIxOWNkZjNhYTBkZTc5ZDBjMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTg4MiwtMC4xMzUxMTkwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zYTY5NTZhZTQ0ZDI0YWQzYWViNzE3MjJhYTY1NzMyMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTg4MiwtMC4xMzUxMTkwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wYjdkYzJmNDFmNTM0ZjRkYTAzYjFkY2Q1MTJkNjRmNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTg4MiwtMC4xMzUxMTkwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hZTEyN2JhMDhmMjc0ZWM2ODIxZTNjNjMyMjhhZmI2MiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjA1LC0wLjEzNTE0NDAwMDAwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzk3YTY3YTYzYjhiNTQ0MTI4ODM5YzI0OWJjNTA4ZTQ3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMjUsLTAuMTM1Mzk0MDAwMDAwMDAwMDFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzBjZDJmNzNiZDc5NDc5NGJhZmE4YTJiMWM5ODA3ZjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTIyNSwtMC4xMzUzOTQwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84ZjU4MzdkNGM3ODI0NWFjOGRhY2JkNzczMDFiOTAwMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjI1LC0wLjEzNTM5NDAwMDAwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzI5Y2NlY2RhOGQzZDRlYTdhMzg3YWY1MWJiNjUxNmY3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMjUsLTAuMTM1Mzk0MDAwMDAwMDAwMDFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTkzODI0M2FlZDRiNDNhMzhjNTRjNjJhZDkzMzliZGQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTIxNjIsLTAuMTM1NDA5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzBiYzk5M2U4MzA5NTQ1YzFiMTQ1MDQ3MjFlNGMzZThlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMjEyLC0wLjEzNTQ3Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80ZDBiYWQ1M2Q0ZjI0NjAxODBmOTc1YzUyMDA4Yzk1MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjU3Mjk5OTk5OTk5NiwtMC4xMzU3NjVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZWE3M2NjMGMwMjZlNDIyOGI2NGZjNzQzM2VhYmVhNzUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI1NzI5OTk5OTk5OTYsLTAuMTM1NzY1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg0OGQ3NjQzYTA0ZDRkZmFhNTRhMmNjNDE4NmEwMzE0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNTc1LC0wLjEzNTg3MV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84MGFmNzYxZmNkN2Q0YmIyYTgwZGFkYmYwMjM2MTZiNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY3MTk5OTk5OTk5NSwtMC4xMzU5NzU5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84NDk1NjQ2OWM2NzY0ZmNjOTM4NjQ4ZDRlMGQwZWYxNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY3MTk5OTk5OTk5NSwtMC4xMzU5NzU5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yODhkOWU5MWRkNWE0ZmZmODVhYjY5OTMxNjE1N2E2NCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjcyNzAwMDAwMDAwNSwtMC4xMzYwMzNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTFjZmY1YTY5OGVjNDAyZDk3ODZmMzNkMDA3NDFjNzcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI3MjcwMDAwMDAwMDUsLTAuMTM2MDMzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2U0ODU5M2JhMTA0OTRjMjJhOWJmMDkzMzAxYmNlNmIzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzI3MDAwMDAwMDA1LC0wLjEzNjAzM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85OWUyMmRlNmQ3MmE0MjA4YWNkY2I1ZTg1MGUyYzc3YyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjc5NCwtMC4xMzYxMTVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmU1ZGUyM2IwNGY4NDYxMTlkZTQ1YWIxMDAzZmRmN2EgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NDYsLTAuMTM2MThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTkzYjM1MmRmNjc2NDM0NmFiMmZiMTU3OGJkMTNhZDMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NDYsLTAuMTM2MThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMWZiYTZlM2YzNDZlNDk4NDgwOGQ1MGQ5ZWViZGI3NzIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NDYsLTAuMTM2MThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTZmNjE5YWRiMTA3NDhjOThmZDkxNTM3OWZiZTlmYjYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NDYsLTAuMTM2MThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNjNmNTZhMjg2MjI4NGRkMzk2ZWIzZTc5NWE3MzM3MDIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NzksLTAuMTM2MDgyOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYTBiNDYwOTBjZTM4NGY5Y2JiMGJlNGNmYzYxNDA1ZjAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5MzksLTAuMTM2MTM5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2ZlZTVlZGRhNWY0NDRmMDc5NGQzYTYzM2JhNjk2NzFlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzY1LC0wLjEzNTMyOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80Mjc1ZjAyY2Q3MTY0MmM1YWU2YjQ3MDA3MDg5NGM0OCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjc2NSwtMC4xMzUzMjldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTRhYzQyMjdiOTM2NGQ3NmI2MjI4Y2RiNDE1MTE5YzYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI3NjUsLTAuMTM1MzI5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2JkZjIxMTFmMDgzNjRjZTY5MjQzYTQ1NGEyYTVlZDI0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzY1LC0wLjEzNTMyOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lNzRhMjE2NDlmYWU0NjQ4YTk4NTU2ZWUzYjgwZjFiZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjc2NSwtMC4xMzUzMjldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDhlZGM0NzBmZDIxNDY5MmE1N2Q0ZTZiNTZmNTk5NjggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI3NjUsLTAuMTM1MzI5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzBlMmI2ODZiYmZhNjQ0NDg4ZTlhNmEwNjllMDFhZGVlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzY1LC0wLjEzNTMyOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yYTk2YjljNjllMjQ0ZjAzOTU1OTUxOWE0NmZkZjJjMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjg0NCwtMC4xMzUxMjJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDdlZTFjZWVlMzJhNGZjYmJiZTExMmMyNGQ0ZTMzNjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NDQsLTAuMTM1MTIyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2RlYzFjOWZiNzI2YzRiOTA4NTQ4YzBlNWQwYWZiYmYwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyODQ0LC0wLjEzNTEyMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNjZkZTQxMTU0NmE0NjI1ODk0ZGU3YzcxOWRlMmExOSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83MjE5YzQ5MzM1YWQ0YTg0YWRjNjhhNmI0MjJmYzNlZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iZjViYmY1ZTc2Y2Y0YzhmOGM4YzkzMzZjYjk3Y2Y2ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81N2I2MjUxZjU2N2E0NjU2ODRmYWJkMDRkNzg3ZGE4YyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NDkwNTdmOGRmNmY0Y2YwOTNiNzUzYTg5YmJjYzgxYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zMjg2MjBkYzg3Yzg0ZWY2YWYxZDAyNDhmODRjMGE0NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lMjFlNjQ5ZDY2NjQ0NDUxODJiMjMyOTYxMjg5ZjVjNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84ZTliNTAxOTZkYjQ0YTAzYTNmNzAxNzY1M2VlYjVlZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zODI3ZWI4MjViNTc0NmJlYTZhZGQ2YTQ0ZTUxOGZjYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjE5OCwtMC4xMzQ1MjJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjkxMDA1M2RiMzE1NGYyMGFlMDcwN2E5ZTVjYTk0YWYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTIyMTUwMDAwMDAwMDUsLTAuMTM0OTY3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzZmODVjZjZiOTJmZTQ5Y2NiMTZiOTc5MTM1YmQ4NmY2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTU0LC0wLjEzNTA5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81ZTAxNTY2ODQxYTI0M2IwYjg4ZDc5Y2EzZmJhNGFhMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE1NCwtMC4xMzUwOThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNTQ3ZDM5NDE1Y2Y3NGQwY2E4NWQ4YmJiYzBhMDE1ZjQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMxNTQsLTAuMTM1MDk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzcwMmI4MmZhMWYxZTQyZjY4MzRmZWMwMzEzMjEwNzQyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTU0LC0wLjEzNTA5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kZmQ0YmY1OGE5NWM0YzZlOGMwY2JjODY5NGNjMWRiOSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE1NCwtMC4xMzUwOThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMmY1MjlhNmY5ZjQ3NDQ3MjlhNjRkMmExMjFiNjQ2YTIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwNTYsLTAuMTM0Mzk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2FhM2Q3NWFkNjY2ZjQ1MWI4ZTRjOTA2MDc2ZDgwOWRhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDU2LC0wLjEzNDM5NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xMjE0Nzg1ODc3YjI0YWViYTIzNjM2ZDk3M2Y1OGFhMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA1NiwtMC4xMzQzOTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWQxYjc0MDkyZjZlNGU1MGJkN2QzYTMwMzg4ZmY5MTYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwNTYsLTAuMTM0Mzk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzEzY2FmOTk5NTk2ODQwNmRhYjA2MDQ3ZmMzYjNlYjUxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDU2LC0wLjEzNDM5NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jMjE5YjI4MThmNWU0ODc2OWU1NzQ5NDZiNGYzNWVlNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA1NiwtMC4xMzQzOTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzI2YTc4MjQzYTRkNGE0YWJhNmFlNzZiNTIxYzRiNGEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwNTYsLTAuMTM0Mzk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ0MTRlYzY2NThiYTQ3OWRiNGI4OGI2NmM4YThlODdlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDU2LC0wLjEzNDM5NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hMDViODg4MTUwNjk0MTgwYjBiNzFhOTM4MjY1YTc4MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2NSwtMC4xMzQ1MDQ5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mOTA5ZGM2ZGY3MWY0OTA3ODMxNDI2MzM5MWE4YmFjYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2NSwtMC4xMzQ1MDQ5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kZmFmZGU2NmI3ZTc0NDQxODRmYzA4ZDAyYzMyZjk0MiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA5OCwtMC4xMzQ0MzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGVmNTk0ZTM5ZTUyNDhiZWE5NTc2OTMwZWQzNzZjNTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMzgsLTAuMTM0NTk0MDAwMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmEzYWQ2YzczNTE1NDliMWJkNGRlY2VjZDA2NDhlMmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyOTMsLTAuMTM0NjRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDM1NmU0OWM1MzNkNDJmNDkwMDI3MDRmMjI1OGY3ZWQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyOTMsLTAuMTM0NjRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYTQyNGZiNWQ0MmFkNDM1NWFlNzU5MDRkZDY5MzZlZDIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzNzksLTAuMTM0NzA5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzhjNjMyNDMxZTA1YjRhMGE4ZDNkODFkMDNjNTM0YWFiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDMxLC0wLjEzNDc1Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kM2U0YTI3NmNlYjE0ZTIwYjU3NjBjMjUyZjQ3NDg3ZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQzMSwtMC4xMzQ3NTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzA3OGZkNmUyNTBmNGVlN2FhMjkxZjViMWIzYzExZGMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0NzUsLTAuMTM1MjQ0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2NiNDYxM2MzYWUwNzRjNDc5MTQ4MDIwNTQ4ZDU0NmUyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDc1LC0wLjEzNTI0NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jZDEzOTMzYWNiY2M0YzQ4ODQxM2QyMmNhYjdhOWE3NyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQyMiwtMC4xMzQ4OTddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmI4OTYyYTg4ZDM2NDc3ZWJkMDViNjkwOWU2MmI0YTYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MjIsLTAuMTM0ODk3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzgyNzA1MDNhMmI0MzQ1MmU5NmY4OTE5MTI5YzljNGI2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDIyLC0wLjEzNDg5N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NmRjMWIwNDcxNGQ0OTY3OWZlNDdmZDdkOWI0MDZiZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzUyOCwtMC4xMzUxNThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMmVlYTFkZmE1NzE5NGZiNDk4YmE0NDU2YjVkYTZkODMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0ODEsLTAuMTM1MzQ0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzExNTA1MmQ1NDU4NDQ0ZjJhMjAyNmZhMTA4NmU3M2YzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDgxLC0wLjEzNTM0NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wMzJiYjg0ZWE2ZWY0ODczOWJiZTIwZmYzYWU1ODkxMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU5NCwtMC4xMzUwNjMwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81ZjMxMmRhNTRhYzA0ZTRlOTA4MGM0NzQyYWM5ZTlhNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU5NCwtMC4xMzUwNjMwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lNDE1MjBkYTYxNjQ0YzhjOGE4ZWFiNzE4NWY5YTdkZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzIyNywtMC4xMzU4MDFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfM2VhMmNlOWNjYWU4NDRhMjgzYmM5ZTMwZDMzNGYyZGUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMjcsLTAuMTM1ODAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzk1MjAzNTMzZTMxNTQ5MzZiMTNiMDNlZWE1YjNmMzM2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjI3LC0wLjEzNTgwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lODA0NjMxMWFhZjM0YmQyODQ0MGE2MjMzNWRhZTcxNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE4LC0wLjEzNTc2Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80MzFkZWFkNjNlNDI0NDQ4ODhiZDJlZjk4OGIxYzhmZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEzMiwtMC4xMzU3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mMDY3ZWJjMjg0ZDM0YzI3OWVmMGE1ZTk5MjQzMTFlNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEzMiwtMC4xMzU3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NThlM2JkNWU1OTU0ZmZlYjQxYjFjNGYzMGYwYWQwMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA0OCwtMC4xMzU2NDUwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wNTkwNDk5NjViMDk0YTQ0YWM4MGRhOGE5MWViZWYwZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzAwNiwtMC4xMzU2MDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDVmMTY2ZjFkZWEwNDU4ZjlkYjE0MTM5NGZmNDAwYjMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4ODMsLTAuMTM1NTAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q0MmEzZWU5NmY0NTQ2NWFhNmI2NDVlYzdkYmQzMmRmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjcsLTAuMTM1ODMxOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjJhZDg0MDFmODM3NGZiOGI5N2YyMzIxNmU2ZWY2ZmEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0NTkwMDAwMDAwMDUsLTAuMTM2MDQ5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzkwNDRlYThmZWFkMjQ0N2NiNDYwOTRmMWJjZmM5YmE5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDU5MDAwMDAwMDA1LC0wLjEzNjA0OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mZGFjYTU1MjdmYjA0NmFhYjQ1YTQwYjYwN2JlMDM5ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQ1OTAwMDAwMDAwNSwtMC4xMzYwNDldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWEyNjIxNTk5YjRkNDllOGFmN2E4ZWQ3MDIzOWY0ZjggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MzEsLTAuMTM2MTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYTEzMWUxZTYyY2MzNDk5Y2FlZjNkM2MxMmNkY2Q4ZGUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MzEsLTAuMTM2MTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWNhMWRmYjM2ZDkwNGZjOGJmMTJhOTA3Njc5ZjRjOTAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MzEsLTAuMTM2MTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDc2MThkM2QyNzA5NDM5ZjlmZmJmYTI4ZGQ4ZmY2MDYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MDIsLTAuMTM2MjI4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzU0OGRmYzkzYTQ2OTRmNDNhNmE0ZmVlMjU0MTZiODhkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDAyLC0wLjEzNjIyOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hZTZiN2UzNjRmMjU0MDE4YTZhZTE5MGNiYzQzNTJmNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQwMiwtMC4xMzYyMjhdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNTZjODBlMTgwOWEyNDcxYmE5ZDFjNWMxMGQxOWE1NDAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI1OTMsLTAuMTM0OTk5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2YxZTE3Mjk1ZjE3ZTRjNmE4NGIzZjJjYmY1YWI3MWJlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNTkzLC0wLjEzNDk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lYmRiODJlYzVkOGE0NzZmOTQ1NGYxNTJiNGM4YTAyOSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjU5MywtMC4xMzQ5OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGY3NGFkYjdlNmM5NDQzNDlhMmU1M2RjNTI5YTgyNmUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI1ODQ5OTk5OTk5OTQsLTAuMTM0NzkzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2M1ZWNmOTRmNTcyMzQyMTY4MWY1ODU5MGIwNmM2Y2EzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNTU1LC0wLjEzNDg5NjAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzliYmNlYmMxZGNhNTRiMGFiOTFlNmQxODc4YjYyZGY5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNTU1LC0wLjEzNDg5NjAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ3OWUzN2VlM2QzNjQ0ZWZhZTFmMjc1MDlmZjI0ZTE1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNTIxLC0wLjEzNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xN2I4NjBhMmYwNTU0MDg3YmEwZjEwMTY5ZWI0ZTQ2MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEzNywtMC4xMzM0ODNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjg4MjhlOGQyZjc1NDFlYWI0NTRlOWEwMTZiMDA0NTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMjgwMDAwMDAwMDUsLTAuMTMzMjY1MDAwMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjIzY2RmNTE2ZjFhNGJmYTljZTU0YjIyOTQxODZhNGMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMxNTIwMDAwMDAwMDUsLTAuMTMzMjk2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg5NzNmYzE1ZjQxNjQ5MDE5MWEyZDFhNDAzNWYzZWYyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTUyMDAwMDAwMDA1LC0wLjEzMzI5Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81OTdmNWUzZGMxYTg0NDZiYjk5NTk0NTY4MDQyZmFhNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzI1OCwtMC4xMzI5MzNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTc3YWUzYWExZWUxNDAzZjllM2Q4MWU2ODU1NmZjMjUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM1NDQsLTAuMTMzOTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2JmMDdmMGUwMDI4NjQ2YzNhMjEyMTFjNDk2NWU5NjBmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjI2LC0wLjEzNDA0Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yY2E2Mzc3YmRmYWM0YTIzODU4Mjc0NzliMTQ0MmE4YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzYzNywtMC4xMzQxNTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjFhZTUwMjk3ZDRlNGU3MTg1OWU5NTViM2FkODgzNGEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2MzcsLTAuMTM0MTU2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzZmYmZkYTYxZTA5MDQxZTdiYjJjMmY4YTU0NzFkYWFiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNTI0LC0wLjEzNDA5MTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2M4ODQzYjg1YmY2NjQ3ODliNzJiNThlODY3ZWY5ZWU4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNTI0LC0wLjEzNDA5MTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzA5YmVjZWUwMTExMzRmNzQ4MzFjYjE0YjYwNTgyNjUwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzODIsLTAuMTM0MjcyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzI0ZjY1YjRiMDhmMTQxMGVhOTExZmJiNTUwNWRmY2JlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzIzOTk5OTk5OTk2LC0wLjEzNDIyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzNhZTE2OWMxZDhjYzQwZGNhYmNlNzZlZDAzOWU3YzZkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzA0LC0wLjEzNDcwNF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82OTFkY2E0ZjA0MjY0ZjE0YTc3M2FjMmJmMzUwMDc5ZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzgzMSwtMC4xMzQ3ODE5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNjZhZDM2MTE1ZWQ0NDhjOWM4MDJlZDdlZmJhZjFmZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzkxNTAwMDAwMDAwNCwtMC4xMzUwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zODE3ZmVkNGEyNzY0Yjg1YmYxNTZlNDE0ODA5NGE5NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU5NywtMC4xMzQ5MjMwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hMGRjM2ZmYmQ2MjQ0NTNmODEzZGZkOGY2NWQ5MTFjZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDAzMiwtMC4xMzQ4ODQ5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83ODE1YmQzYWEzZjU0YjkwYTAzOTIzYzNiMDY5N2YxMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzg5MSwtMC4xMzQyMTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDM2MTBkZDQzYjU0NDExNWFkNGY5N2ZjNjc4NDBlM2IgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4OTEsLTAuMTM0MjEyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzU3ZmUzZTRlYmQ3ODQxNzliYjExZDcyMDY0Yzg4ZTRkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzODkxLC0wLjEzNDIxMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82MjUwNDVlN2IzMmQ0ZDNhYjg5NmMzNzBmYmM2YjY2MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzg5MSwtMC4xMzQyMTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzMxY2ZjN2VlZDFjNDAzZjhmMWIwNDI0NjE0ZTUwNzkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4OTEsLTAuMTM0MjEyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2UzNDgwM2VhNDEwNzQ2NDA4YmFiZDU3MGIwNjlhMWE0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzU4LC0wLjEzNDEzNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yMDg5MjdjZDgxZDI0MzVhYjY5OWJmNGY1YWJlOGMxYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2NSwtMC4xMzQzNjRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWQ1MGZkMzliM2U4NGEzZTkwN2EzZjdkMmU2MDQ1NTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQxNDYwMDAwMDAwMDQsLTAuMTM0NDQ3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzA0YWE2ZWRkYzk3NjQ2ZWRhOTM4NDcxMDc1NjE1ZDlkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MTQ2MDAwMDAwMDA0LC0wLjEzNDQ0N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNmViYWE2ZjRjMjk0YmY1OWNiYjkzZDA4NWE3NzM5MSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDIwMSwtMC4xMzQ0NzldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDRhZTg0Mjk4MjgwNDM0OThlYThhNzJiYmFiZWUyZmQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQyMDEsLTAuMTM0NDc5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2FjMDM3OWExZjI0ZDRmMDBiYmFmMjM4NTg0MmJjODkxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MjMsLTAuMTM0NjU4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQyMDdiMzMyYTQwYjRiYjZiMWIyN2VhNzAyZDBiMDM0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MzE5LC0wLjEzNDM2NzAwMDAwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2M2MzlkYTg1NjQyMDQ4ZDJiZDBhYWEyMWE0OWY0YWVkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0Mzc3LC0wLjEzNDE3OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zODNhMTA3N2FkN2M0OTNlOWVhZTc5NWJhMjg1Y2UzZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDM1NzAwMDAwMDAwNCwtMC4xMzQxNl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84ZmExZjZhYTE1ZmE0ZjExODgzNjFlNzJmZDY4NDJiNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDM4MiwtMC4xMzQwNjldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjRmZGZjOTc2OWJkNGM4MmFhYWI1N2NlYmQwMDllNDggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQzODIsLTAuMTM0MDY5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY4NmQ1YzczYTZlNzQ0MmZiZDVlZTZlNTFjYTgyZjg1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDAyMDAwMDAwMDA0LC0wLjEzNDA4NDk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzc0YzA2YjBhZWM5NzQwMGQ5ZDkyMjllM2NiNDNiM2EyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDAyMDAwMDAwMDA0LC0wLjEzNDA4NDk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2VjMmEwMjY5N2Y2MjQ3Y2Y5YzVhMjljZDNhN2FjZjliID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTIyLC0wLjEzMzgyMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80MjgwYmFiYzBhMjE0OTVkOWIxMTU4MWI0MWEyYzhiMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDUyMiwtMC4xMzM4MjFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMWM4N2U5Njk4YTVhNDg0Zjg0Yzk5OWVkZWZlZjJlY2EgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1MjIsLTAuMTMzODIxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzAxYWUyM2MyYWExZjQ2ZDVhM2MyMzZlNTVmMzk4ODZjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTIyLC0wLjEzMzgyMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kNmYyMDliMmI0YmQ0NzgzODA3MTE1ZWQ5MzZmODM5ZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDUyMiwtMC4xMzM4MjFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTE2ZTNmYWUwNGVhNDY1YmE3MThhMjEzYWU3OWE0OGMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ0OTcsLTAuMTMzOTIyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzRmYjM3MzExYjMyMDQ1NzJhOWU4Y2EzZDFjOTU3ZmZiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDcyLC0wLjEzMzg1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzYzMDljZDM0YjFmZjRiMWZiZTViNTAyNzA5ZmZjZDM5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTAzOTk5OTk5OTk1LC0wLjEzMzcyNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zOTFjZWQ5YzQxMDI0ZDNiOThmYjM3OTU0YTM5NzM0MSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDU0NiwtMC4xMzM3NDVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTFkMTEyYjA1MTMxNDAzNjg4NzUxZmUyOWVlMWYzNTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1NjEsLTAuMTMzNjc2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzcxMTVlZGQ2NDUxZDQ3NDc5ZWJiNDBjNDQyNjQ0MWZjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTYxLC0wLjEzMzY3Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iZmE2ZmQ2MTQ2MTY0ZjUzYjQwMTJiNzBjYmIwZmRmNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDU2MSwtMC4xMzM2NzZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDEzODRjNTBkMTY5NDE2NGIxYWFjMWFkNzJmYjI4ZDggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1NjEsLTAuMTMzNjc2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQwZjY4ZjU1Y2JhMDQyMTFhN2ZlNzZlNGI0M2UwMGUzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTk0LC0wLjEzMzU2MzAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2VjNTQ4YzU3NDBkYzQ5OGNhYTE5ZjhjYTU3ODEyYzU0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTgxLC0wLjEzMzQ2N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85MjE3OWUxZGE4YmM0MDA2Yjg4YTc0NTg0ZWFhOGQwNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDU4MSwtMC4xMzM0NjddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzdlMmIzZTczNDNhNDAzZmEzMjY0MjgwZDM1ZmM2NzYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ2MDYsLTAuMTMzMzkzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzA0ZGNkNzgwZmVjMDQxNjQ5NzM1OWI4ZTVkNmM0YTQ5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE1ODM0MDAwMDAwMDA1LC0wLjEzNDQ3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zY2YyZjEyNjdjYTI0ODUxYmFhYTcwMDNlNTZhMGZiMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNTE5NSwtMC4xMzUyNTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWRhOGFiZTk1MTkzNDY2YmE4ZGJkNmEyM2Y3YTE0YTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTUxNDksLTAuMTM1Mzk1MDAwMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWFiMzBkNTQ4MmY4NGY2NDk0ODlmODJlMTY5OGFiNWIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ4MTgsLTAuMTM2MDIyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q3YzJmZjEzYzM3NzQ1MTZhY2MyZGYxNzliOWI5NWNiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0ODQzLC0wLjEzNjgwNF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kMTE4NzU5YTNlYWU0M2RiYTZkZjYwMmYxYTgxMGRmMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDg0MywtMC4xMzY4MDRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjI4MjEzMDA1NGVhNDY4Zjk5YTU3NjJmOGNlODdjNTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ4NDMsLTAuMTM2ODA0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2NjZjM3NzdhNDY3ZjRiN2E4YzIwNGRmZmQwNTFlZDkxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0OTE0MDAwMDAwMDA1LC0wLjEzNjU4Mjk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzgzNmUwZmZjNzkyOTQwNGU5MWZjNDY5MjIyNTQ0ZTIzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDk2LC0wLjEzNTY1M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NjNkYTEwYjc2Y2M0YzhjOTVmNjYwYzAxOGM5OWVmOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDc0MywtMC4xMzU1NzhdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDMxMDk2Y2FhODg3NDE5ZmI3MDA1ZDEyN2FlOWIwYTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ3NDMsLTAuMTM1NTc4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzAzMGM0YjZjMDRmYTRiZGVhYjNkMTg5MjMzYzMwNDE0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDY2OTk5OTk5OTk2LC0wLjEzNDg1OTk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzUzZTE4NTE4YzM4NzQ3YjViNjYxZDNhOGQwZTQ1ZDJmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDUzLC0wLjEzNDY5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzk3MzgyMjUzZjU5NzQxN2FhNjMxMmIwN2E4ZWNiMjRiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0ODQ1LC0wLjEzNDgxOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zNzQ4MjA5MTJjMmE0MDcyOWM4Yzc5MDJlMDMwZTJjMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDM4OSwtMC4xMzU3MDRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjQ5ZmI2OWE5MjgyNGExZTlmYmUzNGRiOTYyM2QwMDcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQzOTksLTAuMTM1NTYxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Y3M2FkYmJiN2Q1ZDQ3MGNiOTY4NWU4YjBkMTU0ZDhmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MzM0OTk5OTk5OTk2LC0wLjEzNTY0OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mNjJlYjlmMDAwYWM0YmEzYWViYjRlNjBlYzFkNTJmYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDMzNDk5OTk5OTk5NiwtMC4xMzU2NDldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNTNmNDRkYmU5NDNmNDhlZDkxZTI5YTNhOGJjZGEwM2YgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQyMjQsLTAuMTM1NDE1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ4YzQzOWQ4NzliNjQ3ZGY5NzNiYzM5MDYyNmRjZDhjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MjIsLTAuMTM1NTc2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzhkNjQ2MDRmNzMzMDQ1MDk4ZDI2ODIyNjg2NzRmNjNiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MTQ1LC0wLjEzNTM1N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zYjJiNDcyMTliZTg0YzEzOWZjYmY1Yjg3ZjNmMmI5MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDE0NSwtMC4xMzUzNTddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDllZjczYWQ2YjdlNDg3MTk3OWViYjM4NzFkMDE5YmQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQxMDgsLTAuMTM1NDc1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg3YjUzM2E1MzhhZTQ4NWVhZTlhOTUyMGIwMDljOGQ2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MTA4LC0wLjEzNTQ3NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xOGM1ZDA2NjE5NzI0NGRiYThjYjhhY2E2YjhlYzkzYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDEwOCwtMC4xMzU0NzVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGQxZmIyZGZmNjZjNDUxNmEyODhmNzdhNmUwYjU0NTUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQzNTkwMDAwMDAwMDYsLTAuMTM2MjI1OTk5OTk5OTk5OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTg2ZmU0NWUwNDVjNGFmYmI2YjY0ZmQ1OGM2ODk2NDUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQzNTkwMDAwMDAwMDYsLTAuMTM2MjI1OTk5OTk5OTk5OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYTkzYzllMzJlMGY2NDZjY2IwOGFkNDdmNWQ4MDhlNjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQzMjYwMDAwMDAwMDQsLTAuMTM2MzI4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzE0MzgyYTFmZWZkNDQwZjY5YmQ2N2UwYWQwZWQ2NjY0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTQ0LC0wLjEzNjIyMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mZDEzZDM3NzJkZmE0YTRmODkzNDY1YTc1NTgxNjAzNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDU2OSwtMC4xMzYxMTcwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81YWQwMjI4OTY4OWI0MTM1ODUzNDcxODU1ZTBlYWE4NyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDU4NiwtMC4xMzYwMjk5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kMGFkOGVkMzNhZjA0M2NlYmFhMmU0NmYzZGQ4ZmQ0ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDYxMiwtMC4xMzYyNjZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzEzYWExMGZiMmZlNDYwZGExMTBkMGJhNGI0NjAwMTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1NzUsLTAuMTM2NDIxMDAwMDAwMDAwMDFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfODc4MzYyODVlNTVlNGEwY2EyNmMxMDBiYTU1MjkzYTAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1NzUsLTAuMTM2NDIxMDAwMDAwMDAwMDFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWFhMThmZjcwZWIxNDEzNjkwOWNkYjliMjMwZDA3MjEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1MDcsLTAuMTM2OTM1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg2YzU4ODUyYTc1YjRhMjc4ZjRlODFhZWUxMzVkNDFhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTA3LC0wLjEzNjkzNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iYTg1NmQwNzRmMzU0ZTJmOGFjZTc1N2UyNGM2NDc4MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDUwNywtMC4xMzY5MzVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTI1ZDc2NjQ4NjFiNDZiNDgyODk0Njk4ZGRmYmViMzIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQyNzQsLTAuMTM2OTMxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzc2NWI0NTMzNDllNjRmMzg5ZDdhZTA2ZWNmNmYyMjExID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0Mjc0LC0wLjEzNjkzMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83NTliMGY2NmQxMmM0Y2RjOGZlZDM3YWMwNGUyMGE4ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDI3NCwtMC4xMzY5MzFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDlkZDlmMTU2MjBiNGIwMzkxZTJmYjg2YjUzZTMyYTcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQyOTMsLTAuMTM2Nzk5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2I2MTUzM2RjM2NjMDQ0Nzg4Yzc2NTg5NjcwMjk2ZjNmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MDU4LC0wLjEzNjc3OTk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzEwYzMxMTM0ZTFjZTRmMTI5ODIwMjExNWVjYjU5Yzc5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MTQ4LC0wLjEzNjY5Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84OTY5NzRmOTg3MWE0ZTI5OTg3NmIyYjExOWMzZWU0MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDE0OCwtMC4xMzY2OTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNmU3OTcwNzllZWNmNGRjMDk1NDVhZmVmYjk2MDNkOTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQxNDgsLTAuMTM2Njk2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2RhYThlMDEwMmIxMTQ1YTg4M2RhYmI4MmFhNGI3ZjIwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzOTYxLC0wLjEzNjcxMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85MjQ0N2YwNGUwMzk0MTE0YTczZDkzMGIzOTYwYmZmNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDAyNywtMC4xMzYxMjNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTgwZTM2ZTQ1NWJiNGFmYjk5YmMxMWE4OGRlODkyNmUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQwNzYsLTAuMTM1OTU4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2YxYTBhODE5MGI3YjRjZmI5M2EzMDJiOGE5N2M3ZTA5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MDk2LC0wLjEzNTg4M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wMDUxODVkMGI1M2Q0MTFlOWQ2YmMzNDRlYWE0Y2I0NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDEzNDAwMDAwMDAwNiwtMC4xMzU3ODgwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81YzkwODFhNTMzNjg0Y2NhYTkwYTljYmYzOWQyMTdjYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDEzNDAwMDAwMDAwNiwtMC4xMzU3ODgwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jODM0ODU0OTIyYmE0YmRjYTdhYWIxMTgwYzk2Yjk3OSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDAzMzAwMDAwMDAwNSwtMC4xMzU4NDldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjk1NzM5ZGZhNTY3NDQxY2EwOWE5MTU5Mjk2M2Y1ZTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQwMzMwMDAwMDAwMDUsLTAuMTM1ODQ5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q2NzkxZjkwN2I3NzQ2MTY5ZmViMDY3MDJlZTdmNjlkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzOTk2LC0wLjEzNjAwOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xYmEwNWQ1Y2UzMTA0YWMwOTMyYzVkZDRhNzQyOWJkMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk5NiwtMC4xMzYwMDhdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmI4NmVkNmM2MjM2NDc2Njg1NTBjYjc5ZDMwNjQ0YmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM5OTYsLTAuMTM2MDA4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzNmNzA1MjY4M2Y4MjQ0ZDg5NzkxOTJlOTBlZjcwZGFhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzOTk2LC0wLjEzNjAwOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hMmQ2MDIwYmU3MDY0ZTcwODNhNGJmNzRjOTRjYzcyYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk2LC0wLjEzNjA5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mMWEzMDdmMjAwMzk0M2Y4ODU1YWZmMjQwYTAxY2NlYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk2LC0wLjEzNjA5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jNTFmODg5OGZlMzg0ZTUzODkwY2ZkNGJlYTQyMThmYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk2LC0wLjEzNjA5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83OWViYjExYWZhM2I0YzY3YTZkOTM4NDRmNDE4MDNlZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk2LC0wLjEzNjA5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xZmVmYTdkMWNmODE0YjgyYTU1OGQ0YjFmMDY3MWUwZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk2LC0wLjEzNjA5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wYzkxOTE3M2NhNGY0MmZmYjkzMzliNzFiZGIxNWRjMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk0NSwtMC4xMzYxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hMWM3YTg1Y2QzMTA0ZTAxODZlNTk5NDFiZjM1NDI2ZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk0NSwtMC4xMzYxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84ODU5ZThiMGZlMWI0ZWU5YmIyYjMyNjFjMDg2M2E1OCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzgyMSwtMC4xMzU0ODVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjRiYTAyMzM2NTRkNDcwYzllNDhiN2Q2ZjE4ZGRiYjMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4MjEsLTAuMTM1NDg1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ3YjBiNjVjYzdlZDQxNmI5MGZhM2I3MTgwYTQ0YmI3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzODIxLC0wLjEzNTQ4NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jMjhmYzIyNWUyNjk0YjFkYjk1MjNhNTBiOGYyMDBiNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzgyMSwtMC4xMzU0ODVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTBmMzcyNjY3ODkwNDI1NTlmYjRiNWQxYTFmN2QxNjcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4MjEsLTAuMTM1NDg1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQzNzQxYzU2ZmMxMDRiN2I5ZGQ4YTM0YTcxMjZjNzE3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzOTk5LC0wLjEzNTM3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iMThiZWQ1ZmM4N2U0NTFjYTM3MmQzYjM5Y2NiNTg1YyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk5OSwtMC4xMzUzNzRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjYzZjY3YmRiNzAxNDBjMTkxNWViOWZlMDIzZDM5NmEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM5OTksLTAuMTM1Mzc0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzZlOGFiNDA2NGUwMjQ0OWE5NTNlOTA5NzVhOWM1OTQxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzOTk5LC0wLjEzNTM3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81MGE3MGQ0YzQyMmY0MWQyOTVlZDg2NTcyZTg1ZjVkYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk5OSwtMC4xMzUzNzRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDgxYjY4NWRiOTNmNDg0Zjk0MjIyNjI4ZGY4MmE0NmEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3OTUsLTAuMTM1NTgxOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjRkNTBlYjNkNjkyNDhjYzlmMDVmNTI2YTY3YTk3ZWMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3OTUsLTAuMTM1NTgxOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfY2NmM2FkYmMwMzI5NDMyYmFiYzM2YmNhN2ZhYjRjZjUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3OTUsLTAuMTM1NTgxOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTIyNWFiNzZjMDBiNDNkYTkzMDBiNDVjYTM4N2ZkNGIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3NjYsLTAuMTM1Njc5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg5NTU3OTA2NjZlNDRmZWZhZWIyZDhhNjViMTJmYzkwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzY2LC0wLjEzNTY3OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82YmYxOWQyOTk2Y2I0OTdkYWI5YzJiY2FkNzU3MjBhNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzc2NiwtMC4xMzU2NzldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTI2ZTE1Yjc1MzJlNDk3YjhmNjNlY2FhOTllZjE3NGIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3MjYsLTAuMTM1ODE0MDAwMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfN2E5NTMyMjdiZTc5NGJmOTg3MjNlMmEwM2FiZTIzZGIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2OTIsLTAuMTM1OTA1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ5NmI0YmI5OTlmOTRhZTQ4YmNiNWVhOGM1M2RmOWU0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjkyLC0wLjEzNTkwNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xNzdhZTE1MDEwODA0YzAyYjg4YmU0NTg1NDQ0ODY0OCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzY5MiwtMC4xMzU5MDVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTM4YTM3NjZkYjdlNDViNmI3YzRjNDk0OWJhNzBmZDUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2OTIsLTAuMTM1OTA1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzcxYzZmM2E1YmE2ZTRhZjRhZmEyYjA0NGFhNWUxYTQzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjkyLC0wLjEzNTkwNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iMTAwNmUwNDA2MjA0ZDdkOTE0NjQ3ZWEzOTUyNTViYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzY3MiwtMC4xMzU5OTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfY2ExMDg5Y2M1ZmViNDg4OTk1NDU3NDMwMTljNTI5NmMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2NzIsLTAuMTM1OTkyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzZkNjQxNGFkMTFhZjQ0NTg5NjNhYjBmYTA5MDNiN2Q1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjcyLC0wLjEzNTk5Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jMGY3YjU0YTJiZDk0YjA1YjRlNzQ2YmViZDNmNWVhMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzY3MiwtMC4xMzU5OTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzFjYjA4YTk2Nzc5NDA5OTljZTdjOWVmYzk1YzkxNzUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2MDMsLTAuMTM2MjE3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2VlMzRiYWNiMjAyYzQyZTZiNDk2ZTI0NGIxYjhhY2Y1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjAzLC0wLjEzNjIxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83NDA3YjdiZTM3Mjk0ODQwODNkNjJkZmRmNDI0MGYzMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzYwMywtMC4xMzYyMTddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWNhZWJlZTgwOTM0NGM4NWEzMTI3ZjIwYTFlOGIyM2EgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2MDMsLTAuMTM2MjE3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2IwY2Q2YmMyYTU0ZTRkNTlhNDYxNzIzNzAwN2I0N2YxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDgyLC0wLjEzNjU3OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NmI2NDU5MmI5ZWU0ZTc1OTQxZDJmZjJmYzI4ZTI0OCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQ1OCwtMC4xMzY2NzVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTRlMmY3ZDQ4MzhkNDk0OTkzYzhhMWVmZDZjNTVhMTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0NTgsLTAuMTM2Njc1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q0MGE5NmEzOTJiZDQxMDdiZTc1NzNmZjBlNjY3OWI4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDU4LC0wLjEzNjY3NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83ZTJhYThmNGYwNzg0ZGQ3YjgxNjZjMDc3ZWQ4NTI1MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQ1OCwtMC4xMzY2NzVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDE5MmM5M2Y2YThlNGM1YzhiMmViYzBlZDk1NGM0ZTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0Mjg5OTk5OTk5OTUsLTAuMTM2NzY0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzdlNjE2NjVjMGNmODRkMmNiNjk2ZGNjNGI3NGU3ZWI5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDA0LC0wLjEzNjg3N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81NDMwZDIzNzNhMTU0OWIwOWRjMzUxMTQzNjQ5YTBkMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQwNCwtMC4xMzY4NzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmM0MmZkODJlNmFjNGFlOGFlOWNlZDdiMDE0MTI1OTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MDQsLTAuMTM2ODc3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzUzZDU5NWRlN2NiMTRjZDE5NzU1ODZkOGFiMjM4OTc5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMzU5LC0wLjEzNjk1M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85ZGJiNmU5ZDFiM2Y0N2NmYjg4YmM4Njc4OWNkYTFiYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzM1OSwtMC4xMzY5NTNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTUxMWNjODZiNzkzNGJlZDhmMzUwMmEyMzhmYjBhY2EgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzNzgsLTAuMTM3MjNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYzU1NjBlZGIzMzk0NDVkYTlmNWNlMmEwOTcxOTE1OTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4NTUsLTAuMTM2NjUxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2I4NTdkNzZmNGJmYTQ3ZDc4ZDQxMDNkNzEwYmRkOTcyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzODU1LC0wLjEzNjY1MV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81ZTNmZjZhMDE0N2U0NGQ4ODY4ZDE2YjkwMDkxMGY5OSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzg3NSwtMC4xMzY1MDI5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84ZjVlZGM4ZTg1OTU0MDk3YmY3MGQ2MzA4ZTFmNjVhNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU2NSwtMC4xMzczNjcwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lMTRmOTY3NGU4YTc0OGY5YWUxODAwMmFjODZiNDI2YyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzYxNiwtMC4xMzc0MjIwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kOGViMTUxNmQwZmU0ZGQ5OGNkY2EyYWVlMDcwMmU2MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzYxNiwtMC4xMzc0MjIwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jYTgwOTJkOWIwMzE0ODFiYWRmZGIxMGU5NTM5MWMxMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzc0MiwtMC4xMzc0NzJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfODBiMDYyZGMyM2M3NDViOGJiNzY1MWNmODgyOGMwYzQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3NDIsLTAuMTM3NDcyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzE0YTY5MzNjNjMzYjQwMDM5MTMwOGVmMjgyNWUwOWI4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzQyLC0wLjEzNzQ3Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84NTFiNDZlN2U5ZTk0YTY2OWRiNjg1OGY5ZTgxZWE1NyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzkxOCwtMC4xMzgzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzMwMDhhMzU1MWFiODRlYzBiMjI3YjRiMTQ5MWU3NzNmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzcxOTk5OTk5OTk2LC0wLjEzNzM2M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80OGVlMmNmNGNhOTQ0NGNlOGZkYzIwM2EwYTkwMjQzMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzUwMiwtMC4xMzc5OTVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfODgyNzM4N2JjZmUyNDg5ZWIxYTIzNWU1NWEyMGI4MTQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM1MDIsLTAuMTM3OTk1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2NiYTc2ZDdiMWFlZDQwYjNiOTA1MDAzNjJkYjA2ZDU5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNTAyLC0wLjEzNzk5NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wMmMwODM0YzMwNjM0YjFjOTE4YjQwYjNmNzllODk4YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzUwMiwtMC4xMzc5OTVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzNiZGMzNTQzMTJjNGM5OGE4NjBmZjA0ZGFhZjNmNTQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3MTIsLTAuMTM4MTM5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzI3MjNhNTk3N2M0ODQ1OTc4Njk4ZjliNWU3MjFiNGM0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzEyLC0wLjEzODEzOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xYzVlNWEyMWFjYzE0ZDMwYmYxNDdkNzc1MWYyODk2NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzY0NCwtMC4xMzgyMzldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDZlNWM0ZWRhYjE5NGNhMWJiZWU2ZTUxNDIyODEzYTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2NDQsLTAuMTM4MjM5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2IzMjI2OWQxMGJkNzQ4MTZhMjY1NjBlOTJhNWJmZGIxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzExLC0wLjEzODI3Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80YjMyMTU1YjMxYzc0ZDQ3YjU1YTlkMWJhOTMyNjBjOSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2MSwtMC4xMzgwODI5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82ZGY2NjI0ZGI1ZTU0NDI4OTFiY2U4OGE3MTNkMzc0NSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2MSwtMC4xMzgwODI5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yYTU5ZDJkM2U4OGU0NThkODM3ZjcxZDMzNjUxM2JhZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2MSwtMC4xMzgwODI5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85YjM3NDg0N2E5ZDg0MWEyYjZjYWIxMDJmNTAzN2M2YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2MSwtMC4xMzgwODI5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81ODU2ZTZmNjkxZDM0YTYzOGM1NDUwMzYyMWRhYmUyYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2MSwtMC4xMzgwODI5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85MzU1MjRlZGU5NjA0YTI2ODI3YWJlZTgzNDYwODVjNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDc0OCwtMC4xMzc5MTE5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NWVmNmVkYzNlMTY0MWI4ODRlYjAyMWZjZjQzZjk2ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDc0OCwtMC4xMzc5MTE5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zYjA3Y2FiMjRkZGQ0MmUyYmNjMTgwNjc0YTMxYTdiMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDc0OCwtMC4xMzc5MTE5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hNDcxM2NmNWMzZDk0NGIxYTk0ZTk3Yzc2Mjc0OGEzZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDc5NCwtMC4xMzc3MDddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZWIyMjc1NzQ0YmNhNDkzODk3MGU3ODIwOTY0ZjgwOTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ3OTQsLTAuMTM3NzA3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzA4N2FiNWU3NmIxZjRiYWI4MjMyMjE1NjcwYzMwNjkyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTI2MDAwMDAwMDA0LC0wLjEzNzEwNzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzhhM2ZhZTVkNmM2MjRlNTI5YjczZmNkZjc3NDU5ZDBmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTI2MDAwMDAwMDA0LC0wLjEzNzEwNzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2ViYTVmZjRhZWRhMDQzZTJiYTFmN2M1OWVhZWQxODk1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTI2MDAwMDAwMDA0LC0wLjEzNzEwNzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY1YWE5NDcwMDI3MzQ4MTM4YTg4ZGVmYzk0M2QzMTU2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NzA2LC0wLjEzNzA2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzc1OWE0N2FlNjg2ODQyNzFiZDQ4MDdiNTE0Y2YwYWZkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NzA2LC0wLjEzNzA2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzUzYmExZTJmMzFlYjQ0NDhhMDg4ZDEyMGU0MjY4YzY4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMzExLC0wLjEzODQ3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82MjkxNzlhODdmZGY0M2U0YjBmZjMyMjFlOGQ4ZmFjYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTk5OCwtMC4xMzgxMjNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYzk1MTE3ODY0MTM0NGRiODhkMTE5OTEwMTcwYmM2ZmIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTE4NTYsLTAuMTM3NzYyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAo8L3NjcmlwdD4= onload=&quot;this.contentDocument.open();this.contentDocument.write(atob(this.getAttribute(&#39;data-html&#39;)));this.contentDocument.close();&quot; allowfullscreen webkitallowfullscreen mozallowfullscreen&gt;&lt;/iframe&gt; 5. It&#39;s the pump! . After marking the deaths on the map, what John Snow saw was not a random pattern (we saw this on our recreation of The Ghost Map too). The majority of the deaths were concentrated at the corner of Broad Street (now Broadwick Street) and Cambridge Street (now Lexington Street). A cluster of deaths around the junction of these streets was the epicenter of the outbreak, but what was there? Yes, a water pump. . John Snow at the time already had a developed theory that cholera spreads through water, so to test this he marked on the map also the locations of the water pumps nearby. And here it was, the whole picture. . By combining the location of deaths related to cholera with locations of the water pumps, Snow was able to show that the majority were clustered around one particular public water pump in Broad Street, Soho. Finally, he had the proof that he needed. . We will now do the same and add the locations of the pumps to our recreation of The Ghost Map. . pumps = pd.read_csv(&#39;datasets/pumps.csv&#39;) # Subset the DataFrame and select just [&#39;X coordinate&#39;, &#39;Y coordinate&#39;] columns locations_pumps = pumps[[&#39;X coordinate&#39;, &#39;Y coordinate&#39;]] # Transform the DataFrame to list of lists in form of [&#39;X coordinate&#39;, &#39;Y coordinate&#39;] pairs pumps_list = locations_pumps.values.tolist() # Create a for loop and plot the data using folium (use previous map + add another layer) map1 = map for point in range(0, len(pumps_list)): folium.Marker(pumps_list[point], popup=pumps[&#39;Pump Name&#39;][point]).add_to(map1) map1 . Make this Notebook Trusted to load map: File -&gt; Trust Notebook&lt;iframe src=&quot;about:blank&quot; style=&quot;position:absolute;width:100%;height:100%;left:0;top:0;border:none !important;&quot; data-html=PCFET0NUWVBFIGh0bWw+CjxoZWFkPiAgICAKICAgIDxtZXRhIGh0dHAtZXF1aXY9ImNvbnRlbnQtdHlwZSIgY29udGVudD0idGV4dC9odG1sOyBjaGFyc2V0PVVURi04IiAvPgogICAgPHNjcmlwdD5MX1BSRUZFUl9DQU5WQVMgPSBmYWxzZTsgTF9OT19UT1VDSCA9IGZhbHNlOyBMX0RJU0FCTEVfM0QgPSBmYWxzZTs8L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2FqYXguZ29vZ2xlYXBpcy5jb20vYWpheC9saWJzL2pxdWVyeS8xLjExLjEvanF1ZXJ5Lm1pbi5qcyI+PC9zY3JpcHQ+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvanMvYm9vdHN0cmFwLm1pbi5qcyI+PC9zY3JpcHQ+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvTGVhZmxldC5hd2Vzb21lLW1hcmtlcnMvMi4wLjIvbGVhZmxldC5hd2Vzb21lLW1hcmtlcnMuanMiPjwvc2NyaXB0PgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9jc3MvYm9vdHN0cmFwLm1pbi5jc3MiLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzIi8+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLzQuNi4zL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9MZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy8yLjAuMi9sZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy5jc3MiLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9yYXdnaXQuY29tL3B5dGhvbi12aXN1YWxpemF0aW9uL2ZvbGl1bS9tYXN0ZXIvZm9saXVtL3RlbXBsYXRlcy9sZWFmbGV0LmF3ZXNvbWUucm90YXRlLmNzcyIvPgogICAgPHN0eWxlPmh0bWwsIGJvZHkge3dpZHRoOiAxMDAlO2hlaWdodDogMTAwJTttYXJnaW46IDA7cGFkZGluZzogMDt9PC9zdHlsZT4KICAgIDxzdHlsZT4jbWFwIHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtib3R0b206MDtyaWdodDowO2xlZnQ6MDt9PC9zdHlsZT4KICAgIAogICAgICAgICAgICA8c3R5bGU+ICNtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYgewogICAgICAgICAgICAgICAgcG9zaXRpb24gOiByZWxhdGl2ZTsKICAgICAgICAgICAgICAgIHdpZHRoIDogMTAwLjAlOwogICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAuMCU7CiAgICAgICAgICAgICAgICBsZWZ0OiAwLjAlOwogICAgICAgICAgICAgICAgdG9wOiAwLjAlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICA8L3N0eWxlPgogICAgICAgIAo8L2hlYWQ+Cjxib2R5PiAgICAKICAgIAogICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb2xpdW0tbWFwIiBpZD0ibWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2IiA+PC9kaXY+CiAgICAgICAgCjwvYm9keT4KPHNjcmlwdD4gICAgCiAgICAKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IG51bGw7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5NiA9IEwubWFwKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5NicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2VudGVyOiBbNTEuNTEzMjExOSwtMC4xMzY2Nl0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tOiAxNywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEJvdW5kczogYm91bmRzLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzOiBbXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkQ29weUp1bXA6IGZhbHNlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JzOiBMLkNSUy5FUFNHMzg1NwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHRpbGVfbGF5ZXJfNWEwZmE4MjlkNjc0NDAwNjk4NTVhMGIzMTAzYWFkOTIgPSBMLnRpbGVMYXllcigKICAgICAgICAgICAgICAgICdodHRwczovL3N0YW1lbi10aWxlcy17c30uYS5zc2wuZmFzdGx5Lm5ldC90b25lci97en0ve3h9L3t5fS5wbmcnLAogICAgICAgICAgICAgICAgewogICJhdHRyaWJ1dGlvbiI6IG51bGwsCiAgImRldGVjdFJldGluYSI6IGZhbHNlLAogICJtYXhab29tIjogMTgsCiAgIm1pblpvb20iOiAxLAogICJub1dyYXAiOiBmYWxzZSwKICAic3ViZG9tYWlucyI6ICJhYmMiCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NzYyOWY4Nzc1YTM0MWRkYWNjYjAzMTM1MGU0Nzk5MiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQxOCwtMC4xMzc5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iN2Q0NWI2ZWJmZGM0MDgxODMyMTVmYTc1ZDljOWYzNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQxOCwtMC4xMzc5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xMTNhMjc1ODc0NjQ0ZmQ2YmJhMzMxNzBjOGY4ODI1ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQxOCwtMC4xMzc5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83YTg1Y2YxNDlmNGQ0M2YxODNjYTM4M2EzMDQ0NzUyYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzM2MDk5OTk5OTk5NiwtMC4xMzc4ODNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjI0MzFmYzlhY2NhNDgxMmFjMmEzY2U4N2ZjNjUwNWQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzNjA5OTk5OTk5OTYsLTAuMTM3ODgzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2E1NjVmZDM3MGUwNDQwY2JhNjFiNTQ1ZmM5OGUyNTJiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMzE3LC0wLjEzNzg1M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNzY1YjNjODQ4ZDk0NTI4YTQxZDZkOWQ5NmQ3YjYzZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzI2MiwtMC4xMzc4MTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMWU3ZTZhMmMzODM3NDNhM2EwODBjY2I0MWNlN2NjMmQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMDM5OTk5OTk5OTUsLTAuMTM3NzY3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzBlM2ZhNWFhMDY0ZTRiYTY5NWQ3ZjU3YTE2ZTAwMjQ2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjAzOTk5OTk5OTk1LC0wLjEzNzc2N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NjQwZmFmNWZhNGQ0ZTlhODI3YzRjNzUyYTI5OGM3YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzIwMzk5OTk5OTk5NSwtMC4xMzc3NjddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzM3MjUwMWE0ZjFlNGJmYTg4YjNhNTNkY2NjNjE2OGUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMDM5OTk5OTk5OTUsLTAuMTM3NzY3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2UwNmU4ZmU4NTA2ZDQzMWM4MWUyYTdhMGM2ZWQzZTI3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTg0LC0wLjEzNzUzN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mNjhkMGE3ZTIyNmY0YzNlYTEyN2Y2ZGE2OWVhZTk4NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE4NCwtMC4xMzc1MzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDQ4ZWE3ZjhjMWI2NGI5ZDllZTk4N2I4NmJiMjJhOTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzNTksLTAuMTM4Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80MzhhZGVlNGY0NjE0NjFhOWY5Y2RkN2ExZGQ5YzQ1OSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzM1OSwtMC4xMzgyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzE2YjY4MWIzZTFhZjRiMWE5NTFkYjBjYzdiMjgzYzhhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMzI4LC0wLjEzODA0NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yMTI4ZjJhNTQwY2I0NDU5OTIyNWJjODc1Yjg3MzI5ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzMyOCwtMC4xMzgwNDVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzI5OTc5ZGNhYjVlNGU2NmJkMWI4MTMwODdkNDY0ZDYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzMjMsLTAuMTM4Mjc2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2I5Zjc4ZjNlOTI2MzRjNjc4NjJkOTYyZmE2ZDc0MTgzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMzIzLC0wLjEzODI3Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kYzFlNGE5ODMzYmY0NTBjYjkxYjU2MzI4ZGQyZDJjNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzMyMywtMC4xMzgyNzZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWIyOTNmMmY1NmYxNDAyMjhiYjNhYzI3MzQyNDkyZTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MjcsLTAuMTM4MjIzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2YwZjc5ZGNhMzcwMzRlZjA4YWU1NzczNDIyYjM4NWE0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDI3LC0wLjEzODIyM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82Yzg2MjUxMmU1Zjc0ODhmOGEwMWY4ZDBjYzZiZmMwZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzM4MSwtMC4xMzgzMzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYzAwZWNkNjJiMTIzNDE5MWEyZmY1MjRlZjBmNTczN2YgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzODEsLTAuMTM4MzM3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzllYmZmZDllZmU0ZDRkMzViOTI2YWM3MGJiNmJiN2Y4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDYyLC0wLjEzODU2MzAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzIwMGY4M2I4NWFhNDQzYTRhODQzNDMwMTUxY2RlNjA4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjE2LC0wLjEzODQyNl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xMTI3ZGY5ZGQxNTQ0MmY3OGE3MGM1NGRiNDEzMjZiNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzIxNiwtMC4xMzg0MjZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNTk2MjNiMjdiMWQ1NGQxMGJlMmJjNTI1ZTRhYjk5ZmIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMTYsLTAuMTM4NDI2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzEwYTU1ODU2MDI1NDQwOTJiNjEwNGYwNjI0YmJlNmIxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTY5LC0wLjEzODM3OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82ODUwODc3NzVkYTc0NWNjYWY5YjA3NzYwM2IyMDk2MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzExNiwtMC4xMzgzMzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDZhYWRkNjFhNmZmNGI4N2IzMzFmYmI4YTA1MDU4MjEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMxMTYsLTAuMTM4MzM3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzEyYzU3ZDc1YTEwMjRmZDA5OGFkMzhkNTI1NThiNzIxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTE2LC0wLjEzODMzN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NTk4Y2JiMTk0MTI0Y2Y5YjA5MmMzNWRmYzAxNmY4NCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzExNiwtMC4xMzgzMzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNjEzNjY2Y2FlZjFkNDBiNWI2NjI0ZTcwYjg1OTdlMzQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNCwtMC4xMzg2NDUwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81ZjM4YzI4YWEzNGE0YzZjYjc1YzJlNmMyYzNmMGZkMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2NCwtMC4xMzg2OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWJkZjM5ZmE1NGVjNGM5Zjg5ODZkMGU0YzA3NjE1MTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMxNzgsLTAuMTM3OTI0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzdmODVmM2IyN2VlNjQ4NTg4MmQyYzU4ZWMwMzM4ZDFjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTExLC0wLjEzNzg2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY4NmQ1ZjU4YzUzNDRkYjhhYTUzNWEwNmQyYjUwMzAxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTExLC0wLjEzNzg2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2MzNmY3NGIzZTk0MDQ2YmNiYzAxY2Y1MjI0ZmFlMzIzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTExLC0wLjEzNzg2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY0MWExMzg3MjhlODQyZDRiMDQ5NjNmN2M5NWZhMWRmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTExLC0wLjEzNzg2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzVjOGU5OGU3MGEwZDQ1ZTU5NzljM2FiOWU0ZjE4YTQ3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDU1LC0wLjEzNzgxMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNGYzN2NjMWZhYzE0ZTA0YWRhMWNkNDNiZGI0YTFkZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA1NSwtMC4xMzc4MTFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMmYwOWFmOTBiYTNhNDlhYjg5ODAxZmM2MTRkYWFiYzQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwNTUsLTAuMTM3ODExXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2UzMGRkOTcwZWUzNTQ4NmI5NjkwOWY5YTRjOTM3ZDE5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDQxLC0wLjEzODc2Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wMjc2Y2QyNjkxMjE0YzU5YjY0Yjk3MTAzOGJmMDAyZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQ0MSwtMC4xMzg3NjJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDNkMjk0NTIwNjIxNDA2ZThkMjM0MjdjZTA1NTNhYzEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM1OTE5OTk5OTk5OTYsLTAuMTM4Nzk5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzdkNDU0OTVhMTI3YTQzZTY5M2Y5ODhhODg3ZmY4NjExID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDAyLC0wLjEzOTA0NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lZDVkYzQ3YWMxNDI0Mzk1ODRmY2Y1NjliNzU2ODdmNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQwMiwtMC4xMzkwNDVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDhiYjI2ODFkMzZkNDMzMTg2YmZlMjZjNzE5ODQ4MWIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzOCwtMC4xMzg5N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NDE4ODkxMjlkMjk0YjVkYWQ1MTMxZGYwZjJiYTZjYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzM4LC0wLjEzODk3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2EzMmQzYmQ1MDNkZDRhYTFhMWMwZTc2MTMyYjY3NWYwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDExLC0wLjEzODg2MzAwMDAwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzgwMzI2OTQ5NTE3NzQzMWQ5ZjBjMjgwMzRhN2NhYWE2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDExLC0wLjEzODg2MzAwMDAwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzU1MWU2NjQ3ZTc0YjRkN2JhZmZkZmM0MDllMmE5Y2UzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjQxLC0wLjEzODc1Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83ZTUyMjVjODExYWI0Y2IwODY3NTliYmE1NTk5ZGJjYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzY5Mjk5OTk5OTk5NiwtMC4xMzg4MDhdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDZhNDRlYzAwMjM3NDQxM2EyNzU2MDQxOGJjY2FlMmEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3NDUsLTAuMTM4ODU2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzJhZjVjNGYxNDYxMDRjYTRiZmIxODQ2YTQzZDE1NDAyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzQ1LC0wLjEzODg1Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iN2IyYTk0YmU0YjU0YzE2YTNlMTI2ZmJjMTNmNDEwMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzc0NSwtMC4xMzg4NTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNjI5NzY0OGJmMDhmNGM3YjljZDUwY2Y2ZWNjZWNhYTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2NzYwMDAwMDAwMDQsLTAuMTM4ODg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDEwZWZiNjU2N2MzNGM3YWEyMDM5NjIxNDgyNjdlMmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM1OSwtMC4xMzkyMzldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmFlMTMxNTA1YTZkNDBmMGE2YTQ5NjQxMGE0N2QwMzggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2NjMsLTAuMTM5MzIxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzI5MzFjNDk5ZTEwODQ5ZmZhODRiNDdhZTNjM2RlMWI1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNTAyLC0wLjEzOTMxNl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81NzVmOTIxMzkwZWI0N2Q1YjUwM2Q3MGFlYjVhMjgwNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU4MzAwMDAwMDAwNCwtMC4xMzk2MTYwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iZGMxOTBiMGViMzg0M2RlODQwZDJmYmQ4YTE0MjQ3ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU4MzAwMDAwMDAwNCwtMC4xMzk2MTYwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84MDRkNDQ1ZjBjMjk0OTNmYTAxMjgzNmNiZWNmNjgyMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU0MSwtMC4xMzk3MTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjgyMTBiYWE4NGQ2NGU2M2I2M2E3ZDM1Zjg3YzgzMjcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM1NDEsLTAuMTM5NzE5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY1YjE2ZDM3ZjdiZTQyOTViZDM5ZTU5ZjA5MDgxMTkzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjk4LC0wLjE0MDA3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83YmEwMjIxZTc3MTE0NTY2YjVmZGJkZDkzNmVmZThjOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzI5MDk5OTk5OTk5NSwtMC4xMzkwOTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYmEzYTExNDQ5NTMwNGE1NWJiZTU4MDQyZjY4ZDI5ODUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwMTMsLTAuMTM5Njk3MDAwMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzcyN2U0YWRjYmZlNDZiYWEyNGI5Mjg3YmViMzY2M2EgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjUsLTAuMTM5MzI3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzVlYzQyNDJjZGFmYTRkZGViNzgyNDI2MmJiZWUzMmI0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyODkzLC0wLjEzOTMxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kMzk4OGFlMzEwYTM0NjljOThmNTU1NGUxYTUzYThmYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjg5MywtMC4xMzkzMTddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTdjZTY2NDliN2E1NGQxZGI0OGJiMzkwOWQyYzEzZjAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYmE0ODc0ZmFkOTJmNDEyZWE5NWNmZWMwYzJkMDViZDYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDMwYjRjOWU4MjgwNDE5Y2I4ZDk4ZmRjY2E4MzZkYTYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWMyNDZkMGNmNTEwNDcwOWI5NmRiZjM3YWZjN2JmZjYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTQ3ZDA5MmI0NTlhNDNiYzkyMzYyOTk2Mzc1ZjgyZjQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTUzZTM0YzhkMWY4NDc0YTlmNjQ5MTliNGYzMjQ1NDIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzJhOGMzMWY4ZTM3NGZlNjgzM2E2N2QyZDIyNGRkMzIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDkwNDQ0YjIyOTIzNGFmYjgzNDE5ZTFhZDdkZTFlMTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NjQwMDAwMDAwMDQsLTAuMTM5MTg2OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmIwN2FjYTFhY2NjNDQ4NWIxOGRiMzY0Mzc2YzFhNGYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwMjUsLTAuMTM5MDM2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzUxMDVmNDNkNzY1ZDRlZjg5MWUyYzFhNWMyNmYzYTFhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDI1LC0wLjEzOTAzNl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mNzYzZGQ5YjRlNjU0NzFkYTUwMDk1ODBmMjA2MzAwYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzAyNywtMC4xMzkyMDldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjUzZGRjZmQ3M2YwNGQ1ZTkyZjA2M2JmZDgxMDhjMjAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4MzEsLTAuMTM4NDI3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2QwMjk1YmJhNGJkMDRiNTM4Mzk1OTZjY2Q5NTBmYzExID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyODg1LC0wLjEzODYyNF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mZjNiOTI0YmU4MzU0MmFiOTc5YjM5NzdhZWIxMmY2MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUyNiwtMC4xMzgwOTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMGE3NWMzYzZiYjAyNDg2NDhlY2IyMDVkZjY1MzE3NzggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI0NjUsLTAuMTM4MDM1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2I5ZjczZjEzNWFlMzQ3OTRiNGJhNTE2ZTA5MGIyYzc0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDI4LC0wLjEzNzk4NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mZGY0NjZkZTVlOWM0MzM5YTcxNzIyOTU0MjkxNDdhOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjQyOCwtMC4xMzc5ODRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjE5ZDJhMWY1NzYzNDQyM2FjNDMzN2EyMDM2YTlkYTUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI0MjgsLTAuMTM3OTg0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg2OTJjMzY2YTIxOTRjNWM5MWFhNTdiMjg1Y2Y2NTk2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDI4LC0wLjEzNzk4NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82OTRlYmRmNDU2NmI0MDA0YWI3MTU3NzdiMjQyNzg5NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjQxNTAwMDAwMDAwNCwtMC4xMzgwNjUwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iNDMwMmU1YTdkMjY0YjVmYmQ0MDJlMWQ4NmIxN2Q0ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUxLC0wLjEzODE5NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mNTYyMzdlNzMxMzI0MmVhYmFiNTBkOWJmMmI3Mjk2ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjM3ODAwMDAwMDAwNSwtMC4xMzc4MThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjhhNDk5MmM3YTY4NDdjZWE1OWM1YzM1YmJmZjViMWMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI0NDY5OTk5OTk5OTUsLTAuMTM3NjU2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzMzYWMyYTJhYTYzMjQ2MjM4YmFlNDBhNjIyZjllNWYzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDkxLC0wLjEzNzU4Mzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2ZjYWU3ODQyZDRkNzQxNjBhYmU2MzZkNjU0ODE3YjJjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDkxLC0wLjEzNzU4Mzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzYzZmI1YzExZDE5ZTQwZWY5OTU0YzJmMDNjOTk0M2UzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDkxLC0wLjEzNzU4Mzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzJiNTg4NDA4Nzc3ZjQ5OTM5YjI5MjYzODFiOGM0ODQyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDkxLC0wLjEzNzU4Mzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2FhNzkxY2FlMmQ5MDQwM2ZiNDU2OTQyYTM5ZjllODA1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMzc0LC0wLjEzNzY1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzM5YjY1NDNlMTcwZjRiOWZhZDRkZmE1ZjBhYzMwOTkwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMzM5MDAwMDAwMDA0LC0wLjEzNzQ1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzJlOTgxOTQ4MzU1ODQ4MjdiN2NmNmMxMTM4YjQxMTVkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMzY0LC0wLjEzNzM3Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xMWU2MTZhNGE5Mjg0MTAzYTJlMjRlMWYzNjNiOGM5MiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjMxOSwtMC4xMzczMjddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjRkZDY4MWQxNzUyNDYwYTllNTdmMDRlYzc5ZmE3NDYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI1NCwtMC4xMzY5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hNTcwY2ZhNjg0Zjk0NTk1YjkzNjgyOGE5ZDg3Yzc5MSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY0ODk5OTk5OTk5NiwtMC4xMzcxOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zOWZmN2Y2YTU2NDk0YzQ5YjhhYzU0MGZiNWRhMmEwMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY0ODk5OTk5OTk5NiwtMC4xMzcxOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85ZjNkNjY5ZjM0ZDA0YzRhOWNjMjllMDhiMjhjYjIxOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY5MiwtMC4xMzcwNTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjdiMDIyZDdiOGUzNDNiNWJmZjE0NDc1OWZiM2I1ZjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5NTcsLTAuMTM3Njk1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2QwZDU2NmNiZDc4MDQyY2RiZTI3YjcyZWI0YjYxZTk1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzY1LC0wLjEzNzUzM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hYTBkYTM4YjBiOTA0MDcwYjkwNzA4OWIxMjczMjRiMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjc4LC0wLjEzNzQxOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jYWM3ZWY0MWI2YWY0NmViOTQwNzdiNmY5ZTFkZjlkZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjc4LC0wLjEzNzQxOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85YmYwNzhhY2EwNjI0ZDU5ODk4ZDc1N2Q3ZDNlODEwOSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjcyNiwtMC4xMzczNjgwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mNzA2YTgwZTU2NTA0YzA2YjVkYjhiYzQ1OTE5MThkNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY4MSwtMC4xMzczMjVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjJhYWVhYjRkNTcwNDc2OTg5NzE3NDRjNzE4MDk5NzEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5MTQsLTAuMTM3NTMxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q0M2IyNjBmYjY1ZTQ5ODU4NjhkYzEwOWMyY2ExZjVlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyOTE0LC0wLjEzNzUzMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNzU3N2VjOGFmMTE0ZTNjOTU5MDBmNjk1YTUwNzdjMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA0NiwtMC4xMzc1NjJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjQwYWY1N2EwOGZhNDc4MTg0YzNmNzdmYTUyMmYyNjUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwNDYsLTAuMTM3NTYyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2NjMmJjNGZjMzU1YjRmMGQ4YjJlOTVmZGNhNzQyZmI4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDczOTk5OTk5OTk2LC0wLjEzNzQ2Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zZTMwYWZjN2UzZDY0ZjYyOWM1YTU3OGY5MmIzNWYzMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA4NywtMC4xMzczODU5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jYTQzMTZjZjQ5OTM0MWUxOGRiZTkzMTk1NGJhOTM0NCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA4NywtMC4xMzczODU5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iNTA5NjA0MGQ4MzA0NTgzOTMyMDI3ZjAzZmVmOGQ5MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEyMTk5OTk5OTk5NiwtMC4xMzczMDU5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lYjlkYTNiZTJlOTI0NTcyYWQ4MmI5NjgxNjM0YmM3ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEyMTk5OTk5OTk5NiwtMC4xMzczMDU5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zYWQ2MDg0Yzk3ZDc0NGVmYmY3NjI2ZWRmYjI3MDQ5YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEyMTk5OTk5OTk5NiwtMC4xMzczMDU5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82MGNiYTc0Y2E0ZGU0OWY1YTBlOGRiOGNiYTlhZDVjZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE4NywtMC4xMzcwODkwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mM2ZiZTZmZDI0YjU0MDMyOWY5MWQyZDBiOTRhZWJjYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzIxNDAwMDAwMDAwNSwtMC4xMzY5OTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTc2NWFhMzRhNTkxNDU5MGExYTkyMDEyMjNiNDkwNjQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMTQwMDAwMDAwMDUsLTAuMTM2OTk2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2RlYWYzYmE2N2JkMjQ2NTM5ZDc5OWFmY2VmMjc2NDM1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjE0MDAwMDAwMDA1LC0wLjEzNjk5Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83ZTUzNGEzMmFkMWI0YjA2YmM4YjdlMjBkODAwZjAzYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzIxNDAwMDAwMDAwNSwtMC4xMzY5OTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzA0YjQwMTJlNDdjNGU4OTkzZWM3NGRiOTNlZmNkMzEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzBhZWNkYjliZmNmNDc1YWJiNmRiNTU2ZTE4MmU0M2QgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYmQ0MDMyMmQ2NGQyNDExZTk3YzU5Nzg1YTM5NmQwY2MgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTk0ZGNkNTk3N2JjNDQ0MWJjMTIxY2ZjMGE3MTQzNTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWFjZDRkN2Y4OTUyNGRjNGE2MzFjOTNjMDlmMGMzODUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjY4ZGIzM2RiNjY5NDQ2NjllYjM3YzVjYjA1N2NhNjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjRmYmE2MzU2NDQxNGEyMzhlZjI5YzFlNGVhNjM0YjkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYzcwNjM5OGY2MjhiNDg4MWIxNTAyZDg1NGIxYmFlOGEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTY0OTFmZTVmN2JiNGRlMzk4ODNkZTAyOGU1ZDg4MTQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjA5MzJhY2QyN2RmNDI3MmExOWM1N2JlNzNkNmRiMTIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMGE4ZTBkYjg4ZmEwNDdmNWI3ZTM2MmJmYmI3MzBiNDQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDlhMjFjMzcxN2NiNDc4ZGJlMDRlNDQ1NDcyM2M4OTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTdmZTU5OTdjMzliNGI4ZGI0MjVmMzdmZmY2ZGI3OTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMGEyNzExMTllMDJlNDA5MTkxNzYwNzEwMWE2ZWYxMTUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMGNjMDNiMmE0YmZhNGJhMTlhZjMxMDZiMWVlNGQ2ZmIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNDksLTAuMTM2ODU4OTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfY2QwNTJiMzUyNDEwNDg3NGFiNWQzYTQxMWY1ZGE5ZTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyNzEsLTAuMTM2Nzc4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzUyMGU1ZTRlOGQzNzQwYzE5NGQ3ZmNhZmI5M2FjOTRjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjcxLC0wLjEzNjc3OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84Zjg3ODk0ZTA5N2E0NzBiOGQyZjFmZWUwZDBmYWQ4ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzI3MSwtMC4xMzY3NzhdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGQ0MGUzM2FiNjE4NDE0MTg5OGYxMTNmMzBjMzBkOTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzLC0wLjEzNjcwNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yZjJmNGM4ZTAyOWQ0ZWY1YjU0M2Q4YjQxYzBkYWFhNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzMsLTAuMTM2NzA1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2VhZTZiNmY1ZDJhMjQ1MmU5YmVhMDYzZjJhZWYxNTM2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMywtMC4xMzY3MDVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNjQ0NmE3MDQyOTliNDA0MWFiYmY4ZjgwZTliNDViYmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzLC0wLjEzNjcwNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81NWE0ZTZmZDgxOWI0MmU3ODNmN2YxMzY0MjZjNDc4NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2LC0wLjEzNjQ5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mMWVjODZmOTNjZGQ0OGJhYWJlNjRhMTA5OGNmNTc4ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2LC0wLjEzNjQ5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wZmZmYzVkMzE4NWE0NGFkODg4ZGY1MjYyY2RiYjE3MiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2LC0wLjEzNjQ5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iNjdmM2M5ZjliZDM0Yjg4OWRiNmNmZjUzMjIyNjk0ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2LC0wLjEzNjQ5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jYTczZmU0NDBkNDA0MTQ4YTZiOTAzMTZjODFmYmExMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2LC0wLjEzNjQ5M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85MjIwNjZiZDE0M2Y0NDk3YTEwN2Q3YzIxNWEwNTlmMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzAxNiwtMC4xMzYzM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wNjUzNTVjZjdjMzE0OTdiYTQxNzBkZDk4NzNjYmVhOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzAxNiwtMC4xMzYzM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hY2YyNTBkZDEwZDM0MThjODUzYjc5OWY0ZGY5NmEwNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjkyMSwtMC4xMzY0MjRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzA1ODMxNDQ4OTI2NDE3Zjg5ZTIyNmRhM2ZmM2I1NzUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4OTAwMDAwMDAwMDYsLTAuMTM2NTIzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzliMWM5MTQwMzMyZDRiMTViY2RjOGVjZmNjMDgyZjg5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyODkwMDAwMDAwMDA2LC0wLjEzNjUyM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zZDRmZjZlZGYzYWU0NTFhYTIwZGRjYmQxY2I3Zjk5ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjg1OTAwMDAwMDAwNiwtMC4xMzY1OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjY1MjY0NmIxNjM5NDdiY2E1ZjYzZjE3NTU5OWVmZWEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4MywtMC4xMzY2OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGNlZDQxODk0ZTMxNDZkMzkzNTM1ODRkZWFkNmJiMDcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI3ODIsLTAuMTM2ODE5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzMxN2Q0YmVmYjZkMzRkOTJhYjUxMWJmNDIwOWU4YzI5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzI5LC0wLjEzNjk3M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mOTU0MjFmNTRlMGI0MzNjODhkOTc1NzI4OWQyMmRhOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjg2OCwtMC4xMzYzNTc5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85MWZkYTE5YTE3ZmI0Mzk0OWZjMDg3NjM0MDE0YmE0MSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjcyMywtMC4xMzY2M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83Yjk1MTkzMWYxN2Y0NmE3YWY1MDAwYjUzN2Y0MjVhYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY1NCwtMC4xMzY1ODM5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yMTg1NGE4NjY1YzU0NDA5OTc0ZWJlNGZmNGUyOTIwNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjcxMywtMC4xMzY0MjNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjQyMzM4NTgwNGI5NGU2YmE1ZDI3MjMwNWRmZDUxYjMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI2MTUwMDAwMDAwMDQsLTAuMTM2MzQ1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzRmMjE0MGQxOWEzYjQxOGRiOWQ3YjNmMzM3YzA2ZDkxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDkxLC0wLjEzNjQzN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zMDU1OTk3ZDk1MDE0NWRhYTAxMTYwYzAyZWUyZjM4YiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjQ0OSwtMC4xMzYzNzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDQ1MDEyYzI5ZGJiNDVlNGIyYjUwMTI5ODQ4NGZmNzEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI0NjUsLTAuMTM2MTk3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzJmYmQ0MzIyOGE0ZTRlYzNiMThkYmY0MTJhNGQyZTZkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNDEzLC0wLjEzNjE0Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lMWZlZDcyMWIwNjk0OGY1YjgyZTZmNjU1MDIwODRlYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjM1OCwtMC4xMzYxMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMWYzNTg1ZDI4MWU1NDMyMmE0NDQ4NzExMTMxZDhiNmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTIzNTgsLTAuMTM2MTAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzIxMjgyZWE0YWMzNjQ2NGY5MDlhNjUzZmI0ZTBlMjhkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMjcxMDAwMDAwMDA1LC0wLjEzNjAyOTk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzU0Y2MxYWE4ZTY3ZjRjMTc4ZWI0MWM4MTI2Njc0N2Y2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMzU1LC0wLjEzNjMxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzcyMjE2NDBlZTgyODQzZGI5YWJiNTQ1N2E4ZWE0YTgzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTExOTkwOTk5OTk5OTk1LC0wLjEzNTk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY5NTQ4NzdiYWUyYjQ0YzhiYzY2OGRkYThhNTU1YjM4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTExOTkwOTk5OTk5OTk1LC0wLjEzNTk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2ZkMTI3YTlkZDhiZTQ5NTk5YjM4OGIwOTY3YzYwMzQ0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTExOTkwOTk5OTk5OTk1LC0wLjEzNTk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzRmYTRlNjFiNzU5ZTRlYzViZjliNmNiMTFjODA0Njg3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTExOTkwOTk5OTk5OTk1LC0wLjEzNTk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2NlYjI3MDRjOWQxOTRkNGVhN2RhNGZmNzVkMzMxMTM2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMDgzMDAwMDAwMDA0LC0wLjEzNTg1OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iOTY2MjEwMTg0Mjc0NWI0OWIyZDZiNjg0Yzg2OGY0ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjA4MzAwMDAwMDAwNCwtMC4xMzU4NThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGVhODU4MDBhNjFkNGJiMjgyYzkwMzExYzc1MWE3MjEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTIwMzEsLTAuMTM1OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hNjI1MTA5OTkxZTI0ZDcyYTU5MjQ4YTkyMzlhYTNkZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTk3LC0wLjEzNTcxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iMTIxOWY4YjQxZTA0YjkxYWQwMDM2MjhiYjZjNTM2MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTk3LC0wLjEzNTcxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xY2UxMTc2YzBmZjQ0MzFhODBkMjI1NGJkZWRmMTcyNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTk3LC0wLjEzNTcxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNmJmODE0Mzc2YmY0NDJmOGUyODEyNjIxNDI0ZjdlNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTk3LC0wLjEzNTcxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kNWI3MjQ0MmQ1MjE0MWY3YjE5YTdiY2E0YjkxYzlkNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTg4MiwtMC4xMzUxMTkwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jYTA3YTE4NDc1Nzk0ZTIxOWNkZjNhYTBkZTc5ZDBjMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTg4MiwtMC4xMzUxMTkwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zYTY5NTZhZTQ0ZDI0YWQzYWViNzE3MjJhYTY1NzMyMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTg4MiwtMC4xMzUxMTkwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wYjdkYzJmNDFmNTM0ZjRkYTAzYjFkY2Q1MTJkNjRmNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTg4MiwtMC4xMzUxMTkwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hZTEyN2JhMDhmMjc0ZWM2ODIxZTNjNjMyMjhhZmI2MiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjA1LC0wLjEzNTE0NDAwMDAwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzk3YTY3YTYzYjhiNTQ0MTI4ODM5YzI0OWJjNTA4ZTQ3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMjUsLTAuMTM1Mzk0MDAwMDAwMDAwMDFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzBjZDJmNzNiZDc5NDc5NGJhZmE4YTJiMWM5ODA3ZjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTIyNSwtMC4xMzUzOTQwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84ZjU4MzdkNGM3ODI0NWFjOGRhY2JkNzczMDFiOTAwMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjI1LC0wLjEzNTM5NDAwMDAwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzI5Y2NlY2RhOGQzZDRlYTdhMzg3YWY1MWJiNjUxNmY3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMjUsLTAuMTM1Mzk0MDAwMDAwMDAwMDFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTkzODI0M2FlZDRiNDNhMzhjNTRjNjJhZDkzMzliZGQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTIxNjIsLTAuMTM1NDA5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzBiYzk5M2U4MzA5NTQ1YzFiMTQ1MDQ3MjFlNGMzZThlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMjEyLC0wLjEzNTQ3Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80ZDBiYWQ1M2Q0ZjI0NjAxODBmOTc1YzUyMDA4Yzk1MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjU3Mjk5OTk5OTk5NiwtMC4xMzU3NjVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZWE3M2NjMGMwMjZlNDIyOGI2NGZjNzQzM2VhYmVhNzUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI1NzI5OTk5OTk5OTYsLTAuMTM1NzY1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg0OGQ3NjQzYTA0ZDRkZmFhNTRhMmNjNDE4NmEwMzE0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNTc1LC0wLjEzNTg3MV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84MGFmNzYxZmNkN2Q0YmIyYTgwZGFkYmYwMjM2MTZiNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY3MTk5OTk5OTk5NSwtMC4xMzU5NzU5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84NDk1NjQ2OWM2NzY0ZmNjOTM4NjQ4ZDRlMGQwZWYxNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjY3MTk5OTk5OTk5NSwtMC4xMzU5NzU5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yODhkOWU5MWRkNWE0ZmZmODVhYjY5OTMxNjE1N2E2NCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjcyNzAwMDAwMDAwNSwtMC4xMzYwMzNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTFjZmY1YTY5OGVjNDAyZDk3ODZmMzNkMDA3NDFjNzcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI3MjcwMDAwMDAwMDUsLTAuMTM2MDMzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2U0ODU5M2JhMTA0OTRjMjJhOWJmMDkzMzAxYmNlNmIzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzI3MDAwMDAwMDA1LC0wLjEzNjAzM10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85OWUyMmRlNmQ3MmE0MjA4YWNkY2I1ZTg1MGUyYzc3YyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjc5NCwtMC4xMzYxMTVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmU1ZGUyM2IwNGY4NDYxMTlkZTQ1YWIxMDAzZmRmN2EgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NDYsLTAuMTM2MThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTkzYjM1MmRmNjc2NDM0NmFiMmZiMTU3OGJkMTNhZDMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NDYsLTAuMTM2MThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMWZiYTZlM2YzNDZlNDk4NDgwOGQ1MGQ5ZWViZGI3NzIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NDYsLTAuMTM2MThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTZmNjE5YWRiMTA3NDhjOThmZDkxNTM3OWZiZTlmYjYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NDYsLTAuMTM2MThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNjNmNTZhMjg2MjI4NGRkMzk2ZWIzZTc5NWE3MzM3MDIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NzksLTAuMTM2MDgyOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYTBiNDYwOTBjZTM4NGY5Y2JiMGJlNGNmYzYxNDA1ZjAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI5MzksLTAuMTM2MTM5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2ZlZTVlZGRhNWY0NDRmMDc5NGQzYTYzM2JhNjk2NzFlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzY1LC0wLjEzNTMyOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80Mjc1ZjAyY2Q3MTY0MmM1YWU2YjQ3MDA3MDg5NGM0OCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjc2NSwtMC4xMzUzMjldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTRhYzQyMjdiOTM2NGQ3NmI2MjI4Y2RiNDE1MTE5YzYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI3NjUsLTAuMTM1MzI5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2JkZjIxMTFmMDgzNjRjZTY5MjQzYTQ1NGEyYTVlZDI0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzY1LC0wLjEzNTMyOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lNzRhMjE2NDlmYWU0NjQ4YTk4NTU2ZWUzYjgwZjFiZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjc2NSwtMC4xMzUzMjldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDhlZGM0NzBmZDIxNDY5MmE1N2Q0ZTZiNTZmNTk5NjggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI3NjUsLTAuMTM1MzI5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzBlMmI2ODZiYmZhNjQ0NDg4ZTlhNmEwNjllMDFhZGVlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNzY1LC0wLjEzNTMyOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yYTk2YjljNjllMjQ0ZjAzOTU1OTUxOWE0NmZkZjJjMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjg0NCwtMC4xMzUxMjJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDdlZTFjZWVlMzJhNGZjYmJiZTExMmMyNGQ0ZTMzNjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4NDQsLTAuMTM1MTIyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2RlYzFjOWZiNzI2YzRiOTA4NTQ4YzBlNWQwYWZiYmYwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyODQ0LC0wLjEzNTEyMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNjZkZTQxMTU0NmE0NjI1ODk0ZGU3YzcxOWRlMmExOSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83MjE5YzQ5MzM1YWQ0YTg0YWRjNjhhNmI0MjJmYzNlZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iZjViYmY1ZTc2Y2Y0YzhmOGM4YzkzMzZjYjk3Y2Y2ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81N2I2MjUxZjU2N2E0NjU2ODRmYWJkMDRkNzg3ZGE4YyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NDkwNTdmOGRmNmY0Y2YwOTNiNzUzYTg5YmJjYzgxYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zMjg2MjBkYzg3Yzg0ZWY2YWYxZDAyNDhmODRjMGE0NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lMjFlNjQ5ZDY2NjQ0NDUxODJiMjMyOTYxMjg5ZjVjNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84ZTliNTAxOTZkYjQ0YTAzYTNmNzAxNzY1M2VlYjVlZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjUzMiwtMC4xMzQ2NDUwMDAwMDAwMDAwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zODI3ZWI4MjViNTc0NmJlYTZhZGQ2YTQ0ZTUxOGZjYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjE5OCwtMC4xMzQ1MjJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjkxMDA1M2RiMzE1NGYyMGFlMDcwN2E5ZTVjYTk0YWYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTIyMTUwMDAwMDAwMDUsLTAuMTM0OTY3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzZmODVjZjZiOTJmZTQ5Y2NiMTZiOTc5MTM1YmQ4NmY2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTU0LC0wLjEzNTA5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81ZTAxNTY2ODQxYTI0M2IwYjg4ZDc5Y2EzZmJhNGFhMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE1NCwtMC4xMzUwOThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNTQ3ZDM5NDE1Y2Y3NGQwY2E4NWQ4YmJiYzBhMDE1ZjQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMxNTQsLTAuMTM1MDk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzcwMmI4MmZhMWYxZTQyZjY4MzRmZWMwMzEzMjEwNzQyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTU0LC0wLjEzNTA5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kZmQ0YmY1OGE5NWM0YzZlOGMwY2JjODY5NGNjMWRiOSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE1NCwtMC4xMzUwOThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMmY1MjlhNmY5ZjQ3NDQ3MjlhNjRkMmExMjFiNjQ2YTIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwNTYsLTAuMTM0Mzk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2FhM2Q3NWFkNjY2ZjQ1MWI4ZTRjOTA2MDc2ZDgwOWRhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDU2LC0wLjEzNDM5NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xMjE0Nzg1ODc3YjI0YWViYTIzNjM2ZDk3M2Y1OGFhMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA1NiwtMC4xMzQzOTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWQxYjc0MDkyZjZlNGU1MGJkN2QzYTMwMzg4ZmY5MTYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwNTYsLTAuMTM0Mzk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzEzY2FmOTk5NTk2ODQwNmRhYjA2MDQ3ZmMzYjNlYjUxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDU2LC0wLjEzNDM5NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jMjE5YjI4MThmNWU0ODc2OWU1NzQ5NDZiNGYzNWVlNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA1NiwtMC4xMzQzOTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzI2YTc4MjQzYTRkNGE0YWJhNmFlNzZiNTIxYzRiNGEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMwNTYsLTAuMTM0Mzk0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ0MTRlYzY2NThiYTQ3OWRiNGI4OGI2NmM4YThlODdlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMDU2LC0wLjEzNDM5NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hMDViODg4MTUwNjk0MTgwYjBiNzFhOTM4MjY1YTc4MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2NSwtMC4xMzQ1MDQ5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mOTA5ZGM2ZGY3MWY0OTA3ODMxNDI2MzM5MWE4YmFjYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE2NSwtMC4xMzQ1MDQ5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kZmFmZGU2NmI3ZTc0NDQxODRmYzA4ZDAyYzMyZjk0MiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA5OCwtMC4xMzQ0MzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGVmNTk0ZTM5ZTUyNDhiZWE5NTc2OTMwZWQzNzZjNTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMzgsLTAuMTM0NTk0MDAwMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmEzYWQ2YzczNTE1NDliMWJkNGRlY2VjZDA2NDhlMmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyOTMsLTAuMTM0NjRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDM1NmU0OWM1MzNkNDJmNDkwMDI3MDRmMjI1OGY3ZWQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyOTMsLTAuMTM0NjRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYTQyNGZiNWQ0MmFkNDM1NWFlNzU5MDRkZDY5MzZlZDIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzNzksLTAuMTM0NzA5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzhjNjMyNDMxZTA1YjRhMGE4ZDNkODFkMDNjNTM0YWFiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDMxLC0wLjEzNDc1Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kM2U0YTI3NmNlYjE0ZTIwYjU3NjBjMjUyZjQ3NDg3ZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQzMSwtMC4xMzQ3NTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzA3OGZkNmUyNTBmNGVlN2FhMjkxZjViMWIzYzExZGMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0NzUsLTAuMTM1MjQ0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2NiNDYxM2MzYWUwNzRjNDc5MTQ4MDIwNTQ4ZDU0NmUyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDc1LC0wLjEzNTI0NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jZDEzOTMzYWNiY2M0YzQ4ODQxM2QyMmNhYjdhOWE3NyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQyMiwtMC4xMzQ4OTddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmI4OTYyYTg4ZDM2NDc3ZWJkMDViNjkwOWU2MmI0YTYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MjIsLTAuMTM0ODk3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzgyNzA1MDNhMmI0MzQ1MmU5NmY4OTE5MTI5YzljNGI2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDIyLC0wLjEzNDg5N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NmRjMWIwNDcxNGQ0OTY3OWZlNDdmZDdkOWI0MDZiZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzUyOCwtMC4xMzUxNThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMmVlYTFkZmE1NzE5NGZiNDk4YmE0NDU2YjVkYTZkODMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0ODEsLTAuMTM1MzQ0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzExNTA1MmQ1NDU4NDQ0ZjJhMjAyNmZhMTA4NmU3M2YzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDgxLC0wLjEzNTM0NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wMzJiYjg0ZWE2ZWY0ODczOWJiZTIwZmYzYWU1ODkxMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU5NCwtMC4xMzUwNjMwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81ZjMxMmRhNTRhYzA0ZTRlOTA4MGM0NzQyYWM5ZTlhNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU5NCwtMC4xMzUwNjMwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lNDE1MjBkYTYxNjQ0YzhjOGE4ZWFiNzE4NWY5YTdkZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzIyNywtMC4xMzU4MDFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfM2VhMmNlOWNjYWU4NDRhMjgzYmM5ZTMwZDMzNGYyZGUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMjcsLTAuMTM1ODAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzk1MjAzNTMzZTMxNTQ5MzZiMTNiMDNlZWE1YjNmMzM2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjI3LC0wLjEzNTgwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lODA0NjMxMWFhZjM0YmQyODQ0MGE2MjMzNWRhZTcxNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzE4LC0wLjEzNTc2Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80MzFkZWFkNjNlNDI0NDQ4ODhiZDJlZjk4OGIxYzhmZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEzMiwtMC4xMzU3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mMDY3ZWJjMjg0ZDM0YzI3OWVmMGE1ZTk5MjQzMTFlNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEzMiwtMC4xMzU3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NThlM2JkNWU1OTU0ZmZlYjQxYjFjNGYzMGYwYWQwMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzA0OCwtMC4xMzU2NDUwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wNTkwNDk5NjViMDk0YTQ0YWM4MGRhOGE5MWViZWYwZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzAwNiwtMC4xMzU2MDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDVmMTY2ZjFkZWEwNDU4ZjlkYjE0MTM5NGZmNDAwYjMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI4ODMsLTAuMTM1NTAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q0MmEzZWU5NmY0NTQ2NWFhNmI2NDVlYzdkYmQzMmRmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMjcsLTAuMTM1ODMxOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjJhZDg0MDFmODM3NGZiOGI5N2YyMzIxNmU2ZWY2ZmEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0NTkwMDAwMDAwMDUsLTAuMTM2MDQ5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzkwNDRlYThmZWFkMjQ0N2NiNDYwOTRmMWJjZmM5YmE5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDU5MDAwMDAwMDA1LC0wLjEzNjA0OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mZGFjYTU1MjdmYjA0NmFhYjQ1YTQwYjYwN2JlMDM5ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQ1OTAwMDAwMDAwNSwtMC4xMzYwNDldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWEyNjIxNTk5YjRkNDllOGFmN2E4ZWQ3MDIzOWY0ZjggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MzEsLTAuMTM2MTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYTEzMWUxZTYyY2MzNDk5Y2FlZjNkM2MxMmNkY2Q4ZGUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MzEsLTAuMTM2MTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWNhMWRmYjM2ZDkwNGZjOGJmMTJhOTA3Njc5ZjRjOTAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MzEsLTAuMTM2MTRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDc2MThkM2QyNzA5NDM5ZjlmZmJmYTI4ZGQ4ZmY2MDYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MDIsLTAuMTM2MjI4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzU0OGRmYzkzYTQ2OTRmNDNhNmE0ZmVlMjU0MTZiODhkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDAyLC0wLjEzNjIyOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hZTZiN2UzNjRmMjU0MDE4YTZhZTE5MGNiYzQzNTJmNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQwMiwtMC4xMzYyMjhdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNTZjODBlMTgwOWEyNDcxYmE5ZDFjNWMxMGQxOWE1NDAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI1OTMsLTAuMTM0OTk5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2YxZTE3Mjk1ZjE3ZTRjNmE4NGIzZjJjYmY1YWI3MWJlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNTkzLC0wLjEzNDk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lYmRiODJlYzVkOGE0NzZmOTQ1NGYxNTJiNGM4YTAyOSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjU5MywtMC4xMzQ5OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGY3NGFkYjdlNmM5NDQzNDlhMmU1M2RjNTI5YTgyNmUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTI1ODQ5OTk5OTk5OTQsLTAuMTM0NzkzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2M1ZWNmOTRmNTcyMzQyMTY4MWY1ODU5MGIwNmM2Y2EzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNTU1LC0wLjEzNDg5NjAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzliYmNlYmMxZGNhNTRiMGFiOTFlNmQxODc4YjYyZGY5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNTU1LC0wLjEzNDg5NjAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ3OWUzN2VlM2QzNjQ0ZWZhZTFmMjc1MDlmZjI0ZTE1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyNTIxLC0wLjEzNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xN2I4NjBhMmYwNTU0MDg3YmEwZjEwMTY5ZWI0ZTQ2MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzEzNywtMC4xMzM0ODNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjg4MjhlOGQyZjc1NDFlYWI0NTRlOWEwMTZiMDA0NTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMyMjgwMDAwMDAwMDUsLTAuMTMzMjY1MDAwMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjIzY2RmNTE2ZjFhNGJmYTljZTU0YjIyOTQxODZhNGMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMxNTIwMDAwMDAwMDUsLTAuMTMzMjk2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg5NzNmYzE1ZjQxNjQ5MDE5MWEyZDFhNDAzNWYzZWYyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMTUyMDAwMDAwMDA1LC0wLjEzMzI5Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81OTdmNWUzZGMxYTg0NDZiYjk5NTk0NTY4MDQyZmFhNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzI1OCwtMC4xMzI5MzNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTc3YWUzYWExZWUxNDAzZjllM2Q4MWU2ODU1NmZjMjUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM1NDQsLTAuMTMzOTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2JmMDdmMGUwMDI4NjQ2YzNhMjEyMTFjNDk2NWU5NjBmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjI2LC0wLjEzNDA0Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yY2E2Mzc3YmRmYWM0YTIzODU4Mjc0NzliMTQ0MmE4YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzYzNywtMC4xMzQxNTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjFhZTUwMjk3ZDRlNGU3MTg1OWU5NTViM2FkODgzNGEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2MzcsLTAuMTM0MTU2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzZmYmZkYTYxZTA5MDQxZTdiYjJjMmY4YTU0NzFkYWFiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNTI0LC0wLjEzNDA5MTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2M4ODQzYjg1YmY2NjQ3ODliNzJiNThlODY3ZWY5ZWU4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNTI0LC0wLjEzNDA5MTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzA5YmVjZWUwMTExMzRmNzQ4MzFjYjE0YjYwNTgyNjUwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzODIsLTAuMTM0MjcyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzI0ZjY1YjRiMDhmMTQxMGVhOTExZmJiNTUwNWRmY2JlID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzIzOTk5OTk5OTk2LC0wLjEzNDIyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzNhZTE2OWMxZDhjYzQwZGNhYmNlNzZlZDAzOWU3YzZkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzA0LC0wLjEzNDcwNF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82OTFkY2E0ZjA0MjY0ZjE0YTc3M2FjMmJmMzUwMDc5ZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzgzMSwtMC4xMzQ3ODE5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNjZhZDM2MTE1ZWQ0NDhjOWM4MDJlZDdlZmJhZjFmZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzkxNTAwMDAwMDAwNCwtMC4xMzUwMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zODE3ZmVkNGEyNzY0Yjg1YmYxNTZlNDE0ODA5NGE5NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU5NywtMC4xMzQ5MjMwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hMGRjM2ZmYmQ2MjQ0NTNmODEzZGZkOGY2NWQ5MTFjZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDAzMiwtMC4xMzQ4ODQ5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83ODE1YmQzYWEzZjU0YjkwYTAzOTIzYzNiMDY5N2YxMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzg5MSwtMC4xMzQyMTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDM2MTBkZDQzYjU0NDExNWFkNGY5N2ZjNjc4NDBlM2IgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4OTEsLTAuMTM0MjEyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzU3ZmUzZTRlYmQ3ODQxNzliYjExZDcyMDY0Yzg4ZTRkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzODkxLC0wLjEzNDIxMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82MjUwNDVlN2IzMmQ0ZDNhYjg5NmMzNzBmYmM2YjY2MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzg5MSwtMC4xMzQyMTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzMxY2ZjN2VlZDFjNDAzZjhmMWIwNDI0NjE0ZTUwNzkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4OTEsLTAuMTM0MjEyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2UzNDgwM2VhNDEwNzQ2NDA4YmFiZDU3MGIwNjlhMWE0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzU4LC0wLjEzNDEzNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yMDg5MjdjZDgxZDI0MzVhYjY5OWJmNGY1YWJlOGMxYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2NSwtMC4xMzQzNjRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWQ1MGZkMzliM2U4NGEzZTkwN2EzZjdkMmU2MDQ1NTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQxNDYwMDAwMDAwMDQsLTAuMTM0NDQ3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzA0YWE2ZWRkYzk3NjQ2ZWRhOTM4NDcxMDc1NjE1ZDlkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MTQ2MDAwMDAwMDA0LC0wLjEzNDQ0N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNmViYWE2ZjRjMjk0YmY1OWNiYjkzZDA4NWE3NzM5MSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDIwMSwtMC4xMzQ0NzldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDRhZTg0Mjk4MjgwNDM0OThlYThhNzJiYmFiZWUyZmQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQyMDEsLTAuMTM0NDc5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2FjMDM3OWExZjI0ZDRmMDBiYmFmMjM4NTg0MmJjODkxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MjMsLTAuMTM0NjU4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQyMDdiMzMyYTQwYjRiYjZiMWIyN2VhNzAyZDBiMDM0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MzE5LC0wLjEzNDM2NzAwMDAwMDAwMDAxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2M2MzlkYTg1NjQyMDQ4ZDJiZDBhYWEyMWE0OWY0YWVkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0Mzc3LC0wLjEzNDE3OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zODNhMTA3N2FkN2M0OTNlOWVhZTc5NWJhMjg1Y2UzZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDM1NzAwMDAwMDAwNCwtMC4xMzQxNl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84ZmExZjZhYTE1ZmE0ZjExODgzNjFlNzJmZDY4NDJiNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDM4MiwtMC4xMzQwNjldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjRmZGZjOTc2OWJkNGM4MmFhYWI1N2NlYmQwMDllNDggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQzODIsLTAuMTM0MDY5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY4NmQ1YzczYTZlNzQ0MmZiZDVlZTZlNTFjYTgyZjg1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDAyMDAwMDAwMDA0LC0wLjEzNDA4NDk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzc0YzA2YjBhZWM5NzQwMGQ5ZDkyMjllM2NiNDNiM2EyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDAyMDAwMDAwMDA0LC0wLjEzNDA4NDk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2VjMmEwMjY5N2Y2MjQ3Y2Y5YzVhMjljZDNhN2FjZjliID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTIyLC0wLjEzMzgyMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80MjgwYmFiYzBhMjE0OTVkOWIxMTU4MWI0MWEyYzhiMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDUyMiwtMC4xMzM4MjFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMWM4N2U5Njk4YTVhNDg0Zjg0Yzk5OWVkZWZlZjJlY2EgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1MjIsLTAuMTMzODIxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzAxYWUyM2MyYWExZjQ2ZDVhM2MyMzZlNTVmMzk4ODZjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTIyLC0wLjEzMzgyMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kNmYyMDliMmI0YmQ0NzgzODA3MTE1ZWQ5MzZmODM5ZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDUyMiwtMC4xMzM4MjFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTE2ZTNmYWUwNGVhNDY1YmE3MThhMjEzYWU3OWE0OGMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ0OTcsLTAuMTMzOTIyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzRmYjM3MzExYjMyMDQ1NzJhOWU4Y2EzZDFjOTU3ZmZiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDcyLC0wLjEzMzg1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzYzMDljZDM0YjFmZjRiMWZiZTViNTAyNzA5ZmZjZDM5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTAzOTk5OTk5OTk1LC0wLjEzMzcyNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zOTFjZWQ5YzQxMDI0ZDNiOThmYjM3OTU0YTM5NzM0MSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDU0NiwtMC4xMzM3NDVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTFkMTEyYjA1MTMxNDAzNjg4NzUxZmUyOWVlMWYzNTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1NjEsLTAuMTMzNjc2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzcxMTVlZGQ2NDUxZDQ3NDc5ZWJiNDBjNDQyNjQ0MWZjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTYxLC0wLjEzMzY3Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iZmE2ZmQ2MTQ2MTY0ZjUzYjQwMTJiNzBjYmIwZmRmNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDU2MSwtMC4xMzM2NzZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDEzODRjNTBkMTY5NDE2NGIxYWFjMWFkNzJmYjI4ZDggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1NjEsLTAuMTMzNjc2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQwZjY4ZjU1Y2JhMDQyMTFhN2ZlNzZlNGI0M2UwMGUzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTk0LC0wLjEzMzU2MzAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2VjNTQ4YzU3NDBkYzQ5OGNhYTE5ZjhjYTU3ODEyYzU0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTgxLC0wLjEzMzQ2N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85MjE3OWUxZGE4YmM0MDA2Yjg4YTc0NTg0ZWFhOGQwNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDU4MSwtMC4xMzM0NjddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzdlMmIzZTczNDNhNDAzZmEzMjY0MjgwZDM1ZmM2NzYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ2MDYsLTAuMTMzMzkzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzA0ZGNkNzgwZmVjMDQxNjQ5NzM1OWI4ZTVkNmM0YTQ5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE1ODM0MDAwMDAwMDA1LC0wLjEzNDQ3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zY2YyZjEyNjdjYTI0ODUxYmFhYTcwMDNlNTZhMGZiMiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNTE5NSwtMC4xMzUyNTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWRhOGFiZTk1MTkzNDY2YmE4ZGJkNmEyM2Y3YTE0YTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTUxNDksLTAuMTM1Mzk1MDAwMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWFiMzBkNTQ4MmY4NGY2NDk0ODlmODJlMTY5OGFiNWIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ4MTgsLTAuMTM2MDIyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q3YzJmZjEzYzM3NzQ1MTZhY2MyZGYxNzliOWI5NWNiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0ODQzLC0wLjEzNjgwNF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kMTE4NzU5YTNlYWU0M2RiYTZkZjYwMmYxYTgxMGRmMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDg0MywtMC4xMzY4MDRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjI4MjEzMDA1NGVhNDY4Zjk5YTU3NjJmOGNlODdjNTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ4NDMsLTAuMTM2ODA0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2NjZjM3NzdhNDY3ZjRiN2E4YzIwNGRmZmQwNTFlZDkxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0OTE0MDAwMDAwMDA1LC0wLjEzNjU4Mjk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzgzNmUwZmZjNzkyOTQwNGU5MWZjNDY5MjIyNTQ0ZTIzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDk2LC0wLjEzNTY1M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80NjNkYTEwYjc2Y2M0YzhjOTVmNjYwYzAxOGM5OWVmOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDc0MywtMC4xMzU1NzhdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDMxMDk2Y2FhODg3NDE5ZmI3MDA1ZDEyN2FlOWIwYTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ3NDMsLTAuMTM1NTc4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzAzMGM0YjZjMDRmYTRiZGVhYjNkMTg5MjMzYzMwNDE0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDY2OTk5OTk5OTk2LC0wLjEzNDg1OTk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzUzZTE4NTE4YzM4NzQ3YjViNjYxZDNhOGQwZTQ1ZDJmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NDUzLC0wLjEzNDY5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzk3MzgyMjUzZjU5NzQxN2FhNjMxMmIwN2E4ZWNiMjRiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0ODQ1LC0wLjEzNDgxOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zNzQ4MjA5MTJjMmE0MDcyOWM4Yzc5MDJlMDMwZTJjMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDM4OSwtMC4xMzU3MDRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjQ5ZmI2OWE5MjgyNGExZTlmYmUzNGRiOTYyM2QwMDcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQzOTksLTAuMTM1NTYxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Y3M2FkYmJiN2Q1ZDQ3MGNiOTY4NWU4YjBkMTU0ZDhmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MzM0OTk5OTk5OTk2LC0wLjEzNTY0OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mNjJlYjlmMDAwYWM0YmEzYWViYjRlNjBlYzFkNTJmYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDMzNDk5OTk5OTk5NiwtMC4xMzU2NDldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNTNmNDRkYmU5NDNmNDhlZDkxZTI5YTNhOGJjZGEwM2YgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQyMjQsLTAuMTM1NDE1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ4YzQzOWQ4NzliNjQ3ZGY5NzNiYzM5MDYyNmRjZDhjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MjIsLTAuMTM1NTc2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzhkNjQ2MDRmNzMzMDQ1MDk4ZDI2ODIyNjg2NzRmNjNiID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MTQ1LC0wLjEzNTM1N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zYjJiNDcyMTliZTg0YzEzOWZjYmY1Yjg3ZjNmMmI5MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDE0NSwtMC4xMzUzNTddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDllZjczYWQ2YjdlNDg3MTk3OWViYjM4NzFkMDE5YmQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQxMDgsLTAuMTM1NDc1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg3YjUzM2E1MzhhZTQ4NWVhZTlhOTUyMGIwMDljOGQ2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MTA4LC0wLjEzNTQ3NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xOGM1ZDA2NjE5NzI0NGRiYThjYjhhY2E2YjhlYzkzYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDEwOCwtMC4xMzU0NzVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZGQxZmIyZGZmNjZjNDUxNmEyODhmNzdhNmUwYjU0NTUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQzNTkwMDAwMDAwMDYsLTAuMTM2MjI1OTk5OTk5OTk5OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTg2ZmU0NWUwNDVjNGFmYmI2YjY0ZmQ1OGM2ODk2NDUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQzNTkwMDAwMDAwMDYsLTAuMTM2MjI1OTk5OTk5OTk5OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYTkzYzllMzJlMGY2NDZjY2IwOGFkNDdmNWQ4MDhlNjIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQzMjYwMDAwMDAwMDQsLTAuMTM2MzI4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzE0MzgyYTFmZWZkNDQwZjY5YmQ2N2UwYWQwZWQ2NjY0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTQ0LC0wLjEzNjIyMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mZDEzZDM3NzJkZmE0YTRmODkzNDY1YTc1NTgxNjAzNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDU2OSwtMC4xMzYxMTcwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81YWQwMjI4OTY4OWI0MTM1ODUzNDcxODU1ZTBlYWE4NyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDU4NiwtMC4xMzYwMjk5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kMGFkOGVkMzNhZjA0M2NlYmFhMmU0NmYzZGQ4ZmQ0ZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDYxMiwtMC4xMzYyNjZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzEzYWExMGZiMmZlNDYwZGExMTBkMGJhNGI0NjAwMTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1NzUsLTAuMTM2NDIxMDAwMDAwMDAwMDFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfODc4MzYyODVlNTVlNGEwY2EyNmMxMDBiYTU1MjkzYTAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1NzUsLTAuMTM2NDIxMDAwMDAwMDAwMDFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYWFhMThmZjcwZWIxNDEzNjkwOWNkYjliMjMwZDA3MjEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ1MDcsLTAuMTM2OTM1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg2YzU4ODUyYTc1YjRhMjc4ZjRlODFhZWUxMzVkNDFhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTA3LC0wLjEzNjkzNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iYTg1NmQwNzRmMzU0ZTJmOGFjZTc1N2UyNGM2NDc4MyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDUwNywtMC4xMzY5MzVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTI1ZDc2NjQ4NjFiNDZiNDgyODk0Njk4ZGRmYmViMzIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQyNzQsLTAuMTM2OTMxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzc2NWI0NTMzNDllNjRmMzg5ZDdhZTA2ZWNmNmYyMjExID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0Mjc0LC0wLjEzNjkzMV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83NTliMGY2NmQxMmM0Y2RjOGZlZDM3YWMwNGUyMGE4ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDI3NCwtMC4xMzY5MzFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDlkZDlmMTU2MjBiNGIwMzkxZTJmYjg2YjUzZTMyYTcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQyOTMsLTAuMTM2Nzk5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2I2MTUzM2RjM2NjMDQ0Nzg4Yzc2NTg5NjcwMjk2ZjNmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MDU4LC0wLjEzNjc3OTk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzEwYzMxMTM0ZTFjZTRmMTI5ODIwMjExNWVjYjU5Yzc5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MTQ4LC0wLjEzNjY5Nl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84OTY5NzRmOTg3MWE0ZTI5OTg3NmIyYjExOWMzZWU0MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDE0OCwtMC4xMzY2OTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNmU3OTcwNzllZWNmNGRjMDk1NDVhZmVmYjk2MDNkOTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQxNDgsLTAuMTM2Njk2XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2RhYThlMDEwMmIxMTQ1YTg4M2RhYmI4MmFhNGI3ZjIwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzOTYxLC0wLjEzNjcxMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85MjQ0N2YwNGUwMzk0MTE0YTczZDkzMGIzOTYwYmZmNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDAyNywtMC4xMzYxMjNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTgwZTM2ZTQ1NWJiNGFmYjk5YmMxMWE4OGRlODkyNmUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQwNzYsLTAuMTM1OTU4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2YxYTBhODE5MGI3YjRjZmI5M2EzMDJiOGE5N2M3ZTA5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0MDk2LC0wLjEzNTg4M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wMDUxODVkMGI1M2Q0MTFlOWQ2YmMzNDRlYWE0Y2I0NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDEzNDAwMDAwMDAwNiwtMC4xMzU3ODgwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81YzkwODFhNTMzNjg0Y2NhYTkwYTljYmYzOWQyMTdjYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDEzNDAwMDAwMDAwNiwtMC4xMzU3ODgwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jODM0ODU0OTIyYmE0YmRjYTdhYWIxMTgwYzk2Yjk3OSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDAzMzAwMDAwMDAwNSwtMC4xMzU4NDldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjk1NzM5ZGZhNTY3NDQxY2EwOWE5MTU5Mjk2M2Y1ZTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQwMzMwMDAwMDAwMDUsLTAuMTM1ODQ5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q2NzkxZjkwN2I3NzQ2MTY5ZmViMDY3MDJlZTdmNjlkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzOTk2LC0wLjEzNjAwOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xYmEwNWQ1Y2UzMTA0YWMwOTMyYzVkZDRhNzQyOWJkMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk5NiwtMC4xMzYwMDhdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmI4NmVkNmM2MjM2NDc2Njg1NTBjYjc5ZDMwNjQ0YmYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM5OTYsLTAuMTM2MDA4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzNmNzA1MjY4M2Y4MjQ0ZDg5NzkxOTJlOTBlZjcwZGFhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzOTk2LC0wLjEzNjAwOF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hMmQ2MDIwYmU3MDY0ZTcwODNhNGJmNzRjOTRjYzcyYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk2LC0wLjEzNjA5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mMWEzMDdmMjAwMzk0M2Y4ODU1YWZmMjQwYTAxY2NlYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk2LC0wLjEzNjA5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jNTFmODg5OGZlMzg0ZTUzODkwY2ZkNGJlYTQyMThmYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk2LC0wLjEzNjA5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83OWViYjExYWZhM2I0YzY3YTZkOTM4NDRmNDE4MDNlZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk2LC0wLjEzNjA5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xZmVmYTdkMWNmODE0YjgyYTU1OGQ0YjFmMDY3MWUwZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk2LC0wLjEzNjA5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wYzkxOTE3M2NhNGY0MmZmYjkzMzliNzFiZGIxNWRjMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk0NSwtMC4xMzYxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hMWM3YTg1Y2QzMTA0ZTAxODZlNTk5NDFiZjM1NDI2ZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk0NSwtMC4xMzYxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84ODU5ZThiMGZlMWI0ZWU5YmIyYjMyNjFjMDg2M2E1OCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzgyMSwtMC4xMzU0ODVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjRiYTAyMzM2NTRkNDcwYzllNDhiN2Q2ZjE4ZGRiYjMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4MjEsLTAuMTM1NDg1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ3YjBiNjVjYzdlZDQxNmI5MGZhM2I3MTgwYTQ0YmI3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzODIxLC0wLjEzNTQ4NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jMjhmYzIyNWUyNjk0YjFkYjk1MjNhNTBiOGYyMDBiNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzgyMSwtMC4xMzU0ODVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTBmMzcyNjY3ODkwNDI1NTlmYjRiNWQxYTFmN2QxNjcgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4MjEsLTAuMTM1NDg1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQzNzQxYzU2ZmMxMDRiN2I5ZGQ4YTM0YTcxMjZjNzE3ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzOTk5LC0wLjEzNTM3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iMThiZWQ1ZmM4N2U0NTFjYTM3MmQzYjM5Y2NiNTg1YyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk5OSwtMC4xMzUzNzRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjYzZjY3YmRiNzAxNDBjMTkxNWViOWZlMDIzZDM5NmEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM5OTksLTAuMTM1Mzc0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzZlOGFiNDA2NGUwMjQ0OWE5NTNlOTA5NzVhOWM1OTQxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzOTk5LC0wLjEzNTM3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81MGE3MGQ0YzQyMmY0MWQyOTVlZDg2NTcyZTg1ZjVkYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzk5OSwtMC4xMzUzNzRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDgxYjY4NWRiOTNmNDg0Zjk0MjIyNjI4ZGY4MmE0NmEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3OTUsLTAuMTM1NTgxOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMjRkNTBlYjNkNjkyNDhjYzlmMDVmNTI2YTY3YTk3ZWMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3OTUsLTAuMTM1NTgxOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfY2NmM2FkYmMwMzI5NDMyYmFiYzM2YmNhN2ZhYjRjZjUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3OTUsLTAuMTM1NTgxOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZTIyNWFiNzZjMDBiNDNkYTkzMDBiNDVjYTM4N2ZkNGIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3NjYsLTAuMTM1Njc5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzg5NTU3OTA2NjZlNDRmZWZhZWIyZDhhNjViMTJmYzkwID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzY2LC0wLjEzNTY3OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82YmYxOWQyOTk2Y2I0OTdkYWI5YzJiY2FkNzU3MjBhNyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzc2NiwtMC4xMzU2NzldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTI2ZTE1Yjc1MzJlNDk3YjhmNjNlY2FhOTllZjE3NGIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3MjYsLTAuMTM1ODE0MDAwMDAwMDAwMDJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfN2E5NTMyMjdiZTc5NGJmOTg3MjNlMmEwM2FiZTIzZGIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2OTIsLTAuMTM1OTA1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzQ5NmI0YmI5OTlmOTRhZTQ4YmNiNWVhOGM1M2RmOWU0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjkyLC0wLjEzNTkwNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xNzdhZTE1MDEwODA0YzAyYjg4YmU0NTg1NDQ0ODY0OCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzY5MiwtMC4xMzU5MDVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTM4YTM3NjZkYjdlNDViNmI3YzRjNDk0OWJhNzBmZDUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2OTIsLTAuMTM1OTA1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzcxYzZmM2E1YmE2ZTRhZjRhZmEyYjA0NGFhNWUxYTQzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjkyLC0wLjEzNTkwNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9iMTAwNmUwNDA2MjA0ZDdkOTE0NjQ3ZWEzOTUyNTViYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzY3MiwtMC4xMzU5OTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfY2ExMDg5Y2M1ZmViNDg4OTk1NDU3NDMwMTljNTI5NmMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2NzIsLTAuMTM1OTkyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzZkNjQxNGFkMTFhZjQ0NTg5NjNhYjBmYTA5MDNiN2Q1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjcyLC0wLjEzNTk5Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jMGY3YjU0YTJiZDk0YjA1YjRlNzQ2YmViZDNmNWVhMSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzY3MiwtMC4xMzU5OTJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzFjYjA4YTk2Nzc5NDA5OTljZTdjOWVmYzk1YzkxNzUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2MDMsLTAuMTM2MjE3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2VlMzRiYWNiMjAyYzQyZTZiNDk2ZTI0NGIxYjhhY2Y1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNjAzLC0wLjEzNjIxN10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83NDA3YjdiZTM3Mjk0ODQwODNkNjJkZmRmNDI0MGYzMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzYwMywtMC4xMzYyMTddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWNhZWJlZTgwOTM0NGM4NWEzMTI3ZjIwYTFlOGIyM2EgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2MDMsLTAuMTM2MjE3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2IwY2Q2YmMyYTU0ZTRkNTlhNDYxNzIzNzAwN2I0N2YxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDgyLC0wLjEzNjU3OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NmI2NDU5MmI5ZWU0ZTc1OTQxZDJmZjJmYzI4ZTI0OCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQ1OCwtMC4xMzY2NzVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTRlMmY3ZDQ4MzhkNDk0OTkzYzhhMWVmZDZjNTVhMTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0NTgsLTAuMTM2Njc1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2Q0MGE5NmEzOTJiZDQxMDdiZTc1NzNmZjBlNjY3OWI4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDU4LC0wLjEzNjY3NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83ZTJhYThmNGYwNzg0ZGQ3YjgxNjZjMDc3ZWQ4NTI1MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQ1OCwtMC4xMzY2NzVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNDE5MmM5M2Y2YThlNGM1YzhiMmViYzBlZDk1NGM0ZTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0Mjg5OTk5OTk5OTUsLTAuMTM2NzY0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzdlNjE2NjVjMGNmODRkMmNiNjk2ZGNjNGI3NGU3ZWI5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNDA0LC0wLjEzNjg3N10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81NDMwZDIzNzNhMTU0OWIwOWRjMzUxMTQzNjQ5YTBkMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzQwNCwtMC4xMzY4NzddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZmM0MmZkODJlNmFjNGFlOGFlOWNlZDdiMDE0MTI1OTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM0MDQsLTAuMTM2ODc3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzUzZDU5NWRlN2NiMTRjZDE5NzU1ODZkOGFiMjM4OTc5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMzU5LC0wLjEzNjk1M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85ZGJiNmU5ZDFiM2Y0N2NmYjg4YmM4Njc4OWNkYTFiYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzM1OSwtMC4xMzY5NTNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOTUxMWNjODZiNzkzNGJlZDhmMzUwMmEyMzhmYjBhY2EgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTMzNzgsLTAuMTM3MjNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYzU1NjBlZGIzMzk0NDVkYTlmNWNlMmEwOTcxOTE1OTMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4NTUsLTAuMTM2NjUxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2I4NTdkNzZmNGJmYTQ3ZDc4ZDQxMDNkNzEwYmRkOTcyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzODU1LC0wLjEzNjY1MV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81ZTNmZjZhMDE0N2U0NGQ4ODY4ZDE2YjkwMDkxMGY5OSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzg3NSwtMC4xMzY1MDI5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84ZjVlZGM4ZTg1OTU0MDk3YmY3MGQ2MzA4ZTFmNjVhNCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzU2NSwtMC4xMzczNjcwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lMTRmOTY3NGU4YTc0OGY5YWUxODAwMmFjODZiNDI2YyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzYxNiwtMC4xMzc0MjIwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kOGViMTUxNmQwZmU0ZGQ5OGNkY2EyYWVlMDcwMmU2MCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzYxNiwtMC4xMzc0MjIwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jYTgwOTJkOWIwMzE0ODFiYWRmZGIxMGU5NTM5MWMxMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzc0MiwtMC4xMzc0NzJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfODBiMDYyZGMyM2M3NDViOGJiNzY1MWNmODgyOGMwYzQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3NDIsLTAuMTM3NDcyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzE0YTY5MzNjNjMzYjQwMDM5MTMwOGVmMjgyNWUwOWI4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzQyLC0wLjEzNzQ3Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl84NTFiNDZlN2U5ZTk0YTY2OWRiNjg1OGY5ZTgxZWE1NyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzkxOCwtMC4xMzgzXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzMwMDhhMzU1MWFiODRlYzBiMjI3YjRiMTQ5MWU3NzNmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzcxOTk5OTk5OTk2LC0wLjEzNzM2M10sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80OGVlMmNmNGNhOTQ0NGNlOGZkYzIwM2EwYTkwMjQzMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzUwMiwtMC4xMzc5OTVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfODgyNzM4N2JjZmUyNDg5ZWIxYTIzNWU1NWEyMGI4MTQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM1MDIsLTAuMTM3OTk1XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2NiYTc2ZDdiMWFlZDQwYjNiOTA1MDAzNjJkYjA2ZDU5ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNTAyLC0wLjEzNzk5NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8wMmMwODM0YzMwNjM0YjFjOTE4YjQwYjNmNzllODk4YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzUwMiwtMC4xMzc5OTVdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzNiZGMzNTQzMTJjNGM5OGE4NjBmZjA0ZGFhZjNmNTQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM3MTIsLTAuMTM4MTM5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzI3MjNhNTk3N2M0ODQ1OTc4Njk4ZjliNWU3MjFiNGM0ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzEyLC0wLjEzODEzOV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8xYzVlNWEyMWFjYzE0ZDMwYmYxNDdkNzc1MWYyODk2NiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMzY0NCwtMC4xMzgyMzldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDZlNWM0ZWRhYjE5NGNhMWJiZWU2ZTUxNDIyODEzYTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM2NDQsLTAuMTM4MjM5XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2IzMjI2OWQxMGJkNzQ4MTZhMjY1NjBlOTJhNWJmZGIxID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzNzExLC0wLjEzODI3Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl80YjMyMTU1YjMxYzc0ZDQ3YjU1YTlkMWJhOTMyNjBjOSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2MSwtMC4xMzgwODI5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82ZGY2NjI0ZGI1ZTU0NDI4OTFiY2U4OGE3MTNkMzc0NSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2MSwtMC4xMzgwODI5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yYTU5ZDJkM2U4OGU0NThkODM3ZjcxZDMzNjUxM2JhZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2MSwtMC4xMzgwODI5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85YjM3NDg0N2E5ZDg0MWEyYjZjYWIxMDJmNTAzN2M2YSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2MSwtMC4xMzgwODI5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl81ODU2ZTZmNjkxZDM0YTYzOGM1NDUwMzYyMWRhYmUyYSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDA2MSwtMC4xMzgwODI5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl85MzU1MjRlZGU5NjA0YTI2ODI3YWJlZTgzNDYwODVjNSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDc0OCwtMC4xMzc5MTE5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82NWVmNmVkYzNlMTY0MWI4ODRlYjAyMWZjZjQzZjk2ZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDc0OCwtMC4xMzc5MTE5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zYjA3Y2FiMjRkZGQ0MmUyYmNjMTgwNjc0YTMxYTdiMyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDc0OCwtMC4xMzc5MTE5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9hNDcxM2NmNWMzZDk0NGIxYTk0ZTk3Yzc2Mjc0OGEzZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDc5NCwtMC4xMzc3MDddLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZWIyMjc1NzQ0YmNhNDkzODk3MGU3ODIwOTY0ZjgwOTEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTQ3OTQsLTAuMTM3NzA3XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzA4N2FiNWU3NmIxZjRiYWI4MjMyMjE1NjcwYzMwNjkyID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTI2MDAwMDAwMDA0LC0wLjEzNzEwNzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzhhM2ZhZTVkNmM2MjRlNTI5YjczZmNkZjc3NDU5ZDBmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTI2MDAwMDAwMDA0LC0wLjEzNzEwNzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2ViYTVmZjRhZWRhMDQzZTJiYTFmN2M1OWVhZWQxODk1ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NTI2MDAwMDAwMDA0LC0wLjEzNzEwNzk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzY1YWE5NDcwMDI3MzQ4MTM4YTg4ZGVmYzk0M2QzMTU2ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NzA2LC0wLjEzNzA2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzc1OWE0N2FlNjg2ODQyNzFiZDQ4MDdiNTE0Y2YwYWZkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTE0NzA2LC0wLjEzNzA2NTAwMDAwMDAwMDAyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzUzYmExZTJmMzFlYjQ0NDhhMDg4ZDEyMGU0MjY4YzY4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEyMzExLC0wLjEzODQ3NF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJyZWQiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICJyZWQiLAogICJmaWxsT3BhY2l0eSI6IDAuMiwKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAwLjQsCiAgInJhZGl1cyI6IDgsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl82MjkxNzlhODdmZGY0M2U0YjBmZjMyMjFlOGQ4ZmFjYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMTk5OCwtMC4xMzgxMjNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAicmVkIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAicmVkIiwKICAiZmlsbE9wYWNpdHkiOiAwLjIsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMC40LAogICJyYWRpdXMiOiA4LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYzk1MTE3ODY0MTM0NGRiODhkMTE5OTEwMTcwYmM2ZmIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTE4NTYsLTAuMTM3NzYyXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogInJlZCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogInJlZCIsCiAgImZpbGxPcGFjaXR5IjogMC4yLAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDAuNCwKICAicmFkaXVzIjogOCwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCgogICAgICAgICAgICB2YXIgbWFya2VyXzcwYmZhYTY3YzYwZDRhNzNhOWRjYmFhZTkwNGIzODNkID0gTC5tYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTEzMzQxLC0wLjEzNjY2OF0sCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgaWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2EyNWE5YTA0MzJmNTRkYzdiMDcwYzM2NWQ3NDQ0OTRiID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzNjOWE3YjdlNjlkODQ5M2JhZTZhNmE1NmJlMGFkZTEwID0gJCgnPGRpdiBpZD0iaHRtbF8zYzlhN2I3ZTY5ZDg0OTNiYWU2YTZhNTZiZTBhZGUxMCIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+QnJvYWQgU3QuPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF9hMjVhOWEwNDMyZjU0ZGM3YjA3MGMzNjVkNzQ0NDk0Yi5zZXRDb250ZW50KGh0bWxfM2M5YTdiN2U2OWQ4NDkzYmFlNmE2YTU2YmUwYWRlMTApOwogICAgICAgICAgICAKCiAgICAgICAgICAgIG1hcmtlcl83MGJmYWE2N2M2MGQ0YTczYTlkY2JhYWU5MDRiMzgzZC5iaW5kUG9wdXAocG9wdXBfYTI1YTlhMDQzMmY1NGRjN2IwNzBjMzY1ZDc0NDQ5NGIpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKCiAgICAgICAgICAgIHZhciBtYXJrZXJfZGIxNGJhNjkwODZjNDk4NWFmMjU3MmMxZGFjNDVmYjkgPSBMLm1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MTM4NzYsLTAuMTM5NTg2XSwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBpY29uOiBuZXcgTC5JY29uLkRlZmF1bHQoKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIC5hZGRUbyhtYXBfMjkwNDU3NTQ2ZDcwNDk2MGI4MDg1ZmM5NGM1YjAyOTYpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfNjAwZWQ5YjI4MjYxNDA0Y2FhNzNjODJjNjhhNDMzMDEgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMGE2MTA5ZWU5MzEzNDBhMjg3ZGFhNjIyZmQ1OWZjMDAgPSAkKCc8ZGl2IGlkPSJodG1sXzBhNjEwOWVlOTMxMzQwYTI4N2RhYTYyMmZkNTlmYzAwIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5Dcm93biBDaGFwZWw8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzYwMGVkOWIyODI2MTQwNGNhYTczYzgyYzY4YTQzMzAxLnNldENvbnRlbnQoaHRtbF8wYTYxMDllZTkzMTM0MGEyODdkYWE2MjJmZDU5ZmMwMCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgbWFya2VyX2RiMTRiYTY5MDg2YzQ5ODVhZjI1NzJjMWRhYzQ1ZmI5LmJpbmRQb3B1cChwb3B1cF82MDBlZDliMjgyNjE0MDRjYWE3M2M4MmM2OGE0MzMwMSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgdmFyIG1hcmtlcl8zYWFmMmZkY2NkYmY0NGI1ODY1M2ZmMmI0ZTEyY2FkMCA9IEwubWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxNDkwNTk5OTk5OTk5NiwtMC4xMzk2NzEwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgaWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2ZhM2RjYzRiYzMzMTQzNWRiNDk3M2M4ODlmYjQxZjQzID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzA0MThjNTRmZWZjZTQwZGU5NWNiZTk1N2MyMjhkMzUyID0gJCgnPGRpdiBpZD0iaHRtbF8wNDE4YzU0ZmVmY2U0MGRlOTVjYmU5NTdjMjI4ZDM1MiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+R3QgTWFybGJvcm91Z2g8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2ZhM2RjYzRiYzMzMTQzNWRiNDk3M2M4ODlmYjQxZjQzLnNldENvbnRlbnQoaHRtbF8wNDE4YzU0ZmVmY2U0MGRlOTVjYmU5NTdjMjI4ZDM1Mik7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgbWFya2VyXzNhYWYyZmRjY2RiZjQ0YjU4NjUzZmYyYjRlMTJjYWQwLmJpbmRQb3B1cChwb3B1cF9mYTNkY2M0YmMzMzE0MzVkYjQ5NzNjODg5ZmI0MWY0Myk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgdmFyIG1hcmtlcl8zNWUxNThhZWMxMDg0YzE4OGVhMDA5NjMwYzgyMTNmNyA9IEwubWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjM1Mzk5OTk5OTk5NSwtMC4xMzE2M10sCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgaWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzRhNjUyNjk0MmU3YzQyNDg5M2M0MDc4MWE2YzJlMGVkID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzU0ZmU1ZDQyZmZhZDQyYmVhNDk0MjEzZjU0ODI5NDcyID0gJCgnPGRpdiBpZD0iaHRtbF81NGZlNWQ0MmZmYWQ0MmJlYTQ5NDIxM2Y1NDgyOTQ3MiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+RGVhbiBTdC48L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzRhNjUyNjk0MmU3YzQyNDg5M2M0MDc4MWE2YzJlMGVkLnNldENvbnRlbnQoaHRtbF81NGZlNWQ0MmZmYWQ0MmJlYTQ5NDIxM2Y1NDgyOTQ3Mik7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgbWFya2VyXzM1ZTE1OGFlYzEwODRjMTg4ZWEwMDk2MzBjODIxM2Y3LmJpbmRQb3B1cChwb3B1cF80YTY1MjY5NDJlN2M0MjQ4OTNjNDA3ODFhNmMyZTBlZCk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgdmFyIG1hcmtlcl84ZjcxMGRjNmIzZDU0OTRjODVkZDkyY2EyZWViYzQwNiA9IEwubWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMjEzOTAwMDAwMDAwNSwtMC4xMzM1OTQwMDAwMDAwMDAwMl0sCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgaWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzdkZTE4NDEyNDI2ODQwNzY5NWEyNzk3M2M5NWM3ZjI2ID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2ExNDA1YTRmYzY2ZTQxODU5NWE4ODlmZjRjYWUwNmUzID0gJCgnPGRpdiBpZD0iaHRtbF9hMTQwNWE0ZmM2NmU0MTg1OTVhODg5ZmY0Y2FlMDZlMyIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+U28gU29obzwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfN2RlMTg0MTI0MjY4NDA3Njk1YTI3OTczYzk1YzdmMjYuc2V0Q29udGVudChodG1sX2ExNDA1YTRmYzY2ZTQxODU5NWE4ODlmZjRjYWUwNmUzKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBtYXJrZXJfOGY3MTBkYzZiM2Q1NDk0Yzg1ZGQ5MmNhMmVlYmM0MDYuYmluZFBvcHVwKHBvcHVwXzdkZTE4NDEyNDI2ODQwNzY5NWEyNzk3M2M5NWM3ZjI2KTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICB2YXIgbWFya2VyXzg5ODQ4N2U5OTg2ZjRmNjZiMWNlZGEwNzA5ODYzNTkzID0gTC5tYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTExNTQyLC0wLjEzNTkxOV0sCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgaWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2MwZTUwZGMxYzE2YjQ5MTZhMzFlOWNhYmY5NzE5ODNhID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2IyMjA1NjZkYmNlZTQxZWU4ZmNiMWM0YjA5OTQ4NjdmID0gJCgnPGRpdiBpZD0iaHRtbF9iMjIwNTY2ZGJjZWU0MWVlOGZjYjFjNGIwOTk0ODY3ZiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+QnJpZGRsZSBTdC48L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2MwZTUwZGMxYzE2YjQ5MTZhMzFlOWNhYmY5NzE5ODNhLnNldENvbnRlbnQoaHRtbF9iMjIwNTY2ZGJjZWU0MWVlOGZjYjFjNGIwOTk0ODY3Zik7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgbWFya2VyXzg5ODQ4N2U5OTg2ZjRmNjZiMWNlZGEwNzA5ODYzNTkzLmJpbmRQb3B1cChwb3B1cF9jMGU1MGRjMWMxNmI0OTE2YTMxZTljYWJmOTcxOTgzYSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAoKICAgICAgICAgICAgdmFyIG1hcmtlcl85ODFiNmY1NWE0MmU0MDZiYjcwZDM0Zjk4NDI0YTVkMyA9IEwubWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUxMDAxOSwtMC4xMzM5NjJdLAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGljb246IG5ldyBMLkljb24uRGVmYXVsdCgpCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgLmFkZFRvKG1hcF8yOTA0NTc1NDZkNzA0OTYwYjgwODVmYzk0YzViMDI5Nik7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF82YjU4MGUzMjAwNzk0ZDVjOWFmNzE3ZWU2MGRiMTZhMSA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF8yOTM0MWJiOGE1ZWQ0YmM5ODE1MGRiNTQ4MTM4NWEwZSA9ICQoJzxkaXYgaWQ9Imh0bWxfMjkzNDFiYjhhNWVkNGJjOTgxNTBkYjU0ODEzODVhMGUiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkNvdmVudHJ5IFN0LjwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNmI1ODBlMzIwMDc5NGQ1YzlhZjcxN2VlNjBkYjE2YTEuc2V0Q29udGVudChodG1sXzI5MzQxYmI4YTVlZDRiYzk4MTUwZGI1NDgxMzg1YTBlKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBtYXJrZXJfOTgxYjZmNTVhNDJlNDA2YmI3MGQzNGY5ODQyNGE1ZDMuYmluZFBvcHVwKHBvcHVwXzZiNTgwZTMyMDA3OTRkNWM5YWY3MTdlZTYwZGIxNmExKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCgogICAgICAgICAgICB2YXIgbWFya2VyXzNmZjI0MDNlMTJhZjQ1OWI4YWFhNTc1OGRiNjc4NWNhID0gTC5tYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTExMjk1MDAwMDAwMDA0LC0wLjEzODE5OV0sCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgaWNvbjogbmV3IEwuSWNvbi5EZWZhdWx0KCkKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAuYWRkVG8obWFwXzI5MDQ1NzU0NmQ3MDQ5NjBiODA4NWZjOTRjNWIwMjk2KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzg5MDgzMmI3MmMyYzRjZTBiMzI3OTE2ZGUyZjRiZTNiID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2FiZjUwNjhhMjU4NjQ5ZmE5OWM0NmE0ZGNjN2Y0ODMyID0gJCgnPGRpdiBpZD0iaHRtbF9hYmY1MDY4YTI1ODY0OWZhOTljNDZhNGRjYzdmNDgzMiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+V2Fyd2ljazwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfODkwODMyYjcyYzJjNGNlMGIzMjc5MTZkZTJmNGJlM2Iuc2V0Q29udGVudChodG1sX2FiZjUwNjhhMjU4NjQ5ZmE5OWM0NmE0ZGNjN2Y0ODMyKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBtYXJrZXJfM2ZmMjQwM2UxMmFmNDU5YjhhYWE1NzU4ZGI2Nzg1Y2EuYmluZFBvcHVwKHBvcHVwXzg5MDgzMmI3MmMyYzRjZTBiMzI3OTE2ZGUyZjRiZTNiKTsKCiAgICAgICAgICAgIAogICAgICAgIAo8L3NjcmlwdD4= onload=&quot;this.contentDocument.open();this.contentDocument.write(atob(this.getAttribute(&#39;data-html&#39;)));this.contentDocument.close();&quot; allowfullscreen webkitallowfullscreen mozallowfullscreen&gt;&lt;/iframe&gt; 6. You know nothing, John Snow! (again) . So, John Snow finally had his proof that there was a connection between deaths as a consequence of the cholera outbreak and the public water pump that was probably contaminated. But he didn&#39;t just stop there and investigated further. . He was looking for anomalies now (we would now say &quot;outliers in data&quot;) and found two in fact where there were no deaths. First was brewery right on the Broad Street, so he went there and learned that they drank mostly beer (in other words not the water from the local pump, which confirms his theory that the pump is the source of the outbreak). The second building without any deaths was workhouse near Poland street where he learned that their source of water was not the pump on the Broad Street (confirmation again). The locations of both buildings are visualized also on the map on the left. . He was now sure, and although officials did not trust him nor his theory they removed the handle to the pump next day, 8th of September 1854. John Snow later collected and published in his famous book also all the data about deaths in chronological order, before and after the peak of the outbreak and we will now analyze and compare the effect when the handle was removed. . dates = pd.read_csv(&#39;datasets/dates.csv&#39;, parse_dates=[&#39;date&#39;]) # Set the Date when handle was removed (8th of September 1854) handle_removed = pd.to_datetime(&#39;1854/9/8&#39;) # Create new column `day_name` in `dates` DataFrame with names of the day dates[&#39;day_name&#39;] = dates[&#39;date&#39;].dt.weekday_name # Create new column `handle` in `dates` DataFrame based on a Date the handle was removed dates[&#39;handle&#39;] = dates[&#39;date&#39;] &gt; handle_removed # Check the dataset and datatypes dates.info() # Create a comparison of how many cholera deaths and attacks there were before and after the handle was removed dates.groupby([&#39;handle&#39;]).sum() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 43 entries, 0 to 42 Data columns (total 6 columns): order 43 non-null int64 date 43 non-null datetime64[ns] attacks 43 non-null int64 deaths 43 non-null int64 day_name 43 non-null object handle 43 non-null bool dtypes: bool(1), datetime64[ns](1), int64(3), object(1) memory usage: 1.8+ KB . order attacks deaths . handle . False 231 | 528 | 500 | . True 715 | 43 | 116 | . 7. The picture worth a thousand words . . Removing the handle from the pump prevented any more of the infected water from being collected. The spring below the pump was later found to have been contaminated with sewage. This act was later recognized as an early example of epidemiology, public health medicine and the application of science (the germ theory of disease) in a real-life crisis. . A replica of the pump, together with an explanatory and memorial plaque and without a handle was erected in 1992 near the location of the original close to the back wall of what today is the John Snow pub. The site is subtly marked with a pink granite kerbstone in front of a small wall plaque. . We can learn a lot from John Snow&#39;s data. We can take a look at absolute counts, but this observation could lead us to a wrong conclusion so let&#39;s take a different look on the data using Bokeh. . Thanks to John Snow we have the data in chronological order (i.e. as time series data), so the best way to see the whole picture is to visualize it and look at it the way he saw it while writing On the Mode of Communication of Cholera (1855). . import bokeh from bokeh.plotting import output_notebook, figure, show output_notebook(bokeh.resources.INLINE) # Set up figure p = figure(plot_width=900, plot_height=450, x_axis_type=&#39;datetime&#39;, tools=&#39;lasso_select, box_zoom, save, reset, wheel_zoom&#39;, toolbar_location=&#39;above&#39;, x_axis_label=&#39;Date&#39;, y_axis_label=&#39;Number of Deaths/Attacks&#39;, title=&#39;Number of Cholera Deaths/Attacks before and after 8th of September 1854 (removing the pump handle)&#39;) # Plot on figure p.line(dates[&#39;date&#39;], dates[&#39;deaths&#39;], color=&#39;red&#39;, alpha=1, line_width=3, legend=&#39;Cholera Deaths&#39;) p.circle(dates[&#39;date&#39;], dates[&#39;...&#39;], color=&#39;black&#39;, nonselection_fill_alpha=0.2, nonselection_fill_color=&#39;grey&#39;) p.line(dates[&#39;date&#39;], dates[&#39;...&#39;], color=&#39;black&#39;, alpha=1, line_width=2, legend=&#39;Cholera Attacks&#39;) show(p) . Loading BokehJS ... KeyError Traceback (most recent call last) /var/lib/python/site-packages/python3.6/pandas/core/indexes/base.py in get_loc(self, key, method, tolerance) 3077 try: -&gt; 3078 return self._engine.get_loc(key) 3079 except KeyError: pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc() pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc() pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item() pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item() KeyError: &#39;...&#39; During handling of the above exception, another exception occurred: KeyError Traceback (most recent call last) &lt;ipython-input-87-46223feacc67&gt; in &lt;module&gt; 9 10 # Plot on figure &gt; 11 p.line(dates[&#39;date&#39;], dates[&#39;...&#39;], color=&#39;red&#39;, alpha=1, line_width=3, legend=&#39;Cholera Deaths&#39;) 12 p.circle(dates[&#39;date&#39;], dates[&#39;...&#39;], color=&#39;black&#39;, nonselection_fill_alpha=0.2, nonselection_fill_color=&#39;grey&#39;) 13 p.line(dates[&#39;date&#39;], dates[&#39;...&#39;], color=&#39;black&#39;, alpha=1, line_width=2, legend=&#39;Cholera Attacks&#39;) /var/lib/python/site-packages/python3.6/pandas/core/frame.py in __getitem__(self, key) 2686 return self._getitem_multilevel(key) 2687 else: -&gt; 2688 return self._getitem_column(key) 2689 2690 def _getitem_column(self, key): /var/lib/python/site-packages/python3.6/pandas/core/frame.py in _getitem_column(self, key) 2693 # get column 2694 if self.columns.is_unique: -&gt; 2695 return self._get_item_cache(key) 2696 2697 # duplicate columns &amp; possible reduce dimensionality /var/lib/python/site-packages/python3.6/pandas/core/generic.py in _get_item_cache(self, item) 2487 res = cache.get(item) 2488 if res is None: -&gt; 2489 values = self._data.get(item) 2490 res = self._box_item_values(item, values) 2491 cache[item] = res /var/lib/python/site-packages/python3.6/pandas/core/internals.py in get(self, item, fastpath) 4113 4114 if not isna(item): -&gt; 4115 loc = self.items.get_loc(item) 4116 else: 4117 indexer = np.arange(len(self.items))[isna(self.items)] /var/lib/python/site-packages/python3.6/pandas/core/indexes/base.py in get_loc(self, key, method, tolerance) 3078 return self._engine.get_loc(key) 3079 except KeyError: -&gt; 3080 return self._engine.get_loc(self._maybe_cast_indexer(key)) 3081 3082 indexer = self.get_indexer([key], method=method, tolerance=tolerance) pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc() pandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc() pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item() pandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.PyObjectHashTable.get_item() KeyError: &#39;...&#39; . 8. John Snow&#39;s myth &amp; Did we learn something? . . From the previous interactive visualization, we can clearly see that the peak of the cholera outbreak happened before removing the handle and it was already in decline (downside trajectory) before the 8th of September 1854. . This different view on the data is very important because in case that we compare just absolute numbers this could lead us to wrong conclusion that removing the handle on Broad Street pump for sure stopped the outbreak, which is simply not true (it surely did help but did not stop the outbreak) and John Snow was aware of this (he just did what needed to be done and never aspired to become a hero). . But people love stories about heroes and other myths (definitely more than science or data science). According to John Snow&#39;s myth, he was the superhero who in two days defied their equals by hypothesizing that cholera was a waterborne disease. Despite no one listening to him, he bravely continued drawing his map, convinced local authorities to remove the handle of the infected water pump with his findings, and stopped the outbreak. John Snow saved the lives of many Londoners. . If we take a better look behind this story, we can find also the true John Snow, who was fighting the disease with limited tools and wanted to get proof that he was right and &quot;knew something&quot; about cholera. He just did what he could with limited time and always boiled his water before drinking. . john_snow_knows_nothing = False .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/16/Recreating-John-Snows-Ghost-Map.html",
            "relUrl": "/datacamp/projects/python/2021/03/16/Recreating-John-Snows-Ghost-Map.html",
            "date": " • Mar 16, 2021"
        }
        
    
  
    
        ,"post20": {
            "title": "Comparing Cosmetics by Ingredients",
            "content": "1. Cosmetics, chemicals... it&#39;s complicated . Whenever I want to try a new cosmetic item, it&#39;s so difficult to choose. It&#39;s actually more than difficult. It&#39;s sometimes scary because new items that I&#39;ve never tried end up giving me skin trouble. We know the information we need is on the back of each product, but it&#39;s really hard to interpret those ingredient lists unless you&#39;re a chemist. You may be able to relate to this situation. . . So instead of buying and hoping for the best, why don&#39;t we use data science to help us predict which products may be good fits for us? In this notebook, we are going to create a content-based recommendation system where the &#39;content&#39; will be the chemical components of cosmetics. Specifically, we will process ingredient lists for 1472 cosmetics on Sephora via word embedding, then visualize ingredient similarity using a machine learning method called t-SNE and an interactive visualization library called Bokeh. Let&#39;s inspect our data first. . # ... YOUR CODE FOR TASK 1 ... import numpy as np import pandas as pd from sklearn.manifold import TSNE # Load the data df = pd.read_csv(&#39;datasets/cosmetics.csv&#39;) # Check the first five rows # ... YOUR CODE FOR TASK 1 ... df.head() # Inspect the types of products # ... YOUR CODE FOR TASK 1 ... df[&#39;Label&#39;].value_counts() . Moisturizer 298 Cleanser 281 Face Mask 266 Treatment 248 Eye cream 209 Sun protect 170 Name: Label, dtype: int64 . 2. Focus on one product category and one skin type . There are six categories of product in our data (moisturizers, cleansers, face masks, eye creams, and sun protection) and there are five different skin types (combination, dry, normal, oily and sensitive). Because individuals have different product needs as well as different skin types, let&#39;s set up our workflow so its outputs (a t-SNE model and a visualization of that model) can be customized. For the example in this notebook, let&#39;s focus in on moisturizers for those with dry skin by filtering the data accordingly. . moisturizers = df[(df[&#39;Label&#39;] == &#39;Moisturizer&#39;)] # Filter for dry skin as well moisturizers_dry = moisturizers[(moisturizers[&#39;Dry&#39;] == 1)] # Reset index moisturizers_dry = moisturizers_dry.reset_index(drop=True) . 3. Tokenizing the ingredients . To get to our end goal of comparing ingredients in each product, we first need to do some preprocessing tasks and bookkeeping of the actual words in each product&#39;s ingredients list. The first step will be tokenizing the list of ingredients in Ingredients column. After splitting them into tokens, we&#39;ll make a binary bag of words. Then we will create a dictionary with the tokens, ingredient_idx, which will have the following format: . { &quot;ingredient&quot;: index value, … } . ingredient_idx = {} corpus = [] idx = 0 # For loop for tokenization for i in range(len(moisturizers_dry)): ingredients = moisturizers_dry[&#39;Ingredients&#39;][i] ingredients_lower = ingredients.lower() tokens = ingredients_lower.split(&#39;, &#39;) corpus.append(tokens) for ingredient in tokens: if ingredient not in ingredient_idx: ingredient_idx[ingredient] = idx idx += 1 # Check the result print(&quot;The index for decyl oleate is&quot;, ingredient_idx[&#39;decyl oleate&#39;]) . The index for decyl oleate is 25 . 4. Initializing a document-term matrix (DTM) . The next step is making a document-term matrix (DTM). Here each cosmetic product will correspond to a document, and each chemical composition will correspond to a term. This means we can think of the matrix as a “cosmetic-ingredient” matrix. The size of the matrix should be as the picture shown below. To create this matrix, we&#39;ll first make an empty matrix filled with zeros. The length of the matrix is the total number of cosmetic products in the data. The width of the matrix is the total number of ingredients. After initializing this empty matrix, we&#39;ll fill it in the following tasks. . M = len(moisturizers_dry) N = len(ingredient_idx) # Initialize a matrix of zeros A = np.zeros((M, N)) . 5. Creating a counter function . Before we can fill the matrix, let&#39;s create a function to count the tokens (i.e., an ingredients list) for each row. Our end goal is to fill the matrix with 1 or 0: if an ingredient is in a cosmetic, the value is 1. If not, it remains 0. The name of this function, oh_encoder, will become clear next. . def oh_encoder(tokens): x = np.zeros((N,)) for ingredient in tokens: # Get the index for each ingredient idx = ingredient_idx[ingredient] # Put 1 at the corresponding indices x[idx] = 1 return x . 6. The Cosmetic-Ingredient matrix! . Now we&#39;ll apply the oh_encoder() functon to the tokens in corpus and set the values at each row of this matrix. So the result will tell us what ingredients each item is composed of. For example, if a cosmetic item contains water, niacin, decyl aleate and sh-polypeptide-1, the outcome of this item will be as follows. This is what we called one-hot encoding. By encoding each ingredient in the items, the Cosmetic-Ingredient matrix will be filled with binary values. . i = 0 for tokens in corpus: A[i, :] = oh_encoder(tokens) # ... YOUR CODE FOR TASK 6 ... i = i + 1 . 7. Dimension reduction with t-SNE . The dimensions of the existing matrix is (190, 2233), which means there are 2233 features in our data. For visualization, we should downsize this into two dimensions. We&#39;ll use t-SNE for reducing the dimension of the data here. . T-distributed Stochastic Neighbor Embedding (t-SNE) is a nonlinear dimensionality reduction technique that is well-suited for embedding high-dimensional data for visualization in a low-dimensional space of two or three dimensions. Specifically, this technique can reduce the dimension of data while keeping the similarities between the instances. This enables us to make a plot on the coordinate plane, which can be said as vectorizing. All of these cosmetic items in our data will be vectorized into two-dimensional coordinates, and the distances between the points will indicate the similarities between the items. . model = TSNE(n_components=2, learning_rate=200, random_state=42) tsne_features = model.fit_transform(A) # Make X, Y columns moisturizers_dry[&#39;X&#39;] = tsne_features[:, 0] moisturizers_dry[&#39;Y&#39;] = tsne_features[:, 1] . 8. Let&#39;s map the items with Bokeh . We are now ready to start creating our plot. With the t-SNE values, we can plot all our items on the coordinate plane. And the coolest part here is that it will also show us the name, the brand, the price and the rank of each item. Let&#39;s make a scatter plot using Bokeh and add a hover tool to show that information. Note that we won&#39;t display the plot yet as we will make some more additions to it. . from bokeh.io import show, output_notebook, push_notebook from bokeh.plotting import figure from bokeh.models import ColumnDataSource, HoverTool output_notebook() # Make a source and a scatter plot source = ColumnDataSource(moisturizers_dry) plot = figure(x_axis_label = &#39;T-SNE 1&#39;, y_axis_label = &#39;T-SNE 2&#39;, width = 500, height = 400) plot.circle(x = &#39;X&#39;, y = &#39;Y&#39;, source = source, size = 10, color = &#39;#FF7373&#39;, alpha = .8) . Loading BokehJS ... GlyphRenderer(id&nbsp;=&nbsp;&#39;1177&#39;, &hellip;)data_source&nbsp;=&nbsp;ColumnDataSource(id=&#39;1139&#39;, ...),glyph&nbsp;=&nbsp;Circle(id=&#39;1175&#39;, ...),hover_glyph&nbsp;=&nbsp;None,js_event_callbacks&nbsp;=&nbsp;{},js_property_callbacks&nbsp;=&nbsp;{},level&nbsp;=&nbsp;&#39;glyph&#39;,muted&nbsp;=&nbsp;False,muted_glyph&nbsp;=&nbsp;None,name&nbsp;=&nbsp;None,nonselection_glyph&nbsp;=&nbsp;Circle(id=&#39;1176&#39;, ...),selection_glyph&nbsp;=&nbsp;None,subscribed_events&nbsp;=&nbsp;[],tags&nbsp;=&nbsp;[],view&nbsp;=&nbsp;CDSView(id=&#39;1178&#39;, ...),visible&nbsp;=&nbsp;True,x_range_name&nbsp;=&nbsp;&#39;default&#39;,y_range_name&nbsp;=&nbsp;&#39;default&#39;) 9. Adding a hover tool . Why don&#39;t we add a hover tool? Adding a hover tool allows us to check the information of each item whenever the cursor is directly over a glyph. We&#39;ll add tooltips with each product&#39;s name, brand, price, and rank (i.e., rating). . hover = HoverTool(tooltips = [(&#39;Item&#39;, &#39;@Name&#39;), (&#39;Brand&#39;, &#39;@Brand&#39;), (&#39;Price&#39;, &#39;$@Price&#39;), (&#39;Rank&#39;, &#39;@Rank&#39;)]) plot.add_tools(hover) . 10. Mapping the cosmetic items . Finally, it&#39;s show time! Let&#39;s see how the map we&#39;ve made looks like. Each point on the plot corresponds to the cosmetic items. Then what do the axes mean here? The axes of a t-SNE plot aren&#39;t easily interpretable in terms of the original data. Like mentioned above, t-SNE is a visualizing technique to plot high-dimensional data in a low-dimensional space. Therefore, it&#39;s not desirable to interpret a t-SNE plot quantitatively. . Instead, what we can get from this map is the distance between the points (which items are close and which are far apart). The closer the distance between the two items is, the more similar the composition they have. Therefore this enables us to compare the items without having any chemistry background. . # ... YOUR CODE FOR TASK 10 ... show(plot) . 11. Comparing two products . Since there are so many cosmetics and so many ingredients, the plot doesn&#39;t have many super obvious patterns that simpler t-SNE plots can have (example). Our plot requires some digging to find insights, but that&#39;s okay! . Say we enjoyed a specific product, there&#39;s an increased chance we&#39;d enjoy another product that is similar in chemical composition. Say we enjoyed AmorePacific&#39;s Color Control Cushion Compact Broad Spectrum SPF 50+. We could find this product on the plot and see if a similar product(s) exist. And it turns out it does! If we look at the points furthest left on the plot, we see LANEIGE&#39;s BB Cushion Hydra Radiance SPF 50 essentially overlaps with the AmorePacific product. By looking at the ingredients, we can visually confirm the compositions of the products are similar (though it is difficult to do, which is why we did this analysis in the first place!), plus LANEIGE&#39;s version is $22 cheaper and actually has higher ratings. . It&#39;s not perfect, but it&#39;s useful. In real life, we can actually use our little ingredient-based recommendation engine help us make educated cosmetic purchase choices. . cosmetic_1 = moisturizers_dry[moisturizers_dry[&#39;Name&#39;] == &quot;Color Control Cushion Compact Broad Spectrum SPF 50+&quot;] cosmetic_2 = moisturizers_dry[moisturizers_dry[&#39;Name&#39;] == &quot;BB Cushion Hydra Radiance SPF 50&quot;] # Display each item&#39;s data and ingredients display(cosmetic_1) print(cosmetic_1.Ingredients.values) display(cosmetic_2) print(cosmetic_2.Ingredients.values) . Label Brand Name Price Rank Ingredients Combination Dry Normal Oily Sensitive X Y . 45 Moisturizer | AMOREPACIFIC | Color Control Cushion Compact Broad Spectrum S... | 60 | 4.0 | Phyllostachis Bambusoides Juice, Cyclopentasil... | 1 | 1 | 1 | 1 | 1 | 2.775364 | -0.274434 | . [&#39;Phyllostachis Bambusoides Juice, Cyclopentasiloxane, Cyclohexasiloxane, Peg-10 Dimethicone, Phenyl Trimethicone, Butylene Glycol, Butylene Glycol Dicaprylate/Dicaprate, Alcohol, Arbutin, Lauryl Peg-9 Polydimethylsiloxyethyl Dimethicone, Acrylates/Ethylhexyl Acrylate/Dimethicone Methacrylate Copolymer, Polyhydroxystearic Acid, Sodium Chloride, Polymethyl Methacrylate, Aluminium Hydroxide, Stearic Acid, Disteardimonium Hectorite, Triethoxycaprylylsilane, Ethylhexyl Palmitate, Lecithin, Isostearic Acid, Isopropyl Palmitate, Phenoxyethanol, Polyglyceryl-3 Polyricinoleate, Acrylates/Stearyl Acrylate/Dimethicone Methacrylate Copolymer, Dimethicone, Disodium Edta, Trimethylsiloxysilicate, Ethylhexyglycerin, Dimethicone/Vinyl Dimethicone Crosspolymer, Water, Silica, Camellia Japonica Seed Oil, Camillia Sinensis Leaf Extract, Caprylyl Glycol, 1,2-Hexanediol, Fragrance, Titanium Dioxide, Iron Oxides (Ci 77492, Ci 77491, Ci77499).&#39;] . Label Brand Name Price Rank Ingredients Combination Dry Normal Oily Sensitive X Y . 55 Moisturizer | LANEIGE | BB Cushion Hydra Radiance SPF 50 | 38 | 4.3 | Water, Cyclopentasiloxane, Zinc Oxide (CI 7794... | 1 | 1 | 1 | 1 | 1 | 2.814905 | -0.277909 | . [&#39;Water, Cyclopentasiloxane, Zinc Oxide (CI 77947), Ethylhexyl Methoxycinnamate, PEG-10 Dimethicone, Cyclohexasiloxane, Phenyl Trimethicone, Iron Oxides (CI 77492), Butylene Glycol Dicaprylate/Dicaprate, Niacinamide, Lauryl PEG-9 Polydimethylsiloxyethyl Dimethicone, Acrylates/Ethylhexyl Acrylate/Dimethicone Methacrylate Copolymer, Titanium Dioxide (CI 77891 , Iron Oxides (CI 77491), Butylene Glycol, Sodium Chloride, Iron Oxides (CI 77499), Aluminum Hydroxide, HDI/Trimethylol Hexyllactone Crosspolymer, Stearic Acid, Methyl Methacrylate Crosspolymer, Triethoxycaprylylsilane, Phenoxyethanol, Fragrance, Disteardimonium Hectorite, Caprylyl Glycol, Yeast Extract, Acrylates/Stearyl Acrylate/Dimethicone Methacrylate Copolymer, Dimethicone, Trimethylsiloxysilicate, Polysorbate 80, Disodium EDTA, Hydrogenated Lecithin, Dimethicone/Vinyl Dimethicone Crosspolymer, Mica (CI 77019), Silica, 1,2-Hexanediol, Polypropylsilsesquioxane, Chenopodium Quinoa Seed Extract, Magnesium Sulfate, Calcium Chloride, Camellia Sinensis Leaf Extract, Manganese Sulfate, Zinc Sulfate, Ascorbyl Glucoside.&#39;] .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/16/Comparing-Cosmetics-by-Ingredients.html",
            "relUrl": "/datacamp/projects/python/2021/03/16/Comparing-Cosmetics-by-Ingredients.html",
            "date": " • Mar 16, 2021"
        }
        
    
  
    
        ,"post21": {
            "title": "Give Life, Predict Blood Donations",
            "content": "1. Inspecting transfusion.data file . Blood transfusion saves lives - from replacing lost blood during major surgery or a serious injury to treating various illnesses and blood disorders. Ensuring that there&#39;s enough blood in supply whenever needed is a serious challenge for the health professionals. According to WebMD, &quot;about 5 million Americans need a blood transfusion every year&quot;. . Our dataset is from a mobile blood donation vehicle in Taiwan. The Blood Transfusion Service Center drives to different universities and collects blood as part of a blood drive. We want to predict whether or not a donor will give blood the next time the vehicle comes to campus. . The data is stored in datasets/transfusion.data and it is structured according to RFMTC marketing model (a variation of RFM). We&#39;ll explore what that means later in this notebook. First, let&#39;s inspect the data. . !head -5 datasets/transfusion.data . . 2. Loading the blood donations data . We now know that we are working with a typical CSV file (i.e., the delimiter is ,, etc.). We proceed to loading the data into memory. . import pandas as pd # Read in dataset transfusion = pd.read_csv(&#39;datasets/transfusion.data&#39;) # Print out the first rows of our dataset # ... YOUR CODE FOR TASK 2 ... transfusion.head() . Recency (months) Frequency (times) Monetary (c.c. blood) Time (months) whether he/she donated blood in March 2007 . 0 2 | 50 | 12500 | 98 | 1 | . 1 0 | 13 | 3250 | 28 | 1 | . 2 1 | 16 | 4000 | 35 | 1 | . 3 2 | 20 | 5000 | 45 | 1 | . 4 1 | 24 | 6000 | 77 | 0 | . 3. Inspecting transfusion DataFrame . Let&#39;s briefly return to our discussion of RFM model. RFM stands for Recency, Frequency and Monetary Value and it is commonly used in marketing for identifying your best customers. In our case, our customers are blood donors. . RFMTC is a variation of the RFM model. Below is a description of what each column means in our dataset: . R (Recency - months since the last donation) | F (Frequency - total number of donation) | M (Monetary - total blood donated in c.c.) | T (Time - months since the first donation) | a binary variable representing whether he/she donated blood in March 2007 (1 stands for donating blood; 0 stands for not donating blood) | . It looks like every column in our DataFrame has the numeric type, which is exactly what we want when building a machine learning model. Let&#39;s verify our hypothesis. . # ... YOUR CODE FOR TASK 3 ... transfusion.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 748 entries, 0 to 747 Data columns (total 5 columns): Recency (months) 748 non-null int64 Frequency (times) 748 non-null int64 Monetary (c.c. blood) 748 non-null int64 Time (months) 748 non-null int64 whether he/she donated blood in March 2007 748 non-null int64 dtypes: int64(5) memory usage: 29.3 KB . 4. Creating target column . We are aiming to predict the value in whether he/she donated blood in March 2007 column. Let&#39;s rename this it to target so that it&#39;s more convenient to work with. . transfusion.rename( columns={&#39;whether he/she donated blood in March 2007&#39;: &#39;target&#39;}, inplace=True ) # Print out the first 2 rows # ... YOUR CODE FOR TASK 4 ... transfusion.head(2) . Recency (months) Frequency (times) Monetary (c.c. blood) Time (months) target . 0 2 | 50 | 12500 | 98 | 1 | . 1 0 | 13 | 3250 | 28 | 1 | . 5. Checking target incidence . We want to predict whether or not the same donor will give blood the next time the vehicle comes to campus. The model for this is a binary classifier, meaning that there are only 2 possible outcomes: . 0 - the donor will not give blood | 1 - the donor will give blood | . Target incidence is defined as the number of cases of each individual target value in a dataset. That is, how many 0s in the target column compared to how many 1s? Target incidence gives us an idea of how balanced (or imbalanced) is our dataset. . # ... YOUR CODE FOR TASK 5 ... transfusion[&#39;target&#39;].value_counts(normalize=True).round(3) . 0 0.762 1 0.238 Name: target, dtype: float64 . 6. Splitting transfusion into train and test datasets . We&#39;ll now use train_test_split() method to split transfusion DataFrame. . Target incidence informed us that in our dataset 0s appear 76% of the time. We want to keep the same structure in train and test datasets, i.e., both datasets must have 0 target incidence of 76%. This is very easy to do using the train_test_split() method from the scikit learn library - all we need to do is specify the stratify parameter. In our case, we&#39;ll stratify on the target column. . from sklearn.model_selection import train_test_split # Split transfusion DataFrame into # X_train, X_test, y_train and y_test datasets, # stratifying on the `target` column X_train, X_test, y_train, y_test = train_test_split( transfusion.drop(columns=&#39;target&#39;), transfusion.target, test_size=0.25, random_state=42, stratify=transfusion.target ) # Print out the first 2 rows of X_train # ... YOUR CODE FOR TASK 6 ... X_train.head(2) . Recency (months) Frequency (times) Monetary (c.c. blood) Time (months) . 334 16 | 2 | 500 | 16 | . 99 5 | 7 | 1750 | 26 | . 7. Selecting model using TPOT . TPOT is a Python Automated Machine Learning tool that optimizes machine learning pipelines using genetic programming. . . TPOT will automatically explore hundreds of possible pipelines to find the best one for our dataset. Note, the outcome of this search will be a scikit-learn pipeline, meaning it will include any pre-processing steps as well as the model. . We are using TPOT to help us zero in on one model that we can then explore and optimize further. . from tpot import TPOTClassifier from sklearn.metrics import roc_auc_score # Instantiate TPOTClassifier tpot = TPOTClassifier( generations=5, population_size=20, verbosity=2, scoring=&#39;roc_auc&#39;, random_state=42, disable_update_check=True, config_dict=&#39;TPOT light&#39; ) tpot.fit(X_train, y_train) # AUC score for tpot model tpot_auc_score = roc_auc_score(y_test, tpot.predict_proba(X_test)[:, 1]) print(f&#39; nAUC score: {tpot_auc_score:.4f}&#39;) # Print best pipeline steps print(&#39; nBest pipeline steps:&#39;, end=&#39; n&#39;) for idx, (name, transform) in enumerate(tpot.fitted_pipeline_.steps, start=1): # Print idx and transform print(f&#39;{idx}. {transform}&#39;) . Generation 1 - Current best internal CV score: 0.7433977184592779 Generation 2 - Current best internal CV score: 0.7433977184592779 Generation 3 - Current best internal CV score: 0.7433977184592779 Generation 4 - Current best internal CV score: 0.7433977184592779 Generation 5 - Current best internal CV score: 0.7433977184592779 Best pipeline: LogisticRegression(input_matrix, C=0.5, dual=False, penalty=l2) AUC score: 0.7850 Best pipeline steps: 1. LogisticRegression(C=0.5, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, max_iter=100, multi_class=&#39;warn&#39;, n_jobs=None, penalty=&#39;l2&#39;, random_state=None, solver=&#39;warn&#39;, tol=0.0001, verbose=0, warm_start=False) . 8. Checking the variance . TPOT picked LogisticRegression as the best model for our dataset with no pre-processing steps, giving us the AUC score of 0.7850. This is a great starting point. Let&#39;s see if we can make it better. . One of the assumptions for linear models is that the data and the features we are giving it are related in a linear fashion, or can be measured with a linear distance metric. If a feature in our dataset has a high variance that&#39;s orders of magnitude greater than the other features, this could impact the model&#39;s ability to learn from other features in the dataset. . Correcting for high variance is called normalization. It is one of the possible transformations you do before training a model. Let&#39;s check the variance to see if such transformation is needed. . # ... YOUR CODE FOR TASK 8 ... X_train.var().round(3) . Recency (months) 66.929 Frequency (times) 33.830 Monetary (c.c. blood) 2114363.700 Time (months) 611.147 dtype: float64 . 9. Log normalization . Monetary (c.c. blood)&#39;s variance is very high in comparison to any other column in the dataset. This means that, unless accounted for, this feature may get more weight by the model (i.e., be seen as more important) than any other feature. . One way to correct for high variance is to use log normalization. . import numpy as np # Copy X_train and X_test into X_train_normed and X_test_normed X_train_normed, X_test_normed = X_train.copy(), X_test.copy() # Specify which column to normalize col_to_normalize = &#39;Monetary (c.c. blood)&#39; # Log normalization for df_ in [X_train_normed, X_test_normed]: # Add log normalized column df_[&#39;monetary_log&#39;] = np.log(df_[col_to_normalize]) # Drop the original column df_.drop(columns=col_to_normalize, inplace=True) # Check the variance for X_train_normed # ... YOUR CODE FOR TASK 9 ... X_train_normed.var().round(3) . Recency (months) 66.929 Frequency (times) 33.830 Time (months) 611.147 monetary_log 0.837 dtype: float64 . 10. Training the logistic regression model . The variance looks much better now. Notice that now Time (months) has the largest variance, but it&#39;s not the orders of magnitude higher than the rest of the variables, so we&#39;ll leave it as is. . We are now ready to train the logistic regression model. . from sklearn import linear_model # Instantiate LogisticRegression logreg = linear_model.LogisticRegression( solver=&#39;liblinear&#39;, random_state=42 ) # Train the model logreg.fit(X_train_normed, y_train) # AUC score for tpot model logreg_auc_score = roc_auc_score(y_test, logreg.predict_proba(X_test_normed)[:, 1]) print(f&#39; nAUC score: {logreg_auc_score:.4f}&#39;) . AUC score: 0.7891 . 11. Conclusion . The demand for blood fluctuates throughout the year. As one prominent example, blood donations slow down during busy holiday seasons. An accurate forecast for the future supply of blood allows for an appropriate action to be taken ahead of time and therefore saving more lives. . In this notebook, we explored automatic model selection using TPOT and AUC score we got was 0.7850. This is better than simply choosing 0 all the time (the target incidence suggests that such a model would have 76% success rate). We then log normalized our training data and improved the AUC score by 0.5%. In the field of machine learning, even small improvements in accuracy can be important, depending on the purpose. . Another benefit of using logistic regression model is that it is interpretable. We can analyze how much of the variance in the response variable (target) can be explained by other variables in our dataset. . from operator import itemgetter # Sort models based on their AUC score from highest to lowest sorted( [(&#39;tpot&#39;, tpot_auc_score), (&#39;logreg&#39;, logreg_auc_score)], key=itemgetter(1), reverse=True ) . [(&#39;logreg&#39;, 0.7890972663699937), (&#39;tpot&#39;, 0.7849650349650349)] .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2021/03/15/Give-Life-Predict-Blood-Donations.html",
            "relUrl": "/datacamp/projects/python/2021/03/15/Give-Life-Predict-Blood-Donations.html",
            "date": " • Mar 15, 2021"
        }
        
    
  
    
        ,"post22": {
            "title": "Important Pandas functions to load data files in Machine Learning Challenges",
            "content": "Pandas is a python&#39;s third-party library that provides computational fast and flexible data structures in manipulating and analyzing tabular, multi-dimensional and time-series data. . In most machine learning challenges, the dataset provided will be in the form of .csv files that need to be loaded into the workspace. The loaded dataset will be used in prediction, and predicted values also should be submitted in the form of .csv files as per there submission guidelines. . In this article, I will explain some different ways of loading the dataset into your workspace and making an output submission file. . The first way is to load the dataset directly without passing any arguments, which is useful when all the columns are used in model building. . import pandas as pd . data = pd.read_csv(&#39;train.csv&#39;) data.head() # To view the first five rows of the dataset . The second way is to load the dataset using an index_col argument when one of the columns is unique and will not be used in model building. . data = pd.read_csv(&#39;train.csv&#39;, index_col=&#39;Index&#39;) data.head() # To view the first five rows of the dataset . Note: The type of the index_col argument will be a string when only one column needs to be used as an index; it will be a list of strings when two or more columns need to be used as an index. . The Third way is to load the dataset using parse_dates argument when one or more columns in the dataset are of datatype &#39;datetime[ns]&#39; . data = pd.read_csv(&#39;train.csv&#39;, parse_dates=&#39;Date&#39;) data.head() # To view the first five rows of the dataset . Note: The type of the parse_dates argument will be a string when only one column needs to be parsed; it will be a list of strings when two or more columns need to be used as an index. . Finally, in the end, after all the model building, model tuning and prediction stuff. You need to save the prediction in the specified format as in the submission guidelines. . In most cases, the submission file contains two more columns in which of the column will be the predicted value. . For example, if the submission guidelines say that the output should have two columns with column names filename and value, then the code looks similar to this: . The variable index contains the filename values, and the variable prediction has the prediction values. . output = pd.DataFrame({&#39;filename&#39;: filename, &#39;value&#39;: prediction}) output.to_csv(&#39;output.csv&#39;, index=False) . Note: the index should be False to ensure that the to_csv does not add an extra index column to the output file. .",
            "url": "https://anuraganalog.github.io/blog/pandas/load/csv/functions/data/dockship/article/2021/02/26/Important-Pandas-functions-to-load-data-files-in-Machine-Learning-Challenges.html",
            "relUrl": "/pandas/load/csv/functions/data/dockship/article/2021/02/26/Important-Pandas-functions-to-load-data-files-in-Machine-Learning-Challenges.html",
            "date": " • Feb 26, 2021"
        }
        
    
  
    
        ,"post23": {
            "title": "Name Game Gender Prediction using Sound",
            "content": "1. Sound it out! . Grey and Gray. Colour and Color. Words like these have been the cause of many heated arguments between Brits and Americans. Accents (and jokes) aside, there are many words that are pronounced the same way but have different spellings. While it is easy for us to realize their equivalence, basic programming commands will fail to equate such two strings. . More extreme than word spellings are names because people have more flexibility in choosing to spell a name in a certain way. To some extent, tradition sometimes governs the way a name is spelled, which limits the number of variations of any given English name. But if we consider global names and their associated English spellings, you can only imagine how many ways they can be spelled out. . One way to tackle this challenge is to write a program that checks if two strings sound the same, instead of checking for equivalence in spellings. We&#39;ll do that here using fuzzy name matching. . import fuzzy # Exploring the output of fuzzy.nysiis fuzzy.nysiis(&#39;color&#39;) # Testing equivalence of similar sounding words fuzzy.nysiis(&#39;tomorrow&#39;) == fuzzy.nysiis(&#39;tommorow&#39;) . True . 2. Authoring the authors . The New York Times puts out a weekly list of best-selling books from different genres, and which has been published since the 1930’s. We’ll focus on Children’s Picture Books, and analyze the gender distribution of authors to see if there have been changes over time. We&#39;ll begin by reading in the data on the best selling authors from 2008 to 2017. . import pandas as pd # Reading in datasets/nytkids_yearly.csv, which is semicolon delimited. author_df = pd.read_csv(&#39;datasets/nytkids_yearly.csv&#39;, sep=&#39;;&#39;) # Looping through author_df[&#39;Author&#39;] to extract the authors first names first_name = [] for name in author_df[&#39;Author&#39;]: first_name.append(name.split()[0]) # Adding first_name as a column to author_df author_df[&#39;first_name&#39;] = first_name # Checking out the first few rows of author_df print(author_df.head()) . Year Book Title Author 0 2017 DRAGONS LOVE TACOS Adam Rubin 1 2017 THE WONDERFUL THINGS YOU WILL BE Emily Winfield Martin 2 2017 THE DAY THE CRAYONS QUIT Drew Daywalt 3 2017 ROSIE REVERE, ENGINEER Andrea Beaty 4 2017 ADA TWIST, SCIENTIST Andrea Beaty Besteller this year first_name 0 49 Adam 1 48 Emily 2 44 Drew 3 38 Andrea 4 28 Andrea . 3. It&#39;s time to bring on the phonics... again! . When we were young children, we were taught to read using phonics; sounding out the letters that compose words. So let&#39;s relive history and do that again, but using python this time. We will now create a new column or list that contains the phonetic equivalent of every first name that we just extracted. . To make sure we&#39;re on the right track, let&#39;s compare the number of unique values in the first_name column and the number of unique values in the nysiis coded column. As a rule of thumb, the number of unique nysiis first names should be less than or equal to the number of actual first names. . import numpy as np # Looping through author&#39;s first names to create the nysiis (fuzzy) equivalent nysiis_name = [] for fname in first_name: nysiis_name.append(fuzzy.nysiis(fname)) # Adding nysiis_name as a column to author_df author_df[&#39;nysiis_name&#39;] = nysiis_name # Printing out the difference between unique firstnames and unique nysiis_names: print(len(np.unique(first_name)) - len(np.unique(nysiis_name))) . 25 . 4. The inbetweeners . We&#39;ll use babynames_nysiis.csv, a dataset that is derived from the Social Security Administration’s baby name data, to identify author genders. The dataset contains unique NYSIIS versions of baby names, and also includes the percentage of times the name appeared as a female name (perc_female) and the percentage of times it appeared as a male name (perc_male). . We&#39;ll use this data to create a list of gender. Let&#39;s make the following simplifying assumption: For each name, if perc_female is greater than perc_male then assume the name is female, if perc_female is less than perc_male then assume it is a male name, and if the percentages are equal then it&#39;s a &quot;neutral&quot; name. . babies_df = pd.read_csv(&#39;datasets/babynames_nysiis.csv&#39;, sep=&#39;;&#39;) # Looping through babies_df to and filling up gender gender = [] for g in babies_df.iterrows(): if g[1][2] &gt; g[1][1]: gender.append(&quot;M&quot;) elif g[1][2] &lt; g[1][1]: gender.append(&quot;F&quot;) else: gender.append(&quot;N&quot;) # Adding a gender column to babies_df babies_df[&#39;gender&#39;] = gender # Printing out the first few rows of babies_df print(babies_df.head()) . babynysiis perc_female perc_male gender 0 NaN 62.50 37.50 F 1 RAX 63.64 36.36 F 2 ESAR 44.44 55.56 M 3 DJANG 0.00 100.00 M 4 PARCAL 25.00 75.00 M . 5. Playing matchmaker . Now that we have identified the likely genders of different names, let&#39;s find author genders by searching for each author&#39;s name in the babies_df DataFrame, and extracting the associated gender. . # Where an item does not exist, it returns -1. def locate_in_list(a_list, element): loc_of_name = a_list.index(element) if element in a_list else -1 return(loc_of_name) # Looping through author_df[&#39;nysiis_name&#39;] and appending the gender of each # author to author_gender. author_gender = [] for name in author_df[&#39;nysiis_name&#39;]: ind = locate_in_list(list(babies_df[&#39;babynysiis&#39;]), name) if ind &lt; 0: author_gender.append(&quot;Unknown&quot;) else: author_gender.append(list(babies_df[&#39;gender&#39;])[ind]) # Adding author_gender to the author_df author_df[&#39;author_gender&#39;] = author_gender # Counting the author&#39;s genders author_df[&#39;author_gender&#39;].value_counts() . F 395 M 191 Unknown 9 N 8 Name: author_gender, dtype: int64 . 6. Tally up . From the results above see that there are more female authors on the New York Times best seller&#39;s list than male authors. Our dataset spans 2008 to 2017. Let&#39;s find out if there have been changes over time. . years = sorted(np.unique(author_df[&#39;Year&#39;])) # Initializing lists males_by_yr = [] females_by_yr = [] unknown_by_yr = [] # Looping through years to find the number of male, female and unknown authors per year for year in years: tmp_df = author_df[author_df[&#39;Year&#39;] == year] males_by_yr.append(len(author_df[(author_df[&#39;Year&#39;] == year) &amp; (author_df[&#39;author_gender&#39;] == &#39;M&#39;)])) females_by_yr.append(len(author_df[(author_df[&#39;Year&#39;] == year) &amp; (author_df[&#39;author_gender&#39;] == &#39;F&#39;)])) unknown_by_yr.append(len(author_df[(author_df[&#39;Year&#39;] == year) &amp; (author_df[&#39;author_gender&#39;] == &#39;N&#39;)])) # Printing out yearly values to examine changes over time print(males_by_yr) print(females_by_yr) print(unknown_by_yr) . [8, 19, 27, 21, 21, 11, 21, 18, 25, 20] [15, 45, 48, 51, 46, 51, 34, 30, 32, 43] [1, 0, 1, 1, 2, 1, 1, 0, 1, 0] . 7. Foreign-born authors? . Our gender data comes from social security applications of individuals born in the US. Hence, one possible explanation for why there are &quot;unknown&quot; genders associated with some author names is because these authors were foreign-born. While making this assumption, we should note that these are only a subset of foreign-born authors as others will have names that have a match in baby_df (and in the social security dataset). . Using a bar chart, let&#39;s explore the trend of foreign-born authors with no name matches in the social security dataset. . import matplotlib.pyplot as plt # This makes plots appear in the notebook %matplotlib inline # Plotting the bar chart plt.bar(years, unknown_by_yr) # [OPTIONAL] - Setting a title, and axes labels plt.title(&quot;Number of Unknown Authors per year&quot;) plt.xlabel(&quot;Year&quot;) plt.ylabel(&quot;Frequency&quot;) . Text(0,0.5,&#39;Frequency&#39;) . 8. Raising the bar . What’s more exciting than a bar chart is a grouped bar chart. This type of chart is good for displaying changes over time while also comparing two or more groups. Let’s use a grouped bar chart to look at the distribution of male and female authors over time. . years_shifted = [y+0.25 for y in years] # Plotting males_by_yr by year plt.bar(years, males_by_yr, width=0.25, color=&#39;lightblue&#39;) # Plotting females_by_yr by years_shifted # ... YOUR CODE FOR TASK 8 ... # [OPTIONAL] - Adding relevant Axes labels and Chart Title # ... YOUR CODE FOR TASK 8 ... . TypeError Traceback (most recent call last) &lt;ipython-input-118-bfbe721308ff&gt; in &lt;module&gt;() 3 4 # Plotting males_by_yr by year -&gt; 5 plt.bar() 6 7 # Plotting females_by_yr by years_shifted /usr/local/lib/python3.5/dist-packages/matplotlib/pyplot.py in bar(*args, **kwargs) 2646 mplDeprecation) 2647 try: -&gt; 2648 ret = ax.bar(*args, **kwargs) 2649 finally: 2650 ax._hold = washold /usr/local/lib/python3.5/dist-packages/matplotlib/__init__.py in inner(ax, *args, **kwargs) 1715 warnings.warn(msg % (label_namer, func.__name__), 1716 RuntimeWarning, stacklevel=2) -&gt; 1717 return func(ax, *args, **kwargs) 1718 pre_doc = inner.__doc__ 1719 if pre_doc is None: /usr/local/lib/python3.5/dist-packages/matplotlib/axes/_axes.py in bar(self, *args, **kwargs) 1963 break 1964 else: -&gt; 1965 raise exps[0] 1966 # if we matched the second-case, then the user passed in 1967 # left=val as a kwarg which we want to deprecate /usr/local/lib/python3.5/dist-packages/matplotlib/axes/_axes.py in bar(self, *args, **kwargs) 1955 for matcher in matchers: 1956 try: -&gt; 1957 dp, x, height, width, y, kwargs = matcher(*args, **kwargs) 1958 except TypeError as e: 1959 # This can only come from a no-match as there is TypeError: &lt;lambda&gt;() missing 2 required positional arguments: &#39;x&#39; and &#39;height&#39; .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/05/26/Name-Game-Gender-Prediction-using-Sound.html",
            "relUrl": "/datacamp/projects/python/2020/05/26/Name-Game-Gender-Prediction-using-Sound.html",
            "date": " • May 26, 2020"
        }
        
    
  
    
        ,"post24": {
            "title": "The Hottest Topics in Machine Learning",
            "content": "1. Loading the NIPS papers . The NIPS conference (Neural Information Processing Systems) is one of the most prestigious yearly events in the machine learning community. At each NIPS conference, a large number of research papers are published. Over 50,000 PDF files were automatically downloaded and processed to obtain a dataset on various machine learning techniques. These NIPS papers are stored in datasets/papers.csv. The CSV file contains information on the different NIPS papers that were published from 1987 until 2017 (30 years!). These papers discuss a wide variety of topics in machine learning, from neural networks to optimization methods and many more. . First, we will explore the CSV file to determine what type of data we can use for the analysis and how it is structured. A research paper typically consists of a title, an abstract and the main text. Other data such as figures and tables were not extracted from the PDF files. Each paper discusses a novel technique or improvement. In this analysis, we will focus on analyzing these papers with natural language processing methods. . import pandas as pd # Read datasets/papers.csv into papers papers = pd.read_csv(&#39;datasets/papers.csv&#39;) # Print out the first rows of papers print(papers.head()) . id year title event_type 0 1 1987 Self-Organization of Associative Database and ... NaN 1 10 1987 A Mean Field Theory of Layer IV of Visual Cort... NaN 2 100 1988 Storing Covariance by the Associative Long-Ter... NaN 3 1000 1994 Bayesian Query Construction for Neural Network... NaN 4 1001 1994 Neural Network Ensembles, Cross Validation, an... NaN pdf_name abstract 0 1-self-organization-of-associative-database-an... Abstract Missing 1 10-a-mean-field-theory-of-layer-iv-of-visual-c... Abstract Missing 2 100-storing-covariance-by-the-associative-long... Abstract Missing 3 1000-bayesian-query-construction-for-neural-ne... Abstract Missing 4 1001-neural-network-ensembles-cross-validation... Abstract Missing paper_text 0 767 n nSELF-ORGANIZATION OF ASSOCIATIVE DATABA... 1 683 n nA MEAN FIELD THEORY OF LAYER IV OF VISU... 2 394 n nSTORING COVARIANCE BY THE ASSOCIATIVE n... 3 Bayesian Query Construction for Neural nNetwor... 4 Neural Network Ensembles, Cross nValidation, a... . 2. Preparing the data for analysis . For the analysis of the papers, we are only interested in the text data associated with the paper as well as the year the paper was published in. . We will analyze this text data using natural language processing. Since the file contains some metadata such as id&#39;s and filenames, it is necessary to remove all the columns that do not contain useful text information. . papers.drop([&#39;id&#39;, &#39;event_type&#39;, &#39;pdf_name&#39;], axis=1, inplace=True) # Print out the first rows of papers print(papers.head()) . year title abstract 0 1987 Self-Organization of Associative Database and ... Abstract Missing 1 1987 A Mean Field Theory of Layer IV of Visual Cort... Abstract Missing 2 1988 Storing Covariance by the Associative Long-Ter... Abstract Missing 3 1994 Bayesian Query Construction for Neural Network... Abstract Missing 4 1994 Neural Network Ensembles, Cross Validation, an... Abstract Missing paper_text 0 767 n nSELF-ORGANIZATION OF ASSOCIATIVE DATABA... 1 683 n nA MEAN FIELD THEORY OF LAYER IV OF VISU... 2 394 n nSTORING COVARIANCE BY THE ASSOCIATIVE n... 3 Bayesian Query Construction for Neural nNetwor... 4 Neural Network Ensembles, Cross nValidation, a... . 3. Plotting how machine learning has evolved over time . In order to understand how the machine learning field has recently exploded in popularity, we will begin by visualizing the number of publications per year. . By looking at the number of published papers per year, we can understand the extent of the machine learning &#39;revolution&#39;! Typically, this significant increase in popularity is attributed to the large amounts of compute power, data and improvements in algorithms. . groups = papers.groupby(&#39;year&#39;) # Determine the size of each group counts = groups.apply(len) # Visualise the counts as a bar plot import matplotlib.pyplot %matplotlib inline counts.plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fce93386cc0&gt; . 4. Preprocessing the text data . Let&#39;s now analyze the titles of the different papers to identify machine learning trends. First, we will perform some simple preprocessing on the titles in order to make them more amenable for analysis. We will use a regular expression to remove any punctuation in the title. Then we will perform lowercasing. We&#39;ll then print the titles of the first rows before and after applying the modification. . import re # Print the titles of the first rows print(papers[&#39;title&#39;].head()) # Remove punctuation papers[&#39;title_processed&#39;] = papers[&#39;title&#39;].map(lambda x: re.sub(&#39;[, .!?]&#39;, &#39;&#39;, x)) # Convert the titles to lowercase papers[&#39;title_processed&#39;] = papers[&#39;title_processed&#39;].map(lambda x: str.lower(x)) # Print the processed titles of the first rows print(papers[&#39;title_processed&#39;].head()) . 0 Self-Organization of Associative Database and ... 1 A Mean Field Theory of Layer IV of Visual Cort... 2 Storing Covariance by the Associative Long-Ter... 3 Bayesian Query Construction for Neural Network... 4 Neural Network Ensembles, Cross Validation, an... Name: title, dtype: object 0 self-organization of associative database and ... 1 a mean field theory of layer iv of visual cort... 2 storing covariance by the associative long-ter... 3 bayesian query construction for neural network... 4 neural network ensembles cross validation and ... Name: title_processed, dtype: object . 5. A word cloud to visualize the preprocessed text data . In order to verify whether the preprocessing happened correctly, we can make a word cloud of the titles of the research papers. This will give us a visual representation of the most common words. Visualisation is key to understanding whether we are still on the right track! In addition, it allows us to verify whether we need additional preprocessing before further analyzing the text data. . Python has a massive number of open libraries! Instead of trying to develop a method to create word clouds ourselves, we&#39;ll use Andreas Mueller&#39;s wordcloud library. . import wordcloud # Join the different processed titles together. long_string = &quot; &quot;.join([title for title in papers[&#39;title_processed&#39;]]) # Create a WordCloud object wordcloud = wordcloud.WordCloud() # Generate a word cloud wordcloud.generate(long_string) # Visualize the word cloud wordcloud.to_image() . 6. Prepare the text for LDA analysis . The main text analysis method that we will use is latent Dirichlet allocation (LDA). LDA is able to perform topic detection on large document sets, determining what the main &#39;topics&#39; are in a large unlabeled set of texts. A &#39;topic&#39; is a collection of words that tend to co-occur often. The hypothesis is that LDA might be able to clarify what the different topics in the research titles are. These topics can then be used as a starting point for further analysis. . LDA does not work directly on text data. First, it is necessary to convert the documents into a simple vector representation. This representation will then be used by LDA to determine the topics. Each entry of a &#39;document vector&#39; will correspond with the number of times a word occurred in the document. In conclusion, we will convert a list of titles into a list of vectors, all with length equal to the vocabulary. For example, &#39;Analyzing machine learning trends with neural networks.&#39; would be transformed into [1, 0, 1, ..., 1, 0]. . We&#39;ll then plot the 10 most common words based on the outcome of this operation (the list of document vectors). As a check, these words should also occur in the word cloud. . from sklearn.feature_extraction.text import CountVectorizer import numpy as np # Helper function def plot_10_most_common_words(count_data, count_vectorizer): import matplotlib.pyplot as plt words = count_vectorizer.get_feature_names() total_counts = np.zeros(len(words)) for t in count_data: total_counts+=t.toarray()[0] count_dict = (zip(words, total_counts)) count_dict = sorted(count_dict, key=lambda x:x[1], reverse=True)[0:10] words = [w[0] for w in count_dict] counts = [w[1] for w in count_dict] x_pos = np.arange(len(words)) plt.bar(x_pos, counts,align=&#39;center&#39;) plt.xticks(x_pos, words, rotation=90) plt.xlabel(&#39;words&#39;) plt.ylabel(&#39;counts&#39;) plt.title(&#39;10 most common words&#39;) plt.show() # Initialise the count vectorizer with the English stop words count_vectorizer = CountVectorizer(stop_words=&#39;english&#39;) # Fit and transform the processed titles count_data = count_vectorizer.fit_transform(papers[&#39;title_processed&#39;]) # Visualise the 10 most common words plot_10_most_common_words(count_data, count_vectorizer) . 7. Analysing trends with LDA . Finally, the research titles will be analyzed using LDA. Note that in order to process a new set of documents (e.g. news articles), a similar set of steps will be required to preprocess the data. The flow that was constructed here can thus easily be exported for a new text dataset. . The only parameter we will tweak is the number of topics in the LDA algorithm. Typically, one would calculate the &#39;perplexity&#39; metric to determine which number of topics is best and iterate over different amounts of topics until the lowest &#39;perplexity&#39; is found. For now, let&#39;s play around with a different number of topics. From there, we can distinguish what each topic is about (&#39;neural networks&#39;, &#39;reinforcement learning&#39;, &#39;kernel methods&#39;, &#39;gaussian processes&#39;, etc.). . import warnings warnings.simplefilter(&quot;ignore&quot;, DeprecationWarning) # Load the LDA model from sk-learn from sklearn.decomposition import LatentDirichletAllocation as LDA # Helper function def print_topics(model, count_vectorizer, n_top_words): words = count_vectorizer.get_feature_names() for topic_idx, topic in enumerate(model.components_): print(&quot; nTopic #%d:&quot; % topic_idx) print(&quot; &quot;.join([words[i] for i in topic.argsort()[:-n_top_words - 1:-1]])) # Tweak the two parameters below (use int values below 15) number_topics = 3 number_words = 5 # Create and fit the LDA model lda = LDA(n_components=number_topics) lda.fit(count_data) # Print the topics found by the LDA model print(&quot;Topics found via LDA:&quot;) print_topics(lda, count_vectorizer, number_words) . Topics found via LDA: Topic #0: learning neural networks network deep Topic #1: learning model based analysis multi Topic #2: models inference learning stochastic gaussian . 8. The future of machine learning . Machine learning has become increasingly popular over the past years. The number of NIPS conference papers has risen exponentially, and people are continuously looking for ways on how they can incorporate machine learning into their products and services. . Although this analysis focused on analyzing machine learning trends in research, a lot of these techniques are rapidly being adopted in industry. Following the latest machine learning trends is a critical skill for a data scientist, and it is recommended to continuously keep learning by going through blogs, tutorials, and courses. . more_papers_published_in_2018 = True .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/05/21/The-Hottest-Topics-in-Machine-Learning.html",
            "relUrl": "/datacamp/projects/python/2020/05/21/The-Hottest-Topics-in-Machine-Learning.html",
            "date": " • May 21, 2020"
        }
        
    
  
    
        ,"post25": {
            "title": "The Android App Market on Google Play",
            "content": "1. Google Play Store apps and reviews . Mobile apps are everywhere. They are easy to create and can be lucrative. Because of these two factors, more and more apps are being developed. In this notebook, we will do a comprehensive analysis of the Android app market by comparing over ten thousand apps in Google Play across different categories. We&#39;ll look for insights in the data to devise strategies to drive growth and retention. . . Let&#39;s take a look at the data, which consists of two files: . apps.csv: contains all the details of the applications on Google Play. There are 13 features that describe a given app. | user_reviews.csv: contains 100 reviews for each app, most helpful first. The text in each review has been pre-processed and attributed with three new features: Sentiment (Positive, Negative or Neutral), Sentiment Polarity and Sentiment Subjectivity. | . import pandas as pd apps_with_duplicates = pd.read_csv(&#39;datasets/apps.csv&#39;) # Drop duplicates apps = apps_with_duplicates.drop_duplicates() # Print the total number of apps print(&#39;Total number of apps in the dataset = &#39;, len(apps)) # Have a look at a random sample of 5 rows n = 5 apps.sample(n) . Total number of apps in the dataset = 9659 . Unnamed: 0 App Category Rating Reviews Size Installs Type Price Content Rating Genres Last Updated Current Ver Android Ver . 3597 4502 | Gun Shoot War Q | GAME | 4.2 | 26893 | 20M | 1,000,000+ | Free | 0 | Teen | Arcade | March 1, 2017 | 1.0.5 | 2.3 and up | . 8993 10154 | EZ-VPNGate | TOOLS | 4.3 | 36 | 12M | 5,000+ | Free | 0 | Everyone | Tools | August 21, 2017 | 1.0.7 | 4.0.3 and up | . 4524 5488 | eChallan Andhra Pradesh (AP) | SOCIAL | 3.0 | 5 | 2.6M | 1,000+ | Free | 0 | Teen | Social | February 15, 2018 | 1.0.0.4 | 4.1 and up | . 1016 1243 | Eat24 Food Delivery &amp; Takeout | FOOD_AND_DRINK | 4.3 | 40116 | NaN | 1,000,000+ | Free | 0 | Everyone | Food &amp; Drink | August 2, 2018 | Varies with device | Varies with device | . 5405 6414 | TappyToon Comics &amp; Webtoons | COMICS | 3.5 | 4205 | 10M | 100,000+ | Free | 0 | Teen | Comics | July 13, 2018 | 1.77 | 4.0.3 and up | . 2. Data cleaning . The three features that we will be working with most frequently henceforth are Installs, Size, and Price. A careful glance of the dataset reveals that some of these columns mandate data cleaning in order to be consumed by code we&#39;ll write later. Specifically, the presence of special characters (, $ +) and letters (M k) in the Installs, Size, and Price columns make their conversion to a numerical data type difficult. Let&#39;s clean by removing these and converting each column to a numeric type. . chars_to_remove = [&#39;+&#39;, &#39;,&#39;, &#39;M&#39;, &#39;$&#39;] # List of column names to clean cols_to_clean = [&#39;Installs&#39;, &#39;Size&#39;, &#39;Price&#39;] # Loop for each column for col in cols_to_clean: # Replace each character with an empty string for char in chars_to_remove: apps[col] = apps[col].str.replace(char, &#39;&#39;) # Convert col to numeric apps[col] = pd.to_numeric(apps[col]) . 3. Exploring app categories . With more than 1 billion active users in 190 countries around the world, Google Play continues to be an important distribution platform to build a global audience. For businesses to get their apps in front of users, it&#39;s important to make them more quickly and easily discoverable on Google Play. To improve the overall search experience, Google has introduced the concept of grouping apps into categories. . This brings us to the following questions: . Which category has the highest share of (active) apps in the market? | Is any specific category dominating the market? | Which categories have the fewest number of apps? | . We will see that there are 33 unique app categories present in our dataset. Family and Game apps have the highest market prevalence. Interestingly, Tools, Business and Medical apps are also at the top. . import plotly plotly.offline.init_notebook_mode(connected=True) import plotly.graph_objs as go # Print the total number of unique categories num_categories = len(apps[&#39;Category&#39;].unique()) print(&#39;Number of categories = &#39;, num_categories) # Count the number of apps in each &#39;Category&#39; and sort them in descending order num_apps_in_category = apps[&#39;Category&#39;].value_counts().sort_values(ascending = False) data = [go.Bar( x = num_apps_in_category.index, # index = category name y = num_apps_in_category.values, # value = count )] plotly.offline.iplot(data) . Number of categories = 33 . 4. Distribution of app ratings . After having witnessed the market share for each category of apps, let&#39;s see how all these apps perform on an average. App ratings (on a scale of 1 to 5) impact the discoverability, conversion of apps as well as the company&#39;s overall brand image. Ratings are a key performance indicator of an app. . From our research, we found that the average volume of ratings across all app categories is 4.17. The histogram plot is skewed to the right indicating that the majority of the apps are highly rated with only a few exceptions in the low-rated apps. . avg_app_rating = apps[&#39;Rating&#39;].mean() print(&#39;Average app rating = &#39;, avg_app_rating) # Distribution of apps according to their ratings data = [go.Histogram( x = apps[&#39;Rating&#39;] )] # Vertical dashed line to indicate the average app rating layout = {&#39;shapes&#39;: [{ &#39;type&#39; :&#39;line&#39;, &#39;x0&#39;: avg_app_rating, &#39;y0&#39;: 0, &#39;x1&#39;: avg_app_rating, &#39;y1&#39;: 1000, &#39;line&#39;: { &#39;dash&#39;: &#39;dashdot&#39;} }] } plotly.offline.iplot({&#39;data&#39;: data, &#39;layout&#39;: layout}) . Average app rating = 4.173243045387994 . 5. Size and price of an app . Let&#39;s now examine app size and app price. For size, if the mobile app is too large, it may be difficult and/or expensive for users to download. Lengthy download times could turn users off before they even experience your mobile app. Plus, each user&#39;s device has a finite amount of disk space. For price, some users expect their apps to be free or inexpensive. These problems compound if the developing world is part of your target market; especially due to internet speeds, earning power and exchange rates. . How can we effectively come up with strategies to size and price our app? . Does the size of an app affect its rating? | Do users really care about system-heavy apps or do they prefer light-weighted apps? | Does the price of an app affect its rating? | Do users always prefer free apps over paid apps? | . We find that the majority of top rated apps (rating over 4) range from 2 MB to 20 MB. We also find that the vast majority of apps price themselves under $10. . %matplotlib inline import seaborn as sns sns.set_style(&quot;darkgrid&quot;) import warnings warnings.filterwarnings(&quot;ignore&quot;) # Subset for categories with at least 250 apps large_categories = apps.groupby([&#39;Category&#39;]).filter(lambda x: len(x) &gt;= 250).reset_index() # Plot size vs. rating plt1 = sns.jointplot(x = large_categories[&#39;Size&#39;], y = large_categories[&#39;Rating&#39;], kind = &#39;hex&#39;) # Subset out apps whose type is &#39;Paid&#39; paid_apps = apps[apps[&#39;Type&#39;] == &#39;Paid&#39;] # Plot price vs. rating plt2 = sns.jointplot(x = paid_apps[&#39;Size&#39;], y = paid_apps[&#39;Rating&#39;]) . 6. Relation between app category and app price . So now comes the hard part. How are companies and developers supposed to make ends meet? What monetization strategies can companies use to maximize profit? The costs of apps are largely based on features, complexity, and platform. . There are many factors to consider when selecting the right pricing strategy for your mobile app. It is important to consider the willingness of your customer to pay for your app. A wrong price could break the deal before the download even happens. Potential customers could be turned off by what they perceive to be a shocking cost, or they might delete an app they’ve downloaded after receiving too many ads or simply not getting their money&#39;s worth. . Different categories demand different price ranges. Some apps that are simple and used daily, like the calculator app, should probably be kept free. However, it would make sense to charge for a highly-specialized medical app that diagnoses diabetic patients. Below, we see that Medical and Family apps are the most expensive. Some medical apps extend even up to $80! All game apps are reasonably priced below $20. . import matplotlib.pyplot as plt fig, ax = plt.subplots() fig.set_size_inches(15, 8) # Select a few popular app categories popular_app_cats = apps[apps.Category.isin([&#39;GAME&#39;, &#39;FAMILY&#39;, &#39;PHOTOGRAPHY&#39;, &#39;MEDICAL&#39;, &#39;TOOLS&#39;, &#39;FINANCE&#39;, &#39;LIFESTYLE&#39;,&#39;BUSINESS&#39;])] # Examine the price trend by plotting Price vs Category ax = sns.stripplot(x = popular_app_cats[&#39;Price&#39;], y = popular_app_cats[&#39;Category&#39;], jitter=True, linewidth=1) ax.set_title(&#39;App pricing trend across categories&#39;) # Apps whose Price is greater than 200 apps_above_200 = popular_app_cats[[&#39;Category&#39;, &#39;App&#39;, &#39;Price&#39;]][popular_app_cats[&#39;Price&#39;] &gt; 200] apps_above_200 . Category App Price . 3327 FAMILY | most expensive app (H) | 399.99 | . 3465 LIFESTYLE | 💎 I&#39;m rich | 399.99 | . 3469 LIFESTYLE | I&#39;m Rich - Trump Edition | 400.00 | . 4396 LIFESTYLE | I am rich | 399.99 | . 4398 FAMILY | I am Rich Plus | 399.99 | . 4399 LIFESTYLE | I am rich VIP | 299.99 | . 4400 FINANCE | I Am Rich Premium | 399.99 | . 4401 LIFESTYLE | I am extremely Rich | 379.99 | . 4402 FINANCE | I am Rich! | 399.99 | . 4403 FINANCE | I am rich(premium) | 399.99 | . 4406 FAMILY | I Am Rich Pro | 399.99 | . 4408 FINANCE | I am rich (Most expensive app) | 399.99 | . 4410 FAMILY | I Am Rich | 389.99 | . 4413 FINANCE | I am Rich | 399.99 | . 4417 FINANCE | I AM RICH PRO PLUS | 399.99 | . 8763 FINANCE | Eu Sou Rico | 394.99 | . 8780 LIFESTYLE | I&#39;m Rich/Eu sou Rico/أنا غني/我很有錢 | 399.99 | . 7. Filter out &quot;junk&quot; apps . It looks like a bunch of the really expensive apps are &quot;junk&quot; apps. That is, apps that don&#39;t really have a purpose. Some app developer may create an app called I Am Rich Premium or most expensive app (H) just for a joke or to test their app development skills. Some developers even do this with malicious intent and try to make money by hoping people accidentally click purchase on their app in the store. . Let&#39;s filter out these junk apps and re-do our visualization. The distribution of apps under $20 becomes clearer. . apps_under_100 = popular_app_cats[popular_app_cats[&#39;Price&#39;] &lt; 100] fig, ax = plt.subplots() fig.set_size_inches(15, 8) # Examine price vs category with the authentic apps ax = sns.stripplot(x=apps_under_100[&#39;Price&#39;], y=apps_under_100[&#39;Category&#39;], data=apps_under_100, jitter=True, linewidth=1) ax.set_title(&#39;App pricing trend across categories after filtering for junk apps&#39;) . Text(0.5, 1.0, &#39;App pricing trend across categories after filtering for junk apps&#39;) . 8. Popularity of paid apps vs free apps . For apps in the Play Store today, there are five types of pricing strategies: free, freemium, paid, paymium, and subscription. Let&#39;s focus on free and paid apps only. Some characteristics of free apps are: . Free to download. | Main source of income often comes from advertisements. | Often created by companies that have other products and the app serves as an extension of those products. | Can serve as a tool for customer retention, communication, and customer service. | . Some characteristics of paid apps are: . Users are asked to pay once for the app to download and use it. | The user can&#39;t really get a feel for the app before buying it. | . Are paid apps installed as much as free apps? It turns out that paid apps have a relatively lower number of installs than free apps, though the difference is not as stark as I would have expected! . trace0 = go.Box( # Data for paid apps y=apps[apps[&#39;Type&#39;] == &#39;Paid&#39;][&#39;Installs&#39;], name = &#39;Paid&#39; ) trace1 = go.Box( # Data for free apps y=apps[apps[&#39;Type&#39;] == &#39;Free&#39;][&#39;Installs&#39;], name = &#39;Free&#39; ) layout = go.Layout( title = &quot;Number of downloads of paid apps vs. free apps&quot;, yaxis = dict( type = &#39;log&#39;, autorange = True ) ) # Add trace0 and trace1 to a list for plotting data = [trace0, trace1] plotly.offline.iplot({&#39;data&#39;: data, &#39;layout&#39;: layout}) . 9. Sentiment analysis of user reviews . Mining user review data to determine how people feel about your product, brand, or service can be done using a technique called sentiment analysis. User reviews for apps can be analyzed to identify if the mood is positive, negative or neutral about that app. For example, positive words in an app review might include words such as &#39;amazing&#39;, &#39;friendly&#39;, &#39;good&#39;, &#39;great&#39;, and &#39;love&#39;. Negative words might be words like &#39;malware&#39;, &#39;hate&#39;, &#39;problem&#39;, &#39;refund&#39;, and &#39;incompetent&#39;. . By plotting sentiment polarity scores of user reviews for paid and free apps, we observe that free apps receive a lot of harsh comments, as indicated by the outliers on the negative y-axis. Reviews for paid apps appear never to be extremely negative. This may indicate something about app quality, i.e., paid apps being of higher quality than free apps on average. The median polarity score for paid apps is a little higher than free apps, thereby syncing with our previous observation. . In this notebook, we analyzed over ten thousand apps from the Google Play Store. We can use our findings to inform our decisions should we ever wish to create an app ourselves. . reviews_df = pd.read_csv(&#39;datasets/user_reviews.csv&#39;) # Join and merge the two dataframe merged_df = pd.merge(apps, reviews_df, on = &#39;App&#39;, how = &quot;inner&quot;) # Drop NA values from Sentiment and Translated_Review columns merged_df = merged_df.dropna(subset=[&#39;Sentiment&#39;, &#39;Translated_Review&#39;]) sns.set_style(&#39;ticks&#39;) fig, ax = plt.subplots() fig.set_size_inches(11, 8) # User review sentiment polarity for paid vs. free apps ax = sns.boxplot(x = &#39;Type&#39;, y = &#39;Sentiment_Polarity&#39;, data = merged_df) ax.set_title(&#39;Sentiment Polarity Distribution&#39;) . Text(0.5, 1.0, &#39;Sentiment Polarity Distribution&#39;) .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/04/23/The-Android-App-Market-on-Google-Play.html",
            "relUrl": "/datacamp/projects/python/2020/04/23/The-Android-App-Market-on-Google-Play.html",
            "date": " • Apr 23, 2020"
        }
        
    
  
    
        ,"post26": {
            "title": "A New Era of Data Analysis in Baseball",
            "content": "1. The Statcast revolution . This is Aaron Judge. Judge is one of the physically largest players in Major League Baseball standing 6 feet 7 inches (2.01 m) tall and weighing 282 pounds (128 kg). He also hit the hardest home run ever recorded. How do we know this? Statcast. . Statcast is a state-of-the-art tracking system that uses high-resolution cameras and radar equipment to measure the precise location and movement of baseballs and baseball players. Introduced in 2015 to all 30 major league ballparks, Statcast data is revolutionizing the game. Teams are engaging in an &quot;arms race&quot; of data analysis, hiring analysts left and right in an attempt to gain an edge over their competition. This video describing the system is incredible. . In this notebook, we&#39;re going to wrangle, analyze, and visualize Statcast data to compare Mr. Judge and another (extremely large) teammate of his. Let&#39;s start by loading the data into our Notebook. There are two CSV files, judge.csv and stanton.csv, both of which contain Statcast data for 2015-2017. We&#39;ll use pandas DataFrames to store this data. Let&#39;s also load our data visualization libraries, matplotlib and seaborn. . import pandas as pd import matplotlib.pyplot as plt import seaborn as sns %matplotlib inline # Load Aaron Judge&#39;s Statcast data judge = pd.read_csv(&#39;datasets/judge.csv&#39;) # Load Giancarlo Stanton&#39;s Statcast data stanton = pd.read_csv(&#39;datasets/stanton.csv&#39;) . 2. What can Statcast measure? . The better question might be, what can&#39;t Statcast measure? . Starting with the pitcher, Statcast can measure simple data points such as velocity. At the same time, Statcast digs a whole lot deeper, also measuring the release point and spin rate of every pitch. . Moving on to hitters, Statcast is capable of measuring the exit velocity, launch angle and vector of the ball as it comes off the bat. From there, Statcast can also track the hang time and projected distance that a ball travels. . Let&#39;s inspect the last five rows of the judge DataFrame. You&#39;ll see that each row represents one pitch thrown to a batter. You&#39;ll also see that some columns have esoteric names. If these don&#39;t make sense now, don&#39;t worry. The relevant ones will be explained as necessary. . pd.set_option(&#39;display.max_columns&#39;, None) # Display the last five rows of the Aaron Judge file judge.tail() . pitch_type game_date release_speed release_pos_x release_pos_z player_name batter pitcher events description spin_dir spin_rate_deprecated break_angle_deprecated break_length_deprecated zone des game_type stand p_throws home_team away_team type hit_location bb_type balls strikes game_year pfx_x pfx_z plate_x plate_z on_3b on_2b on_1b outs_when_up inning inning_topbot hc_x hc_y tfs_deprecated tfs_zulu_deprecated pos2_person_id umpire sv_id vx0 vy0 vz0 ax ay az sz_top sz_bot hit_distance_sc launch_speed launch_angle effective_speed release_spin_rate release_extension game_pk pos1_person_id pos2_person_id.1 pos3_person_id pos4_person_id pos5_person_id pos6_person_id pos7_person_id pos8_person_id pos9_person_id release_pos_y estimated_ba_using_speedangle estimated_woba_using_speedangle woba_value woba_denom babip_value iso_value launch_speed_angle at_bat_number pitch_number . 3431 CH | 2016-08-13 | 85.6 | -1.9659 | 5.9113 | Aaron Judge | 592450 | 542882 | NaN | ball | NaN | NaN | NaN | NaN | 14.0 | NaN | R | R | R | NYY | TB | B | NaN | NaN | 0 | 0 | 2016 | -0.379108 | 0.370567 | 0.739 | 1.442 | NaN | NaN | NaN | 0 | 5 | Bot | NaN | NaN | NaN | NaN | 571912.0 | NaN | 160813_144259 | 6.960 | -124.371 | -4.756 | -2.821 | 23.634 | -30.220 | 3.93 | 1.82 | NaN | NaN | NaN | 84.459 | 1552.0 | 5.683 | 448611 | 542882.0 | 571912.0 | 543543.0 | 523253.0 | 446334.0 | 622110.0 | 545338.0 | 595281.0 | 543484.0 | 54.8144 | 0.00 | 0.000 | NaN | NaN | NaN | NaN | NaN | 36 | 1 | . 3432 CH | 2016-08-13 | 87.6 | -1.9318 | 5.9349 | Aaron Judge | 592450 | 542882 | home_run | hit_into_play_score | NaN | NaN | NaN | NaN | 4.0 | Aaron Judge homers (1) on a fly ball to center... | R | R | R | NYY | TB | X | NaN | fly_ball | 1 | 2 | 2016 | -0.295608 | 0.320400 | -0.419 | 3.273 | NaN | NaN | NaN | 2 | 2 | Bot | 130.45 | 14.58 | NaN | NaN | 571912.0 | NaN | 160813_135833 | 4.287 | -127.452 | -0.882 | -1.972 | 24.694 | -30.705 | 4.01 | 1.82 | 446.0 | 108.8 | 27.410 | 86.412 | 1947.0 | 5.691 | 448611 | 542882.0 | 571912.0 | 543543.0 | 523253.0 | 446334.0 | 622110.0 | 545338.0 | 595281.0 | 543484.0 | 54.8064 | 0.98 | 1.937 | 2.0 | 1.0 | 0.0 | 3.0 | 6.0 | 14 | 4 | . 3433 CH | 2016-08-13 | 87.2 | -2.0285 | 5.8656 | Aaron Judge | 592450 | 542882 | NaN | ball | NaN | NaN | NaN | NaN | 14.0 | NaN | R | R | R | NYY | TB | B | NaN | NaN | 0 | 2 | 2016 | -0.668575 | 0.198567 | 0.561 | 0.960 | NaN | NaN | NaN | 2 | 2 | Bot | NaN | NaN | NaN | NaN | 571912.0 | NaN | 160813_135815 | 7.491 | -126.665 | -5.862 | -6.393 | 21.952 | -32.121 | 4.01 | 1.82 | NaN | NaN | NaN | 86.368 | 1761.0 | 5.721 | 448611 | 542882.0 | 571912.0 | 543543.0 | 523253.0 | 446334.0 | 622110.0 | 545338.0 | 595281.0 | 543484.0 | 54.7770 | 0.00 | 0.000 | NaN | NaN | NaN | NaN | NaN | 14 | 3 | . 3434 CU | 2016-08-13 | 79.7 | -1.7108 | 6.1926 | Aaron Judge | 592450 | 542882 | NaN | foul | NaN | NaN | NaN | NaN | 4.0 | NaN | R | R | R | NYY | TB | S | NaN | NaN | 0 | 1 | 2016 | 0.397442 | -0.614133 | -0.803 | 2.742 | NaN | NaN | NaN | 2 | 2 | Bot | NaN | NaN | NaN | NaN | 571912.0 | NaN | 160813_135752 | 1.254 | -116.062 | 0.439 | 5.184 | 21.328 | -39.866 | 4.01 | 1.82 | 9.0 | 55.8 | -24.973 | 77.723 | 2640.0 | 5.022 | 448611 | 542882.0 | 571912.0 | 543543.0 | 523253.0 | 446334.0 | 622110.0 | 545338.0 | 595281.0 | 543484.0 | 55.4756 | 0.00 | 0.000 | NaN | NaN | NaN | NaN | 1.0 | 14 | 2 | . 3435 FF | 2016-08-13 | 93.2 | -1.8476 | 6.0063 | Aaron Judge | 592450 | 542882 | NaN | called_strike | NaN | NaN | NaN | NaN | 8.0 | NaN | R | R | R | NYY | TB | S | NaN | NaN | 0 | 0 | 2016 | -0.823050 | 1.623300 | -0.273 | 2.471 | NaN | NaN | NaN | 2 | 2 | Bot | NaN | NaN | NaN | NaN | 571912.0 | NaN | 160813_135736 | 5.994 | -135.497 | -6.736 | -9.360 | 26.782 | -13.446 | 4.01 | 1.82 | NaN | NaN | NaN | 92.696 | 2271.0 | 6.068 | 448611 | 542882.0 | 571912.0 | 543543.0 | 523253.0 | 446334.0 | 622110.0 | 545338.0 | 595281.0 | 543484.0 | 54.4299 | 0.00 | 0.000 | NaN | NaN | NaN | NaN | NaN | 14 | 1 | . 3. Aaron Judge and Giancarlo Stanton, prolific sluggers . This is Giancarlo Stanton. He is also a very large human being, standing 6 feet 6 inches tall and weighing 245 pounds. Despite not wearing the same jersey as Judge in the pictures provided, in 2018 they will be teammates on the New York Yankees. They are similar in a lot of ways, one being that they hit a lot of home runs. Stanton and Judge led baseball in home runs in 2017, with 59 and 52, respectively. These are exceptional totals - the player in third &quot;only&quot; had 45 home runs. . Stanton and Judge are also different in many ways. One is batted ball events, which is any batted ball that produces a result. This includes outs, hits, and errors. Next, you&#39;ll find the counts of batted ball events for each player in 2017. The frequencies of other events are quite different. . judge_events_2017 = judge[judge[&#39;game_date&#39;] &gt; &#39;2017-01-01&#39;][&#39;events&#39;] print(&quot;Aaron Judge batted ball event totals, 2017:&quot;) print(judge_events_2017.value_counts()) # All of Giancarlo Stanton&#39;s batted ball events in 2017 stanton_events_2017 = stanton[stanton[&#39;game_date&#39;] &gt; &#39;2017-01-01&#39;][&#39;events&#39;] print(&quot; nGiancarlo Stanton batted ball event totals, 2017:&quot;) print(stanton_events_2017.value_counts()) . Aaron Judge batted ball event totals, 2017: strikeout 207 field_out 146 walk 116 single 75 home_run 52 double 24 grounded_into_double_play 15 intent_walk 11 force_out 11 hit_by_pitch 5 sac_fly 4 fielders_choice_out 4 field_error 4 triple 3 strikeout_double_play 1 Name: events, dtype: int64 Giancarlo Stanton batted ball event totals, 2017: field_out 239 strikeout 161 single 77 walk 72 home_run 59 double 32 intent_walk 13 grounded_into_double_play 13 hit_by_pitch 7 force_out 7 field_error 5 sac_fly 3 strikeout_double_play 2 fielders_choice_out 2 pickoff_1b 1 Name: events, dtype: int64 . 4. Analyzing home runs with Statcast data . So Judge walks and strikes out more than Stanton. Stanton flies out more than Judge. But let&#39;s get into their hitting profiles in more detail. Two of the most groundbreaking Statcast metrics are launch angle and exit velocity: . Launch angle: the vertical angle at which the ball leaves a player&#39;s bat | Exit velocity: the speed of the baseball as it comes off the bat | . This new data has changed the way teams value both hitters and pitchers. Why? As per the Washington Post: . Balls hit with a high launch angle are more likely to result in a hit. Hit fast enough and at the right angle, they become home runs. . Let&#39;s look at exit velocity vs. launch angle and let&#39;s focus on home runs only (2015-2017). The first two plots show data points. The second two show smoothed contours to represent density. . judge_hr = judge[judge[&#39;events&#39;] == &#39;home_run&#39;] stanton_hr = stanton[stanton[&#39;events&#39;] == &#39;home_run&#39;] # Create a figure with two scatter plots of launch speed vs. launch angle, one for each player&#39;s home runs fig1, axs1 = plt.subplots(ncols=2, sharex=True, sharey=True) sns.regplot(x=&#39;launch_speed&#39;, y=&#39;launch_angle&#39;, fit_reg=False, color=&#39;tab:blue&#39;, data=judge_hr, ax=axs1[0]).set_title(&#39;Aaron Judge nHome Runs, 2015-2017&#39;) sns.regplot(x=&#39;launch_speed&#39;, y=&#39;launch_angle&#39;, fit_reg=False, color=&#39;tab:blue&#39;, data=stanton_hr, ax=axs1[1]).set_title(&#39;Giancarlo Stanton nHome Runs, 2015-2017&#39;) # Create a figure with two KDE plots of launch speed vs. launch angle, one for each player&#39;s home runs fig2, axs2 = plt.subplots(ncols=2, sharex=True, sharey=True) sns.kdeplot(judge_hr[&#39;launch_speed&#39;], judge_hr[&#39;launch_angle&#39;], cmap=&quot;Blues&quot;, shade=True, shade_lowest=False, ax=axs2[0]).set_title(&#39;Aaron Judge nHome Runs, 2015-2017&#39;) sns.kdeplot(stanton_hr[&#39;launch_speed&#39;], stanton_hr[&#39;launch_angle&#39;], cmap=&quot;Blues&quot;, shade=True, shade_lowest=False, ax=axs2[1]).set_title(&#39;Giancarlo Stanton nHome Runs, 2015-2017&#39;) . Text(0.5,1,&#39;Giancarlo Stanton nHome Runs, 2015-2017&#39;) . 5. Home runs by pitch velocity . It appears that Stanton hits his home runs slightly lower and slightly harder than Judge, though this needs to be taken with a grain of salt given the small sample size of home runs. . Not only does Statcast measure the velocity of the ball coming off of the bat, it measures the velocity of the ball coming out of the pitcher&#39;s hand and begins its journey towards the plate. We can use this data to compare Stanton and Judge&#39;s home runs in terms of pitch velocity. Next you&#39;ll find box plots displaying the five-number summaries for each player: minimum, first quartile, median, third quartile, and maximum. . judge_stanton_hr = pd.concat([judge_hr, stanton_hr], axis=0) # Create a boxplot that describes the pitch velocity of each player&#39;s home runs sns.boxplot(judge_stanton_hr[&#39;release_speed&#39;]).set_title(&#39;Home Runs, 2015-2017&#39;) . Text(0.5,1,&#39;Home Runs, 2015-2017&#39;) . 6. Home runs by pitch location (I) . So Judge appears to hit his home runs off of faster pitches than Stanton. We might call Judge a fastball hitter. Stanton appears agnostic to pitch speed and likely pitch movement since slower pitches (e.g. curveballs, sliders, and changeups) tend to have more break. Statcast does track pitch movement and type but let&#39;s move on to something else: pitch location. Statcast tracks the zone the pitch is in when it crosses the plate. The zone numbering looks like this (from the catcher&#39;s point of view): . . We can plot this using a 2D histogram. For simplicity, let&#39;s only look at strikes, which gives us a 9x9 grid. We can view each zone as coordinates on a 2D plot, the bottom left corner being (1,1) and the top right corner being (3,3). Let&#39;s set up a function to assign x-coordinates to each pitch. . def assign_x_coord(row): &quot;&quot;&quot; Assigns an x-coordinate to Statcast&#39;s strike zone numbers. Zones 11, 12, 13, and 14 are ignored for plotting simplicity. &quot;&quot;&quot; # Left third of strike zone if row.zone in [1, 4, 7]: return 1 # Middle third of strike zone if row.zone in [2, 5, 8]: return 2 # Right third of strike zone if row.zone in [3, 6, 9]: return 3 . 7. Home runs by pitch location (II) . And let&#39;s do the same but for y-coordinates. . def assign_y_coord(row): &quot;&quot;&quot; Assigns a y-coordinate to Statcast&#39;s strike zone numbers. Zones 11, 12, 13, and 14 are ignored for plotting simplicity. &quot;&quot;&quot; # Upper third of strike zone if row.zone in [1, 2, 3]: return 3 # Middle third of strike zone if row.zone in [4, 5, 6]: return 2 # Lower third of strike zone if row.zone in [7, 8, 9]: return 1 . 8. Aaron Judge&#39;s home run zone . Now we can apply the functions we&#39;ve created then construct our 2D histograms. First, for Aaron Judge (again, for pitches in the strike zone that resulted in home runs). . judge_strike_hr = judge_hr.copy().loc[judge_hr.zone &lt;= 9] # Assign Cartesian coordinates to pitches in the strike zone for Judge home runs judge_strike_hr[&#39;zone_x&#39;] = judge_strike_hr.apply(assign_x_coord, axis=1) judge_strike_hr[&#39;zone_y&#39;] = judge_strike_hr.apply(assign_y_coord, axis=1) # Plot Judge&#39;s home run zone as a 2D histogram with a colorbar plt.hist2d(judge_strike_hr[&#39;zone_x&#39;], judge_strike_hr[&#39;zone_y&#39;], bins = 3, cmap=&#39;Blues&#39;) plt.title(&#39;Aaron Judge Home Runs on n Pitches in the Strike Zone, 2015-2017&#39;) plt.gca().get_xaxis().set_visible(False) plt.gca().get_yaxis().set_visible(False) cb = plt.colorbar() cb.set_label(&#39;Counts in Bin&#39;) . 9. Giancarlo Stanton&#39;s home run zone . And now for Giancarlo Stanton. . stanton_strike_hr = stanton_hr.copy().loc[stanton_hr.zone &lt;= 9] # Assign Cartesian coordinates to pitches in the strike zone for Stanton home runs ome runs stanton_strike_hr[&#39;zone_x&#39;] = stanton_strike_hr.apply(assign_x_coord, axis=1) stanton_strike_hr[&#39;zone_y&#39;] = stanton_strike_hr.apply(assign_y_coord, axis=1) # Plot Stanton&#39;s home run zone as a 2D histogram with a colorbar plt.hist2d(stanton_strike_hr[&#39;zone_x&#39;], stanton_strike_hr[&#39;zone_y&#39;], bins = 3, cmap=&#39;Blues&#39;) plt.title(&#39;Giancarlo Stanton Home Runs on n Pitches in the Strike Zone, 2015-2017&#39;) plt.gca().get_xaxis().set_visible(False) plt.gca().get_yaxis().set_visible(False) cb = plt.colorbar() cb.set_label(&#39;Counts in Bin&#39;) . File &#34;&lt;ipython-input-286-e2275b3e6291&gt;&#34;, line 5 ome runs ^ SyntaxError: invalid syntax . 10. Should opposing pitchers be scared? . A few takeaways: . Stanton does not hit many home runs on pitches in the upper third of the strike zone. | Like pretty much every hitter ever, both players love pitches in the horizontal and vertical middle of the plate. | Judge&#39;s least favorite home run pitch appears to be high-away while Stanton&#39;s appears to be low-away. | If we were to describe Stanton&#39;s home run zone, it&#39;d be middle-inside. Judge&#39;s home run zone is much more spread out. | . The grand takeaway from this whole exercise: Aaron Judge and Giancarlo Stanton are not identical despite their superficial similarities. In terms of home runs, their launch profiles, as well as their pitch speed and location preferences, are different. . Should opposing pitchers still be scared? . should_pitchers_be_scared = True .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/04/08/A-New-Era-of-Data-Analysis-in-Baseball.html",
            "relUrl": "/datacamp/projects/python/2020/04/08/A-New-Era-of-Data-Analysis-in-Baseball.html",
            "date": " • Apr 8, 2020"
        }
        
    
  
    
        ,"post27": {
            "title": "Visualizing COVID-19",
            "content": "1. From epidemic to pandemic . In December 2019, COVID-19 coronavirus was first identified in the Wuhan region of China. By March 11, 2020, the World Health Organization (WHO) categorized the COVID-19 outbreak as a pandemic. A lot has happened in the months in between with major outbreaks in Iran, South Korea, and Italy. . We know that COVID-19 spreads through respiratory droplets, such as through coughing, sneezing, or speaking. But, how quickly did the virus spread across the globe? And, can we see any effect from country-wide policies, like shutdowns and quarantines? . Fortunately, organizations around the world have been collecting data so that governments can monitor and learn from this pandemic. Notably, the Johns Hopkins University Center for Systems Science and Engineering created a publicly available data repository to consolidate this data from sources like the WHO, the Centers for Disease Control and Prevention (CDC), and the Ministry of Health from multiple countries. . In this notebook, you will visualize COVID-19 data from the first several weeks of the outbreak to see at what point this virus became a global pandemic. . Please note that information and data regarding COVID-19 is frequently being updated. The data used in this project was pulled on March 17, 2020, and should not be considered to be the most up to date data available. . library(readr) library(ggplot2) library(dplyr) # Read datasets/confirmed_cases_worldwide.csv into confirmed_cases_worldwide confirmed_cases_worldwide &lt;- read_csv(&#39;datasets/confirmed_cases_worldwide.csv&#39;) # See the result confirmed_cases_worldwide . Parsed with column specification: cols( date = col_date(format = &#34;&#34;), cum_cases = col_double() ) . A spec_tbl_df: 56 x 2 datecum_cases . &lt;date&gt;&lt;dbl&gt; . 2020-01-22 | 555 | . 2020-01-23 | 653 | . 2020-01-24 | 941 | . 2020-01-25 | 1434 | . 2020-01-26 | 2118 | . 2020-01-27 | 2927 | . 2020-01-28 | 5578 | . 2020-01-29 | 6166 | . 2020-01-30 | 8234 | . 2020-01-31 | 9927 | . 2020-02-01 | 12038 | . 2020-02-02 | 16787 | . 2020-02-03 | 19881 | . 2020-02-04 | 23892 | . 2020-02-05 | 27635 | . 2020-02-06 | 30817 | . 2020-02-07 | 34391 | . 2020-02-08 | 37120 | . 2020-02-09 | 40150 | . 2020-02-10 | 42762 | . 2020-02-11 | 44802 | . 2020-02-12 | 45221 | . 2020-02-13 | 60368 | . 2020-02-14 | 66885 | . 2020-02-15 | 69030 | . 2020-02-16 | 71224 | . 2020-02-17 | 73258 | . 2020-02-18 | 75136 | . 2020-02-19 | 75639 | . 2020-02-20 | 76197 | . 2020-02-21 | 76823 | . 2020-02-22 | 78579 | . 2020-02-23 | 78965 | . 2020-02-24 | 79568 | . 2020-02-25 | 80413 | . 2020-02-26 | 81395 | . 2020-02-27 | 82754 | . 2020-02-28 | 84120 | . 2020-02-29 | 86011 | . 2020-03-01 | 88369 | . 2020-03-02 | 90306 | . 2020-03-03 | 92840 | . 2020-03-04 | 95120 | . 2020-03-05 | 97882 | . 2020-03-06 | 101784 | . 2020-03-07 | 105821 | . 2020-03-08 | 109795 | . 2020-03-09 | 113561 | . 2020-03-10 | 118592 | . 2020-03-11 | 125865 | . 2020-03-12 | 128343 | . 2020-03-13 | 145193 | . 2020-03-14 | 156097 | . 2020-03-15 | 167449 | . 2020-03-16 | 181531 | . 2020-03-17 | 197146 | . 2. Confirmed cases throughout the world . The table above shows the cumulative confirmed cases of COVID-19 worldwide by date. Just reading numbers in a table makes it hard to get a sense of the scale and growth of the outbreak. Let&#39;s draw a line plot to visualize the confirmed cases worldwide. . # Label the y-axis ggplot(data=confirmed_cases_worldwide, aes(x=date, y=cum_cases)) + geom_line() + geom_point() + ylab(&quot;Cumulative confirmed cases&quot;) . 3. China compared to the rest of the world . The y-axis in that plot is pretty scary, with the total number of confirmed cases around the world approaching 200,000. Beyond that, some weird things are happening: there is an odd jump in mid February, then the rate of new cases slows down for a while, then speeds up again in March. We need to dig deeper to see what is happening. . Early on in the outbreak, the COVID-19 cases were primarily centered in China. Let&#39;s plot confirmed COVID-19 cases in China and the rest of the world separately to see if it gives us any insight. . We&#39;ll build on this plot in future tasks. One thing that will be important for the following tasks is that you add aesthetics within the line geometry of your ggplot, rather than making them global aesthetics. . confirmed_cases_china_vs_world &lt;- read_csv(&#39;datasets/confirmed_cases_china_vs_world.csv&#39;) # See the result confirmed_cases_china_vs_world # Draw a line plot of cumulative cases vs. date, grouped and colored by is_china # Define aesthetics within the line geom plt_cum_confirmed_cases_china_vs_world &lt;- ggplot(data=confirmed_cases_china_vs_world) + geom_line(aes(x=date, y=cum_cases, group=is_china, color=is_china)) + ylab(&quot;Cumulative confirmed cases&quot;) # See the plot plt_cum_confirmed_cases_china_vs_world . Parsed with column specification: cols( is_china = col_character(), date = col_date(format = &#34;&#34;), cases = col_double(), cum_cases = col_double() ) . A spec_tbl_df: 112 x 4 is_chinadatecasescum_cases . &lt;chr&gt;&lt;date&gt;&lt;dbl&gt;&lt;dbl&gt; . China | 2020-01-22 | 548 | 548 | . China | 2020-01-23 | 95 | 643 | . China | 2020-01-24 | 277 | 920 | . China | 2020-01-25 | 486 | 1406 | . China | 2020-01-26 | 669 | 2075 | . China | 2020-01-27 | 802 | 2877 | . China | 2020-01-28 | 2632 | 5509 | . China | 2020-01-29 | 578 | 6087 | . China | 2020-01-30 | 2054 | 8141 | . China | 2020-01-31 | 1661 | 9802 | . China | 2020-02-01 | 2089 | 11891 | . China | 2020-02-02 | 4739 | 16630 | . China | 2020-02-03 | 3086 | 19716 | . China | 2020-02-04 | 3991 | 23707 | . China | 2020-02-05 | 3733 | 27440 | . China | 2020-02-06 | 3147 | 30587 | . China | 2020-02-07 | 3523 | 34110 | . China | 2020-02-08 | 2704 | 36814 | . China | 2020-02-09 | 3015 | 39829 | . China | 2020-02-10 | 2525 | 42354 | . China | 2020-02-11 | 2032 | 44386 | . China | 2020-02-12 | 373 | 44759 | . China | 2020-02-13 | 15136 | 59895 | . China | 2020-02-14 | 6463 | 66358 | . China | 2020-02-15 | 2055 | 68413 | . China | 2020-02-16 | 2100 | 70513 | . China | 2020-02-17 | 1921 | 72434 | . China | 2020-02-18 | 1777 | 74211 | . China | 2020-02-19 | 408 | 74619 | . China | 2020-02-20 | 458 | 75077 | . ... | ... | ... | ... | . Not China | 2020-02-17 | 113 | 824 | . Not China | 2020-02-18 | 101 | 925 | . Not China | 2020-02-19 | 95 | 1020 | . Not China | 2020-02-20 | 100 | 1120 | . Not China | 2020-02-21 | 153 | 1273 | . Not China | 2020-02-22 | 305 | 1578 | . Not China | 2020-02-23 | 365 | 1943 | . Not China | 2020-02-24 | 384 | 2327 | . Not China | 2020-02-25 | 332 | 2659 | . Not China | 2020-02-26 | 570 | 3229 | . Not China | 2020-02-27 | 925 | 4154 | . Not China | 2020-02-28 | 1038 | 5192 | . Not China | 2020-02-29 | 1463 | 6655 | . Not China | 2020-03-01 | 1782 | 8437 | . Not China | 2020-03-02 | 1733 | 10170 | . Not China | 2020-03-03 | 2409 | 12579 | . Not China | 2020-03-04 | 2155 | 14734 | . Not China | 2020-03-05 | 2611 | 17345 | . Not China | 2020-03-06 | 3749 | 21094 | . Not China | 2020-03-07 | 3957 | 25051 | . Not China | 2020-03-08 | 3921 | 28972 | . Not China | 2020-03-09 | 3729 | 32701 | . Not China | 2020-03-10 | 5004 | 37705 | . Not China | 2020-03-11 | 7239 | 44944 | . Not China | 2020-03-12 | 2467 | 47411 | . Not China | 2020-03-13 | 16837 | 64248 | . Not China | 2020-03-14 | 10872 | 75120 | . Not China | 2020-03-15 | 11326 | 86446 | . Not China | 2020-03-16 | 14052 | 100498 | . Not China | 2020-03-17 | 15590 | 116088 | . 4. Let&#39;s annotate! . Wow! The two lines have very different shapes. In February, the majority of cases were in China. That changed in March when it really became a global outbreak: around March 14, the total number of cases outside China overtook the cases inside China. This was days after the WHO declared a pandemic. . There were a couple of other landmark events that happened during the outbreak. For example, the huge jump in the China line on February 13, 2020 wasn&#39;t just a bad day regarding the outbreak; China changed the way it reported figures on that day (CT scans were accepted as evidence for COVID-19, rather than only lab tests). . By annotating events like this, we can better interpret changes in the plot. . who_events &lt;- tribble( ~ date, ~ event, &quot;2020-01-30&quot;, &quot;Global health nemergency declared&quot;, &quot;2020-03-11&quot;, &quot;Pandemic ndeclared&quot;, &quot;2020-02-13&quot;, &quot;China reporting nchange&quot; ) %&gt;% mutate(date = as.Date(date)) # Using who_events, add vertical dashed lines with an xintercept at date # and text at date, labeled by event, and at 100000 on the y-axis plt_cum_confirmed_cases_china_vs_world + geom_vline(data=who_events, linetype=&#39;dashed&#39;, aes(xintercept=date)) + geom_text(data=who_events, y=1e+05, aes(x=date, label=event)) . 5. Adding a trend line to China . When trying to assess how big future problems are going to be, we need a measure of how fast the number of cases is growing. A good starting point is to see if the cases are growing faster or slower than linearly. . There is a clear surge of cases around February 13, 2020, with the reporting change in China. However, a couple of days after, the growth of cases in China slows down. How can we describe COVID-19&#39;s growth in China after February 15, 2020? . china_after_feb15 &lt;- filter(confirmed_cases_china_vs_world, date &gt;= &quot;2020-02-15&quot; &amp; is_china == &#39;China&#39;) # Using china_after_feb15, draw a line plot cum_cases vs. date # Add a smooth trend line using linear regression, no error bars ggplot(data=china_after_feb15, aes(x=date, y=cum_cases)) + geom_line() + geom_smooth(method=&#39;lm&#39;, se=FALSE) + ylab(&quot;Cumulative confirmed cases&quot;) . `geom_smooth()` using formula &#39;y ~ x&#39; . 6. And the rest of the world? . From the plot above, the growth rate in China is slower than linear. That&#39;s great news because it indicates China has at least somewhat contained the virus in late February and early March. . How does the rest of the world compare to linear growth? . not_china &lt;- filter(confirmed_cases_china_vs_world, is_china != &#39;China&#39;) # Using not_china, draw a line plot cum_cases vs. date # Add a smooth trend line using linear regression, no error bars plt_not_china_trend_lin &lt;- ggplot(data=not_china, aes(x=date, y=cum_cases)) + geom_line() + geom_smooth(method=&#39;lm&#39;, se=FALSE) + ylab(&quot;Cumulative confirmed cases&quot;) # See the result plt_not_china_trend_lin . `geom_smooth()` using formula &#39;y ~ x&#39; . 7. Adding a logarithmic scale . From the plot above, we can see a straight line does not fit well at all, and the rest of the world is growing much faster than linearly. What if we added a logarithmic scale to the y-axis? . plt_not_china_trend_lin + scale_y_log10(TRUE) . `geom_smooth()` using formula &#39;y ~ x&#39; . 8. Which countries outside of China have been hit hardest? . With the logarithmic scale, we get a much closer fit to the data. From a data science point of view, a good fit is great news. Unfortunately, from a public health point of view, that means that cases of COVID-19 in the rest of the world are growing at an exponential rate, which is terrible news. . Not all countries are being affected by COVID-19 equally, and it would be helpful to know where in the world the problems are greatest. Let&#39;s find the countries outside of China with the most confirmed cases in our dataset. . confirmed_cases_by_country &lt;- read_csv(&quot;datasets/confirmed_cases_by_country.csv&quot;) glimpse(confirmed_cases_by_country) # Group by country, summarize to calculate total cases, find the top 7 top_countries_by_total_cases &lt;- confirmed_cases_by_country %&gt;% group_by(country) %&gt;% summarise(confirmed_cases_by_country = max(cum_cases)) %&gt;% top_n(7) # See the result top_countries_by_total_cases . Parsed with column specification: cols( country = col_character(), province = col_character(), date = col_date(format = &#34;&#34;), cases = col_double(), cum_cases = col_double() ) . Observations: 13,272 Variables: 5 $ country &lt;chr&gt; &#34;Afghanistan&#34;, &#34;Albania&#34;, &#34;Algeria&#34;, &#34;Andorra&#34;, &#34;Antigua ... $ province &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N... $ date &lt;date&gt; 2020-01-22, 2020-01-22, 2020-01-22, 2020-01-22, 2020-01-... $ cases &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... $ cum_cases &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... . Selecting by confirmed_cases_by_country . A tibble: 7 x 2 countryconfirmed_cases_by_country . &lt;chr&gt;&lt;dbl&gt; . France | 7699 | . Germany | 9257 | . Iran | 16169 | . Italy | 31506 | . Korea, South | 8320 | . Spain | 11748 | . US | 6421 | . 9. Plotting hardest hit countries as of Mid-March 2020 . Even though the outbreak was first identified in China, there is only one country from East Asia (South Korea) in the above table. Four of the listed countries (France, Germany, Italy, and Spain) are in Europe and share borders. To get more context, we can plot these countries&#39; confirmed cases over time. . Finally, congratulations on getting to the last step! If you would like to continue making visualizations or find the hardest hit countries as of today, you can do your own analyses with the latest data available here. . confirmed_cases_top7_outside_china = read_csv(&#39;datasets/confirmed_cases_top7_outside_china.csv&#39;) # glimpse(confirmed_cases_top7_outside_china) # Using confirmed_cases_top7_outside_china, draw a line plot of # cum_cases vs. date, grouped and colored by country ggplot(data=confirmed_cases_top7_outside_china, aes(x=date, y=cum_cases)) + geom_line(aes(color=country, group=country)) + ylab(&quot;Cumulative confirmed cases&quot;) . Parsed with column specification: cols( country = col_character(), date = col_date(format = &#34;&#34;), cum_cases = col_double() ) . Observations: 2,030 Variables: 3 $ country &lt;chr&gt; &#34;Germany&#34;, &#34;Iran&#34;, &#34;Italy&#34;, &#34;Korea, South&#34;, &#34;Spain&#34;, &#34;US&#34;... $ date &lt;date&gt; 2020-02-18, 2020-02-18, 2020-02-18, 2020-02-18, 2020-02-... $ cum_cases &lt;dbl&gt; 16, 0, 3, 31, 2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, ... .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/r/2020/04/03/Visualizing-COVID-19.html",
            "relUrl": "/datacamp/projects/r/2020/04/03/Visualizing-COVID-19.html",
            "date": " • Apr 3, 2020"
        }
        
    
  
    
        ,"post28": {
            "title": "Predicting Credit Card Approvals",
            "content": "1. Credit card applications . Commercial banks receive a lot of applications for credit cards. Many of them get rejected for many reasons, like high loan balances, low income levels, or too many inquiries on an individual&#39;s credit report, for example. Manually analyzing these applications is mundane, error-prone, and time-consuming (and time is money!). Luckily, this task can be automated with the power of machine learning and pretty much every commercial bank does so nowadays. In this notebook, we will build an automatic credit card approval predictor using machine learning techniques, just like the real banks do. . . We&#39;ll use the Credit Card Approval dataset from the UCI Machine Learning Repository. The structure of this notebook is as follows: . First, we will start off by loading and viewing the dataset. | We will see that the dataset has a mixture of both numerical and non-numerical features, that it contains values from different ranges, plus that it contains a number of missing entries. | We will have to preprocess the dataset to ensure the machine learning model we choose can make good predictions. | After our data is in good shape, we will do some exploratory data analysis to build our intuitions. | Finally, we will build a machine learning model that can predict if an individual&#39;s application for a credit card will be accepted. | . First, loading and viewing the dataset. We find that since this data is confidential, the contributor of the dataset has anonymized the feature names. . import pandas as pd # Load dataset cc_apps = pd.read_csv(&#39;datasets/cc_approvals.data&#39;, header=None) # Inspect data cc_apps.head() . 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . 0 b | 30.83 | 0.000 | u | g | w | v | 1.25 | t | t | 1 | f | g | 00202 | 0 | + | . 1 a | 58.67 | 4.460 | u | g | q | h | 3.04 | t | t | 6 | f | g | 00043 | 560 | + | . 2 a | 24.50 | 0.500 | u | g | q | h | 1.50 | t | f | 0 | f | g | 00280 | 824 | + | . 3 b | 27.83 | 1.540 | u | g | w | v | 3.75 | t | t | 5 | t | g | 00100 | 3 | + | . 4 b | 20.17 | 5.625 | u | g | w | v | 1.71 | t | f | 0 | f | s | 00120 | 0 | + | . 2. Inspecting the applications . The output may appear a bit confusing at its first sight, but let&#39;s try to figure out the most important features of a credit card application. The features of this dataset have been anonymized to protect the privacy, but this blog gives us a pretty good overview of the probable features. The probable features in a typical credit card application are Gender, Age, Debt, Married, BankCustomer, EducationLevel, Ethnicity, YearsEmployed, PriorDefault, Employed, CreditScore, DriversLicense, Citizen, ZipCode, Income and finally the ApprovalStatus. This gives us a pretty good starting point, and we can map these features with respect to the columns in the output. . As we can see from our first glance at the data, the dataset has a mixture of numerical and non-numerical features. This can be fixed with some preprocessing, but before we do that, let&#39;s learn about the dataset a bit more to see if there are other dataset issues that need to be fixed. . cc_apps_description = cc_apps.describe() print(cc_apps_description) print(&quot; n&quot;) # Print DataFrame information cc_apps_info = cc_apps.info() print(cc_apps_info) print(&quot; n&quot;) # Inspect missing values in the dataset cc_apps.tail(17) . 2 7 10 14 count 690.000000 690.000000 690.00000 690.000000 mean 4.758725 2.223406 2.40000 1017.385507 std 4.978163 3.346513 4.86294 5210.102598 min 0.000000 0.000000 0.00000 0.000000 25% 1.000000 0.165000 0.00000 0.000000 50% 2.750000 1.000000 0.00000 5.000000 75% 7.207500 2.625000 3.00000 395.500000 max 28.000000 28.500000 67.00000 100000.000000 &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 690 entries, 0 to 689 Data columns (total 16 columns): 0 690 non-null object 1 690 non-null object 2 690 non-null float64 3 690 non-null object 4 690 non-null object 5 690 non-null object 6 690 non-null object 7 690 non-null float64 8 690 non-null object 9 690 non-null object 10 690 non-null int64 11 690 non-null object 12 690 non-null object 13 690 non-null object 14 690 non-null int64 15 690 non-null object dtypes: float64(2), int64(2), object(12) memory usage: 86.3+ KB None . 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . 673 ? | 29.50 | 2.000 | y | p | e | h | 2.000 | f | f | 0 | f | g | 00256 | 17 | - | . 674 a | 37.33 | 2.500 | u | g | i | h | 0.210 | f | f | 0 | f | g | 00260 | 246 | - | . 675 a | 41.58 | 1.040 | u | g | aa | v | 0.665 | f | f | 0 | f | g | 00240 | 237 | - | . 676 a | 30.58 | 10.665 | u | g | q | h | 0.085 | f | t | 12 | t | g | 00129 | 3 | - | . 677 b | 19.42 | 7.250 | u | g | m | v | 0.040 | f | t | 1 | f | g | 00100 | 1 | - | . 678 a | 17.92 | 10.210 | u | g | ff | ff | 0.000 | f | f | 0 | f | g | 00000 | 50 | - | . 679 a | 20.08 | 1.250 | u | g | c | v | 0.000 | f | f | 0 | f | g | 00000 | 0 | - | . 680 b | 19.50 | 0.290 | u | g | k | v | 0.290 | f | f | 0 | f | g | 00280 | 364 | - | . 681 b | 27.83 | 1.000 | y | p | d | h | 3.000 | f | f | 0 | f | g | 00176 | 537 | - | . 682 b | 17.08 | 3.290 | u | g | i | v | 0.335 | f | f | 0 | t | g | 00140 | 2 | - | . 683 b | 36.42 | 0.750 | y | p | d | v | 0.585 | f | f | 0 | f | g | 00240 | 3 | - | . 684 b | 40.58 | 3.290 | u | g | m | v | 3.500 | f | f | 0 | t | s | 00400 | 0 | - | . 685 b | 21.08 | 10.085 | y | p | e | h | 1.250 | f | f | 0 | f | g | 00260 | 0 | - | . 686 a | 22.67 | 0.750 | u | g | c | v | 2.000 | f | t | 2 | t | g | 00200 | 394 | - | . 687 a | 25.25 | 13.500 | y | p | ff | ff | 2.000 | f | t | 1 | t | g | 00200 | 1 | - | . 688 b | 17.92 | 0.205 | u | g | aa | v | 0.040 | f | f | 0 | f | g | 00280 | 750 | - | . 689 b | 35.00 | 3.375 | u | g | c | h | 8.290 | f | f | 0 | t | g | 00000 | 0 | - | . 3. Handling the missing values (part i) . We&#39;ve uncovered some issues that will affect the performance of our machine learning model(s) if they go unchanged: . Our dataset contains both numeric and non-numeric data (specifically data that are of float64, int64 and object types). Specifically, the features 2, 7, 10 and 14 contain numeric values (of types float64, float64, int64 and int64 respectively) and all the other features contain non-numeric values. | The dataset also contains values from several ranges. Some features have a value range of 0 - 28, some have a range of 2 - 67, and some have a range of 1017 - 100000. Apart from these, we can get useful statistical information (like mean, max, and min) about the features that have numerical values. | Finally, the dataset has missing values, which we&#39;ll take care of in this task. The missing values in the dataset are labeled with &#39;?&#39;, which can be seen in the last cell&#39;s output. | . Now, let&#39;s temporarily replace these missing value question marks with NaN. . import numpy as np # Inspect missing values in the dataset print(cc_apps.tail(17)) # Replace the &#39;?&#39;s with NaN cc_apps = cc_apps.replace(&#39;?&#39;, np.nan) # Inspect the missing values again cc_apps.tail(17) . 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 673 ? 29.50 2.000 y p e h 2.000 f f 0 f g 00256 17 - 674 a 37.33 2.500 u g i h 0.210 f f 0 f g 00260 246 - 675 a 41.58 1.040 u g aa v 0.665 f f 0 f g 00240 237 - 676 a 30.58 10.665 u g q h 0.085 f t 12 t g 00129 3 - 677 b 19.42 7.250 u g m v 0.040 f t 1 f g 00100 1 - 678 a 17.92 10.210 u g ff ff 0.000 f f 0 f g 00000 50 - 679 a 20.08 1.250 u g c v 0.000 f f 0 f g 00000 0 - 680 b 19.50 0.290 u g k v 0.290 f f 0 f g 00280 364 - 681 b 27.83 1.000 y p d h 3.000 f f 0 f g 00176 537 - 682 b 17.08 3.290 u g i v 0.335 f f 0 t g 00140 2 - 683 b 36.42 0.750 y p d v 0.585 f f 0 f g 00240 3 - 684 b 40.58 3.290 u g m v 3.500 f f 0 t s 00400 0 - 685 b 21.08 10.085 y p e h 1.250 f f 0 f g 00260 0 - 686 a 22.67 0.750 u g c v 2.000 f t 2 t g 00200 394 - 687 a 25.25 13.500 y p ff ff 2.000 f t 1 t g 00200 1 - 688 b 17.92 0.205 u g aa v 0.040 f f 0 f g 00280 750 - 689 b 35.00 3.375 u g c h 8.290 f f 0 t g 00000 0 - . 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . 673 NaN | 29.50 | 2.000 | y | p | e | h | 2.000 | f | f | 0 | f | g | 00256 | 17 | - | . 674 a | 37.33 | 2.500 | u | g | i | h | 0.210 | f | f | 0 | f | g | 00260 | 246 | - | . 675 a | 41.58 | 1.040 | u | g | aa | v | 0.665 | f | f | 0 | f | g | 00240 | 237 | - | . 676 a | 30.58 | 10.665 | u | g | q | h | 0.085 | f | t | 12 | t | g | 00129 | 3 | - | . 677 b | 19.42 | 7.250 | u | g | m | v | 0.040 | f | t | 1 | f | g | 00100 | 1 | - | . 678 a | 17.92 | 10.210 | u | g | ff | ff | 0.000 | f | f | 0 | f | g | 00000 | 50 | - | . 679 a | 20.08 | 1.250 | u | g | c | v | 0.000 | f | f | 0 | f | g | 00000 | 0 | - | . 680 b | 19.50 | 0.290 | u | g | k | v | 0.290 | f | f | 0 | f | g | 00280 | 364 | - | . 681 b | 27.83 | 1.000 | y | p | d | h | 3.000 | f | f | 0 | f | g | 00176 | 537 | - | . 682 b | 17.08 | 3.290 | u | g | i | v | 0.335 | f | f | 0 | t | g | 00140 | 2 | - | . 683 b | 36.42 | 0.750 | y | p | d | v | 0.585 | f | f | 0 | f | g | 00240 | 3 | - | . 684 b | 40.58 | 3.290 | u | g | m | v | 3.500 | f | f | 0 | t | s | 00400 | 0 | - | . 685 b | 21.08 | 10.085 | y | p | e | h | 1.250 | f | f | 0 | f | g | 00260 | 0 | - | . 686 a | 22.67 | 0.750 | u | g | c | v | 2.000 | f | t | 2 | t | g | 00200 | 394 | - | . 687 a | 25.25 | 13.500 | y | p | ff | ff | 2.000 | f | t | 1 | t | g | 00200 | 1 | - | . 688 b | 17.92 | 0.205 | u | g | aa | v | 0.040 | f | f | 0 | f | g | 00280 | 750 | - | . 689 b | 35.00 | 3.375 | u | g | c | h | 8.290 | f | f | 0 | t | g | 00000 | 0 | - | . 4. Handling the missing values (part ii) . We replaced all the question marks with NaNs. This is going to help us in the next missing value treatment that we are going to perform. . An important question that gets raised here is why are we giving so much importance to missing values? Can&#39;t they be just ignored? Ignoring missing values can affect the performance of a machine learning model heavily. While ignoring the missing values our machine learning model may miss out on information about the dataset that may be useful for its training. Then, there are many models which cannot handle missing values implicitly such as LDA. . So, to avoid this problem, we are going to impute the missing values with a strategy called mean imputation. . cc_apps[[2, 7, 10, 14]].fillna(pd.DataFrame.mean, inplace=True) # Count the number of NaNs in the dataset to verify cc_apps.isnull().sum() . 0 12 1 12 2 0 3 6 4 6 5 9 6 9 7 0 8 0 9 0 10 0 11 0 12 0 13 13 14 0 15 0 dtype: int64 . 5. Handling the missing values (part iii) . We have successfully taken care of the missing values present in the numeric columns. There are still some missing values to be imputed for columns 0, 1, 3, 4, 5, 6 and 13. All of these columns contain non-numeric data and this why the mean imputation strategy would not work here. This needs a different treatment. . We are going to impute these missing values with the most frequent values as present in the respective columns. This is good practice when it comes to imputing missing values for categorical data in general. . for col in cc_apps.columns: # Check if the column is of object type if cc_apps[col].dtypes == &#39;object&#39;: # Impute with the most frequent value column_val = cc_apps[col].value_counts() cc_apps = cc_apps.fillna(column_val.index[0]) # Count the number of NaNs in the dataset and print the counts to verify print(cc_apps.isnull().sum()) . 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 dtype: int64 . 6. Preprocessing the data (part i) . The missing values are now successfully handled. . There is still some minor but essential data preprocessing needed before we proceed towards building our machine learning model. We are going to divide these remaining preprocessing steps into three main tasks: . Convert the non-numeric data into numeric. | Split the data into train and test sets. | Scale the feature values to a uniform range. | First, we will be converting all the non-numeric values into numeric ones. We do this because not only it results in a faster computation but also many machine learning models (like XGBoost) (and especially the ones developed using scikit-learn) require the data to be in a strictly numeric format. We will do this by using a technique called label encoding. . from sklearn.preprocessing import LabelEncoder # Instantiate LabelEncoder le = LabelEncoder() # Iterate over all the values of each column and extract their dtypes for col in cc_apps.columns: # Compare if the dtype is object if cc_apps[col].dtypes == &#39;object&#39;: # Use LabelEncoder to do the numeric transformation cc_apps[col] = le.fit_transform(cc_apps[col]) . 7. Splitting the dataset into train and test sets . We have successfully converted all the non-numeric values to numeric ones. . Now, we will split our data into train set and test set to prepare our data for two different phases of machine learning modeling: training and testing. Ideally, no information from the test data should be used to scale the training data or should be used to direct the training process of a machine learning model. Hence, we first split the data and then apply the scaling. . Also, features like DriversLicense and ZipCode are not as important as the other features in the dataset for predicting credit card approvals. We should drop them to design our machine learning model with the best set of features. In Data Science literature, this is often referred to as feature selection. . from sklearn.model_selection import train_test_split # Drop the features 11 and 13 and convert the DataFrame to a NumPy array cc_apps = cc_apps.drop([11, 13], axis=1) cc_apps = cc_apps.values # Segregate features and labels into separate variables X,y = cc_apps[:,0:13] , cc_apps[:,13] # Split into train and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42) . 8. Preprocessing the data (part ii) . The data is now split into two separate sets - train and test sets respectively. We are only left with one final preprocessing step of scaling before we can fit a machine learning model to the data. . Now, let&#39;s try to understand what these scaled values mean in the real world. Let&#39;s use CreditScore as an example. The credit score of a person is their creditworthiness based on their credit history. The higher this number, the more financially trustworthy a person is considered to be. So, a CreditScore of 1 is the highest since we&#39;re rescaling all the values to the range of 0-1. . from sklearn.preprocessing import MinMaxScaler # Instantiate MinMaxScaler and use it to rescale X_train and X_test scaler = MinMaxScaler(feature_range=(0, 1)) rescaledX_train = scaler.fit_transform(X_train) rescaledX_test = scaler.fit_transform(X_test) . 9. Fitting a logistic regression model to the train set . Essentially, predicting if a credit card application will be approved or not is a classification task. According to UCI, our dataset contains more instances that correspond to &quot;Denied&quot; status than instances corresponding to &quot;Approved&quot; status. Specifically, out of 690 instances, there are 383 (55.5%) applications that got denied and 307 (44.5%) applications that got approved. . This gives us a benchmark. A good machine learning model should be able to accurately predict the status of the applications with respect to these statistics. . Which model should we pick? A question to ask is: are the features that affect the credit card approval decision process correlated with each other? Although we can measure correlation, that is outside the scope of this notebook, so we&#39;ll rely on our intuition that they indeed are correlated for now. Because of this correlation, we&#39;ll take advantage of the fact that generalized linear models perform well in these cases. Let&#39;s start our machine learning modeling with a Logistic Regression model (a generalized linear model). . from sklearn.linear_model import LogisticRegression # Instantiate a LogisticRegression classifier with default parameter values logreg = LogisticRegression() # Fit logreg to the train set logreg.fit(rescaledX_train, y_train) . LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, max_iter=100, multi_class=&#39;ovr&#39;, n_jobs=1, penalty=&#39;l2&#39;, random_state=None, solver=&#39;liblinear&#39;, tol=0.0001, verbose=0, warm_start=False) . 10. Making predictions and evaluating performance . But how well does our model perform? . We will now evaluate our model on the test set with respect to classification accuracy. But we will also take a look the model&#39;s confusion matrix. In the case of predicting credit card applications, it is equally important to see if our machine learning model is able to predict the approval status of the applications as denied that originally got denied. If our model is not performing well in this aspect, then it might end up approving the application that should have been approved. The confusion matrix helps us to view our model&#39;s performance from these aspects. . from sklearn.metrics import confusion_matrix # Use logreg to predict instances from the test set and store it y_pred = logreg.predict(rescaledX_test) # Get the accuracy score of logreg model and print it print(&quot;Accuracy of logistic regression classifier: &quot;, logreg.score(rescaledX_test, y_test)) # Print the confusion matrix of the logreg model confusion_matrix(y_test, y_pred) . Accuracy of logistic regression classifier: 0.8377192982456141 . array([[92, 11], [26, 99]]) . 11. Grid searching and making the model perform better . Our model was pretty good! It was able to yield an accuracy score of almost 84%. . For the confusion matrix, the first element of the of the first row of the confusion matrix denotes the true negatives meaning the number of negative instances (denied applications) predicted by the model correctly. And the last element of the second row of the confusion matrix denotes the true positives meaning the number of positive instances (approved applications) predicted by the model correctly. . Let&#39;s see if we can do better. We can perform a grid search of the model parameters to improve the model&#39;s ability to predict credit card approvals. . scikit-learn&#39;s implementation of logistic regression consists of different hyperparameters but we will grid search over the following two: . tol | max_iter | . from sklearn.model_selection import GridSearchCV # Define the grid of values for tol and max_iter tol = [0.01, 0.001, 0.0001] max_iter = [100, 150, 200] # Create a dictionary where tol and max_iter are keys and the lists of their values are corresponding values param_grid = dict([[&quot;tol&quot;, &quot;max_iter&quot;], [tol, max_iter]]) . TypeError Traceback (most recent call last) &lt;ipython-input-88-805e51811033&gt; in &lt;module&gt;() 7 8 # Create a dictionary where tol and max_iter are keys and the lists of their values are corresponding values -&gt; 9 param_grid = dict([[&#34;tol&#34;, &#34;max_iter&#34;], [tol, max_iter]]) TypeError: unhashable type: &#39;list&#39; . 12. Finding the best performing model . We have defined the grid of hyperparameter values and converted them into a single dictionary format which GridSearchCV() expects as one of its parameters. Now, we will begin the grid search to see which values perform best. . We will instantiate GridSearchCV() with our earlier logreg model with all the data we have. Instead of passing train and test sets separately, we will supply X (scaled version) and y. We will also instruct GridSearchCV() to perform a cross-validation of five folds. . We&#39;ll end the notebook by storing the best-achieved score and the respective best parameters. . While building this credit card predictor, we tackled some of the most widely-known preprocessing steps such as scaling, label encoding, and missing value imputation. We finished with some machine learning to predict if a person&#39;s application for a credit card would get approved or not given some information about that person. . grid_model = GridSearchCV(estimator=logreg, param_grid=param_grid, cv=5) # Use scaler to rescale X and assign it to rescaledX rescaledX = scaler.fit_transform(X) # Fit data to grid_model grid_model_result = grid_model.fit(rescaledX, y) # Summarize results best_score, best_params = grid_model_result.best_score_, grid_model_result.best_params_ print(&quot;Best: %f using %s&quot; % (best_score, best_params)) . NameError Traceback (most recent call last) &lt;ipython-input-90-d1ddbb5a1b04&gt; in &lt;module&gt;() 1 # Instantiate GridSearchCV with the required parameters -&gt; 2 grid_model = GridSearchCV(estimator=logreg, param_grid=param_grid, cv=5) 3 4 # Use scaler to rescale X and assign it to rescaledX 5 rescaledX = scaler.fit_transform(X) NameError: name &#39;param_grid&#39; is not defined .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/04/03/Predicting-Credit-Card-Approvals.html",
            "relUrl": "/datacamp/projects/python/2020/04/03/Predicting-Credit-Card-Approvals.html",
            "date": " • Apr 3, 2020"
        }
        
    
  
    
        ,"post29": {
            "title": "Exploring the Evolution of Linux",
            "content": "1. Introduction . . Version control repositories like CVS, Subversion or Git can be a real gold mine for software developers. They contain every change to the source code including the date (the &quot;when&quot;), the responsible developer (the &quot;who&quot;), as well as a little message that describes the intention (the &quot;what&quot;) of a change. . In this notebook, we will analyze the evolution of a very famous open-source project &ndash; the Linux kernel. The Linux kernel is the heart of some Linux distributions like Debian, Ubuntu or CentOS. Our dataset at hand contains the history of kernel development of almost 13 years (early 2005 - late 2017). We get some insights into the work of the development efforts by . identifying the TOP 10 contributors and | visualizing the commits over the years. | . import pandas as pd data = pd.read_csv(&#39;datasets/git_log_excerpt.csv&#39;) print(data) . 1502382966#Linus Torvalds 0 1501368308#Max Gurtovoy 1 1501625560#James Smart 2 1501625559#James Smart 3 1500568442#Martin Wilck 4 1502273719#Xin Long 5 1502278684#Nikolay Borisov 6 1502238384#Girish Moodalbail 7 1502228709#Florian Fainelli 8 1502223836#Jon Paul Maloy . 2. Reading in the dataset . The dataset was created by using the command git log --encoding=latin-1 --pretty=&quot;%at#%aN&quot; in late 2017. The latin-1 encoded text output was saved in a header-less CSV file. In this file, each row is a commit entry with the following information: . timestamp: the time of the commit as a UNIX timestamp in seconds since 1970-01-01 00:00:00 (Git log placeholder &quot;%at&quot;) | author: the name of the author that performed the commit (Git log placeholder &quot;%aN&quot;) | . The columns are separated by the number sign #. The complete dataset is in the datasets/ directory. It is a gz-compressed csv file named git_log.gz. . import pandas as pd # Reading in the log file git_log = pd.read_csv(&#39;datasets/git_log.gz&#39;, sep=&#39;#&#39;, encoding=&#39;latin-1&#39;, compression=&#39;gzip&#39;, header=None, names=[&#39;timestamp&#39;, &#39;author&#39;]) # Printing out the first 5 rows print(git_log.head()) . timestamp author 0 1502826583 Linus Torvalds 1 1501749089 Adrian Hunter 2 1501749088 Adrian Hunter 3 1501882480 Kees Cook 4 1497271395 Rob Clark . 3. Getting an overview . The dataset contains the information about every single code contribution (a &quot;commit&quot;) to the Linux kernel over the last 13 years. We&#39;ll first take a look at the number of authors and their commits to the repository. . number_of_commits = len(git_log[&#39;author&#39;]) # calculating number of authors not_null = (git_log[&#39;author&#39;].isna() == False) number_of_authors = len(pd.unique(git_log[&#39;author&#39;][not_null])) # printing out the results print(&quot;%s authors committed %s code changes.&quot; % (number_of_authors, number_of_commits)) . 17385 authors committed 699071 code changes. . 4. Finding the TOP 10 contributors . There are some very important people that changed the Linux kernel very often. To see if there are any bottlenecks, we take a look at the TOP 10 authors with the most commits. . top_10_authors = git_log.groupby(&#39;author&#39;).count().sort_values(&#39;timestamp&#39;, ascending=False).head(10) # Listing contents of &#39;top_10_authors&#39; top_10_authors . timestamp . author . Linus Torvalds 23361 | . David S. Miller 9106 | . Mark Brown 6802 | . Takashi Iwai 6209 | . Al Viro 6006 | . H Hartley Sweeten 5938 | . Ingo Molnar 5344 | . Mauro Carvalho Chehab 5204 | . Arnd Bergmann 4890 | . Greg Kroah-Hartman 4580 | . 5. Wrangling the data . For our analysis, we want to visualize the contributions over time. For this, we use the information in the timestamp column to create a time series-based column. . git_log[&#39;timestamp&#39;] = pd.to_datetime(git_log[&#39;timestamp&#39;], unit=&#39;s&#39;) # summarizing the converted timestamp column git_log[[&#39;timestamp&#39;]].describe() . timestamp . count 699071 | . unique 668448 | . top 2008-09-04 05:30:19 | . freq 99 | . first 1970-01-01 00:00:01 | . last 2037-04-25 08:08:26 | . 6. Treating wrong timestamps . As we can see from the results above, some contributors had their operating system&#39;s time incorrectly set when they committed to the repository. We&#39;ll clean up the timestamp column by dropping the rows with the incorrect timestamps. . first_commit_timestamp = git_log[git_log[&#39;author&#39;] == &#39;Linus Torvalds&#39;][&#39;timestamp&#39;].min() # determining the last sensible commit timestamp last_commit_timestamp = pd.to_datetime(&#39;today&#39;) # filtering out wrong timestamps corrected_log = git_log[git_log[&#39;timestamp&#39;] &gt;= first_commit_timestamp][git_log[&#39;timestamp&#39;] &lt;= last_commit_timestamp] # summarizing the corrected timestamp column corrected_log[&#39;timestamp&#39;].describe() . count 698569 unique 667977 top 2008-09-04 05:30:19 freq 99 first 2005-04-16 22:20:36 last 2017-10-03 12:57:00 Name: timestamp, dtype: object . 7. Grouping commits per year . To find out how the development activity has increased over time, we&#39;ll group the commits by year and count them up. . commits_per_year = corrected_log.groupby(pd.Grouper(key=&#39;timestamp&#39;, freq=&#39;AS&#39;)).count() # Listing the first rows commits_per_year.head(5) . author . timestamp . 2005-01-01 16229 | . 2006-01-01 29255 | . 2007-01-01 33759 | . 2008-01-01 48847 | . 2009-01-01 52572 | . 8. Visualizing the history of Linux . Finally, we&#39;ll make a plot out of these counts to better see how the development effort on Linux has increased over the the last few years. . %matplotlib inline # plot the data commits_per_year.plot(kind=&#39;line&#39;, title=&#39;Visual&#39;, legend=False) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fa586a039b0&gt; . 9. Conclusion . Thanks to the solid foundation and caretaking of Linux Torvalds, many other developers are now able to contribute to the Linux kernel as well. There is no decrease of development activity at sight! . year_with_most_commits = commits_per_year[commits_per_year[&#39;author&#39;] == max(commits_per_year[&#39;author&#39;])] year_with_most_commits.index[0] . Timestamp(&#39;2016-01-01 00:00:00&#39;, freq=&#39;AS-JAN&#39;) .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/03/02/Exploring-the-Evolution-of-Linux.html",
            "relUrl": "/datacamp/projects/python/2020/03/02/Exploring-the-Evolution-of-Linux.html",
            "date": " • Mar 2, 2020"
        }
        
    
  
    
        ,"post30": {
            "title": "Introduction to DataCamp Projects(R)",
            "content": "1. This is a Jupyter notebook! . A Jupyter notebook is a document that contains text cells (what you&#39;re reading right now) and code cells. What is special with a notebook is that it&#39;s interactive: You can change or add code cells, and then run a cell by first selecting it and then clicking the run cell button above ( ▶| Run ) or hitting ctrl + enter. . . The result will be displayed directly in the notebook. You could use a notebook as a simple calculator. For example, it&#39;s estimated that on average 256 children were born every minute in 2016. The code cell below calculates how many children were born on average on a day. . 256 * 60 * 24 # Children × minutes × hours . 368640 2. Put any code in code cells . But a code cell can contain much more than a simple one-liner! This is a notebook running R and you can put any R code in a code cell (but notebooks can run other languages too, like python). Below is a code cell where we define a whole new function (greet). To show the output of greet we can run it anywhere and the result is always printed out at the end of the code cell. . greet &lt;- function(first_name, last_name) { paste(&quot;My name is &quot;, last_name, &quot;, &quot;, first_name, &quot; &quot;, last_name, &quot;!&quot;, sep = &quot;&quot;) } # Replace with your first and last name. # That is, unless your name is already James Bond. greet(&quot;James&quot;, &quot;Bond&quot;) . &#39;My name is Bond, James Bond!&#39; 3. Jupyter notebooks &#9825; data . We&#39;ve seen that notebooks can display basic objects such as numbers and strings. But notebooks also support the objects used in data science, which makes them great for interactive data analysis! . For example, below we create a data frame by reading in a csv-file with the average global temperature for the years 1850 to 2016. If we look at the head of this data frame the notebook will render it as a nice-looking table. . global_temp &lt;- read.csv(&quot;datasets/global_temperature.csv&quot;) # Take a look at the first datapoints global_temp[1,] . A data.frame: 1 x 2 yeardegrees_celsius . &lt;int&gt;&lt;dbl&gt; . 1850 | 7.74 | . 4. Jupyter notebooks &#9825; plots . Tables are nice but — as the saying goes — &quot;a plot can show a thousand data points&quot;. Notebooks handle plots as well and all plots created in code cells will automatically be displayed inline. . Let&#39;s take a look at the global temperature for the last 150 years. . plot(global_temp$year, global_temp$degrees_celsius, type = &quot;l&quot;, col = &quot;forestgreen&quot;, xlab = &quot;Year&quot;, ylab = &quot;Celsius&quot;) . 5. Jupyter notebooks &#9825; Data Science . Tables and plots are the most common outputs when doing data science and, as these outputs are rendered inline, notebooks works great not only for doing a data analysis but also for showing a data analysis. A finished notebook contains both the result and the code that produced it. This is useful when you want to share your findings or if you need to update your analysis with new data. . Let&#39;s add some advanced data analysis to our notebook! For example, this (slightly complicated) code forecasts the global temperature 50 years into the future using an exponential smoothing state space model (ets). . Note: Global temperature is a complex phenomenon and exponential smoothing is likely not a good model here. This is just an example of how easy it is to do (and show) complex forecasting in a Jupyter notebook. . library(forecast) library(ggplot2) # Converting global_temp into a time series (ts) object. global_temp_ts &lt;- ts(global_temp$degrees_celsius, start = global_temp$year[1]) # Forecasting global temperature 50 years into the future # using an exponential smoothing state space model (ets). temperature_forecast &lt;- forecast( ets(global_temp_ts), h = 50) # Plotting the forecast plot(temperature_forecast, type=&#39;l&#39;) . 6. Goodbye for now! . This was just a short introduction to Jupyter notebooks, an open source technology that is increasingly used for data science and analysis. I hope you enjoyed it! :) . I_am_ready &lt;- TRUE # Ps. # Feel free to try out any other stuff in this notebook. # It&#39;s all yours! .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/r/2020/03/01/Introduction-to-DataCamp-Projects.html",
            "relUrl": "/datacamp/projects/r/2020/03/01/Introduction-to-DataCamp-Projects.html",
            "date": " • Mar 1, 2020"
        }
        
    
  
    
        ,"post31": {
            "title": "A Network Analysis of Game of Thrones",
            "content": "1. Winter is Coming. Let&#39;s load the dataset ASAP! . If you haven&#39;t heard of Game of Thrones, then you must be really good at hiding. Game of Thrones is the hugely popular television series by HBO based on the (also) hugely popular book series A Song of Ice and Fire by George R.R. Martin. In this notebook, we will analyze the co-occurrence network of the characters in the Game of Thrones books. Here, two characters are considered to co-occur if their names appear in the vicinity of 15 words from one another in the books. . . This dataset constitutes a network and is given as a text file describing the edges between characters, with some attributes attached to each edge. Let&#39;s start by loading in the data for the first book A Game of Thrones and inspect it. . import pandas as pd # Reading in datasets/book1.csv book1 = pd.read_csv(&#39;datasets/book1.csv&#39;) # Printing out the head of the dataset book1.head() . Source Target Type weight book . 0 Addam-Marbrand | Jaime-Lannister | Undirected | 3 | 1 | . 1 Addam-Marbrand | Tywin-Lannister | Undirected | 6 | 1 | . 2 Aegon-I-Targaryen | Daenerys-Targaryen | Undirected | 5 | 1 | . 3 Aegon-I-Targaryen | Eddard-Stark | Undirected | 4 | 1 | . 4 Aemon-Targaryen-(Maester-Aemon) | Alliser-Thorne | Undirected | 4 | 1 | . 2. Time for some Network of Thrones . The resulting DataFrame book1 has 5 columns: Source, Target, Type, weight, and book. Source and target are the two nodes that are linked by an edge. A network can have directed or undirected edges and in this network all the edges are undirected. The weight attribute of every edge tells us the number of interactions that the characters have had over the book, and the book column tells us the book number. . Once we have the data loaded as a pandas DataFrame, it&#39;s time to create a network. We will use networkx, a network analysis library, and create a graph object for the first book. . import networkx as nx # Creating an empty graph object G_book1 = nx.Graph() . 3. Populate the network with the DataFrame . Currently, the graph object G_book1 is empty. Let&#39;s now populate it with the edges from book1. And while we&#39;re at it, let&#39;s load in the rest of the books too! . for i, se in book1.iterrows(): G_book1.add_edge(se[&#39;Source&#39;], se[&#39;Target&#39;], weights=se[&#39;weight&#39;]) # Creating a list of networks for all the books books = [G_book1] book_fnames = [&#39;datasets/book2.csv&#39;, &#39;datasets/book3.csv&#39;, &#39;datasets/book4.csv&#39;, &#39;datasets/book5.csv&#39;] for book_fname in book_fnames: book = pd.read_csv(book_fname) G_book = nx.Graph() for _, edge in book.iterrows(): G_book.add_edge(edge[&#39;Source&#39;], edge[&#39;Target&#39;], weight=edge[&#39;weight&#39;]) books.append(G_book) . 4. The most important character in Game of Thrones . Is it Jon Snow, Tyrion, Daenerys, or someone else? Let&#39;s see! Network science offers us many different metrics to measure the importance of a node in a network. Note that there is no &quot;correct&quot; way of calculating the most important node in a network, every metric has a different meaning. . First, let&#39;s measure the importance of a node in a network by looking at the number of neighbors it has, that is, the number of nodes it is connected to. For example, an influential account on Twitter, where the follower-followee relationship forms the network, is an account which has a high number of followers. This measure of importance is called degree centrality. . Using this measure, let&#39;s extract the top ten important characters from the first book (book[0]) and the fifth book (book[4]). . deg_cen_book1 = nx.degree_centrality(books[0]) # Calculating the degree centrality of book 5 deg_cen_book5 = nx.degree_centrality(books[4]) # Sorting the dictionaries according to their degree centrality and storing the top 10 sorted_deg_cen_book1 = sorted(deg_cen_book1.items(), key = lambda x:x[1], reverse=True)[:10] # Sorting the dictionaries according to their degree centrality and storing the top 10 sorted_deg_cen_book5 = sorted(deg_cen_book5.items(), key = lambda x:x[1], reverse=True)[:10] # Printing out the top 10 of book1 and book5 print(sorted_deg_cen_book1) print(sorted_deg_cen_book5) . [(&#39;Eddard-Stark&#39;, 0.3548387096774194), (&#39;Robert-Baratheon&#39;, 0.2688172043010753), (&#39;Tyrion-Lannister&#39;, 0.24731182795698928), (&#39;Catelyn-Stark&#39;, 0.23118279569892475), (&#39;Jon-Snow&#39;, 0.19892473118279572), (&#39;Robb-Stark&#39;, 0.18817204301075272), (&#39;Sansa-Stark&#39;, 0.18817204301075272), (&#39;Bran-Stark&#39;, 0.17204301075268819), (&#39;Cersei-Lannister&#39;, 0.16129032258064518), (&#39;Joffrey-Baratheon&#39;, 0.16129032258064518)] [(&#39;Jon-Snow&#39;, 0.1962025316455696), (&#39;Daenerys-Targaryen&#39;, 0.18354430379746836), (&#39;Stannis-Baratheon&#39;, 0.14873417721518986), (&#39;Tyrion-Lannister&#39;, 0.10443037974683544), (&#39;Theon-Greyjoy&#39;, 0.10443037974683544), (&#39;Cersei-Lannister&#39;, 0.08860759493670886), (&#39;Barristan-Selmy&#39;, 0.07911392405063292), (&#39;Hizdahr-zo-Loraq&#39;, 0.06962025316455696), (&#39;Asha-Greyjoy&#39;, 0.056962025316455694), (&#39;Melisandre&#39;, 0.05379746835443038)] . 5. The evolution of character importance . According to degree centrality, the most important character in the first book is Eddard Stark but he is not even in the top 10 of the fifth book. The importance of characters changes over the course of five books because, you know, stuff happens... ;) . Let&#39;s look at the evolution of degree centrality of a couple of characters like Eddard Stark, Jon Snow, and Tyrion, which showed up in the top 10 of degree centrality in the first book. . %matplotlib inline # Creating a list of degree centrality of all the books evol = [nx.degree_centrality(book) for book in books] # Creating a DataFrame from the list of degree centralities in all the books degree_evol_df = pd.DataFrame.from_records(evol) # Plotting the degree centrality evolution of Eddard-Stark, Tyrion-Lannister and Jon-Snow degree_evol_df[[&#39;Eddard-Stark&#39;, &#39;Tyrion-Lannister&#39;, &#39;Jon-Snow&#39;]].plot() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f3e61994c50&gt; . 6. What&#39;s up with Stannis Baratheon? . We can see that the importance of Eddard Stark dies off as the book series progresses. With Jon Snow, there is a drop in the fourth book but a sudden rise in the fifth book. . Now let&#39;s look at various other measures like betweenness centrality and PageRank to find important characters in our Game of Thrones character co-occurrence network and see if we can uncover some more interesting facts about this network. Let&#39;s plot the evolution of betweenness centrality of this network over the five books. We will take the evolution of the top four characters of every book and plot it. . evol = [nx.betweenness_centrality(book, weight=&#39;weight&#39;) for book in books] # Making a DataFrame from the list betweenness_evol_df = pd.DataFrame.from_records(evol).fillna(0) # Finding the top 4 characters in every book set_of_char = set() for i in range(5): set_of_char |= set(list(betweenness_evol_df.T[i].sort_values(ascending=False)[0:4].index)) list_of_char = list(set_of_char) # Plotting the evolution of the top characters betweenness_evol_df[list_of_char].plot() . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f3e95616278&gt; . 7. What does Google PageRank tell us about GoT? . We see a peculiar rise in the importance of Stannis Baratheon over the books. In the fifth book, he is significantly more important than other characters in the network, even though he is the third most important character according to degree centrality. . PageRank was the initial way Google ranked web pages. It evaluates the inlinks and outlinks of webpages in the world wide web, which is, essentially, a directed network. Let&#39;s look at the importance of characters in the Game of Thrones network according to PageRank. . evol = [nx.pagerank(book, weight=&#39;weight&#39;) for book in books] # Making a DataFrame from the list pagerank_evol_df = pd.DataFrame.from_records(evol).fillna(0) # Finding the top 4 characters in every book set_of_char = set() for i in range(5): set_of_char |= set(list(pagerank_evol_df.T[i].sort_values(ascending=False)[0:4].index)) list_of_char = list(set_of_char) # Plotting the top characters pagerank_evol_df[list_of_char].plot(figsize=(13, 7)) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f3e64796b70&gt; . 8. Correlation between different measures . Stannis, Jon Snow, and Daenerys are the most important characters in the fifth book according to PageRank. Eddard Stark follows a similar curve but for degree centrality and betweenness centrality: He is important in the first book but dies into oblivion over the book series. . We have seen three different measures to calculate the importance of a node in a network, and all of them tells us something about the characters and their importance in the co-occurrence network. We see some names pop up in all three measures so maybe there is a strong correlation between them? . Let&#39;s look at the correlation between PageRank, betweenness centrality and degree centrality for the fifth book using Pearson correlation. . # of all the characters in the fifth book. measures = [nx.pagerank(books[4]), nx.betweenness_centrality(books[4], weight=&#39;weight&#39;), nx.degree_centrality(books[4])] # Creating the correlation DataFrame cor = pd.DataFrame.from_records(measures) # Calculating the correlation cor.corr() . Aegon-I-Targaryen Aegon-Targaryen-(son-of-Rhaegar) Aemon-Targaryen-(Maester-Aemon) Aenys-Frey Aeron-Greyjoy Aerys-II-Targaryen Aggo Alliser-Thorne Alys-Karstark Alysane-Mormont ... Wun-Weg-Wun-Dar-Wun Wylis-Manderly Wyman-Manderly Xaro-Xhoan-Daxos Yandry Yellow-Dick Yezzan-zo-Qaggaz Ygritte Ysilla Yurkhaz-zo-Yunzak . Aegon-I-Targaryen 1.000000 | 0.278893 | 0.882815 | 0.999467 | 0.320632 | 0.999048 | 0.971752 | 0.997956 | 0.999952 | 0.998448 | ... | 0.999555 | 0.999994 | -0.008652 | 0.999886 | 0.999258 | 0.995381 | 0.999977 | 0.999249 | 0.938126 | 1.000000 | . Aegon-Targaryen-(son-of-Rhaegar) 0.278893 | 1.000000 | 0.697294 | 0.310094 | 0.999043 | 0.320525 | 0.497653 | 0.216958 | 0.269464 | 0.224971 | ... | 0.307418 | 0.275465 | 0.957873 | 0.264389 | 0.315685 | 0.369802 | 0.285400 | 0.241484 | 0.594191 | 0.278893 | . Aemon-Targaryen-(Maester-Aemon) 0.882815 | 0.697294 | 1.000000 | 0.897679 | 0.727980 | 0.902468 | 0.968733 | 0.850996 | 0.878167 | 0.855281 | ... | 0.896435 | 0.881133 | 0.462065 | 0.875636 | 0.900257 | 0.923834 | 0.885981 | 0.863957 | 0.990853 | 0.882815 | . Aenys-Frey 0.999467 | 0.310094 | 0.897679 | 1.000000 | 0.351383 | 0.999940 | 0.978939 | 0.995338 | 0.999099 | 0.996097 | ... | 0.999996 | 0.999344 | 0.023997 | 0.998862 | 0.999983 | 0.997984 | 0.999665 | 0.997452 | 0.948931 | 0.999467 | . Aeron-Greyjoy 0.320632 | 0.999043 | 0.727980 | 0.351383 | 1.000000 | 0.361652 | 0.535117 | 0.259450 | 0.311330 | 0.267376 | ... | 0.348747 | 0.317250 | 0.944394 | 0.306321 | 0.356887 | 0.410089 | 0.327049 | 0.283700 | 0.628804 | 0.320632 | . Aerys-II-Targaryen 0.999048 | 0.320525 | 0.902468 | 0.999940 | 0.361652 | 1.000000 | 0.981124 | 0.994218 | 0.998572 | 0.995067 | ... | 0.999905 | 0.998886 | 0.034984 | 0.998277 | 0.999987 | 0.998622 | 0.999321 | 0.996608 | 0.952341 | 0.999048 | . Aggo 0.971752 | 0.497653 | 0.968733 | 0.978939 | 0.535117 | 0.981124 | 1.000000 | 0.954686 | 0.969392 | 0.957099 | ... | 0.978361 | 0.970904 | 0.227586 | 0.968085 | 0.980124 | 0.989921 | 0.973331 | 0.961881 | 0.993353 | 0.971752 | . Alliser-Thorne 0.997956 | 0.216958 | 0.850996 | 0.995338 | 0.259450 | 0.994218 | 0.954686 | 1.000000 | 0.998535 | 0.999966 | ... | 0.995606 | 0.998178 | -0.072532 | 0.998806 | 0.994753 | 0.987212 | 0.997500 | 0.999683 | 0.914080 | 0.997956 | . Alys-Karstark 0.999952 | 0.269464 | 0.878167 | 0.999099 | 0.311330 | 0.998572 | 0.969392 | 0.998535 | 1.000000 | 0.998946 | ... | 0.999214 | 0.999981 | -0.018455 | 0.999986 | 0.998832 | 0.994392 | 0.999862 | 0.999581 | 0.934686 | 0.999952 | . Alysane-Mormont 0.998448 | 0.224971 | 0.855281 | 0.996097 | 0.267376 | 0.995067 | 0.957099 | 0.999966 | 0.998946 | 1.000000 | ... | 0.996342 | 0.998640 | -0.064336 | 0.999174 | 0.995560 | 0.988488 | 0.998047 | 0.999856 | 0.917381 | 0.998448 | . Archibald-Yronwood 0.999945 | 0.268800 | 0.877837 | 0.999069 | 0.310674 | 0.998535 | 0.969222 | 0.998572 | 1.000000 | 0.998977 | ... | 0.999187 | 0.999976 | -0.019145 | 0.999990 | 0.998798 | 0.994318 | 0.999851 | 0.999601 | 0.934440 | 0.999945 | . Areo-Hotah 0.999389 | 0.312281 | 0.898690 | 0.999997 | 0.353536 | 0.999962 | 0.979406 | 0.995114 | 0.998999 | 0.995891 | ... | 0.999987 | 0.999258 | 0.026297 | 0.998749 | 0.999994 | 0.998128 | 0.999603 | 0.997286 | 0.949654 | 0.999389 | . Arianne-Martell 0.997788 | 0.342119 | 0.912090 | 0.999426 | 0.382894 | 0.999738 | 0.985292 | 0.991500 | 0.997088 | 0.992536 | ... | 0.999327 | 0.997544 | 0.057846 | 0.996672 | 0.999608 | 0.999561 | 0.998216 | 0.994464 | 0.959073 | 0.997788 | . Arnolf-Karstark 0.152395 | 0.991607 | 0.598771 | 0.184578 | 0.985003 | 0.195370 | 0.381337 | 0.088930 | 0.142698 | 0.097110 | ... | 0.181812 | 0.148868 | 0.986964 | 0.137484 | 0.190360 | 0.246577 | 0.159096 | 0.113997 | 0.485215 | 0.152395 | . Arron 0.999597 | 0.306032 | 0.895789 | 0.999991 | 0.347382 | 0.999884 | 0.978058 | 0.995741 | 0.999271 | 0.996465 | ... | 0.999999 | 0.999490 | 0.019728 | 0.999056 | 0.999948 | 0.997704 | 0.999767 | 0.997748 | 0.947575 | 0.999597 | . Arthor-Karstark 0.997776 | 0.214260 | 0.849541 | 0.995068 | 0.256781 | 0.993918 | 0.953860 | 0.999996 | 0.998382 | 0.999940 | ... | 0.995343 | 0.998007 | -0.075287 | 0.998667 | 0.994467 | 0.986767 | 0.997301 | 0.999609 | 0.912956 | 0.997776 | . Arya-Stark 0.481352 | 0.975994 | 0.836668 | 0.509710 | 0.984587 | 0.519136 | 0.674618 | 0.424358 | 0.472736 | 0.431783 | ... | 0.507288 | 0.478222 | 0.872330 | 0.468088 | 0.514766 | 0.563282 | 0.487287 | 0.447038 | 0.755105 | 0.481352 | . Arys-Oakheart 0.999861 | 0.294844 | 0.890514 | 0.999872 | 0.336359 | 0.999636 | 0.975547 | 0.996754 | 0.999650 | 0.997382 | ... | 0.999913 | 0.999796 | 0.007999 | 0.999497 | 0.999761 | 0.996841 | 0.999951 | 0.998466 | 0.943762 | 0.999861 | . Asha-Greyjoy -0.446205 | 0.734978 | 0.026451 | -0.416752 | 0.704614 | -0.406735 | -0.222395 | -0.502479 | -0.454958 | -0.495359 | ... | -0.419308 | -0.449395 | 0.898758 | -0.459641 | -0.411394 | -0.358224 | -0.440125 | -0.480536 | -0.108687 | -0.446205 | . Ashara-Dayne 0.998672 | 0.229056 | 0.857448 | 0.996459 | 0.271416 | 0.995474 | 0.958306 | 0.999923 | 0.999130 | 0.999991 | ... | 0.996691 | 0.998850 | -0.060148 | 0.999335 | 0.995946 | 0.989114 | 0.998300 | 0.999918 | 0.919043 | 0.998672 | . Axell-Florent -0.506689 | 0.686610 | -0.042352 | -0.478274 | 0.654152 | -0.468592 | -0.288911 | -0.560743 | -0.515117 | -0.553922 | ... | -0.480743 | -0.509761 | 0.866481 | -0.519624 | -0.473097 | -0.421577 | -0.500829 | -0.539704 | -0.176787 | -0.506689 | . Azor-Ahai 1.000000 | 0.278072 | 0.882413 | 0.999439 | 0.319822 | 0.999010 | 0.971550 | 0.998011 | 0.999960 | 0.998495 | ... | 0.999529 | 0.999996 | -0.009507 | 0.999899 | 0.999224 | 0.995298 | 0.999971 | 0.999282 | 0.937830 | 1.000000 | . Balon-Greyjoy 0.381983 | 0.994033 | 0.771322 | 0.411949 | 0.997853 | 0.421940 | 0.589299 | 0.322148 | 0.372904 | 0.329914 | ... | 0.409384 | 0.378683 | 0.920830 | 0.368012 | 0.417305 | 0.468945 | 0.388243 | 0.345897 | 0.678383 | 0.381983 | . Balon-Swann 0.926722 | 0.619294 | 0.994621 | 0.938495 | 0.653045 | 0.942233 | 0.989222 | 0.900818 | 0.922994 | 0.904355 | ... | 0.937520 | 0.925376 | 0.367715 | 0.920954 | 0.940511 | 0.958516 | 0.929250 | 0.911472 | 0.999501 | 0.926722 | . Barbrey-Dustin -0.028012 | 0.952133 | 0.444807 | 0.004635 | 0.937851 | 0.015626 | 0.208689 | -0.091830 | -0.037811 | -0.083646 | ... | 0.001822 | -0.031579 | 0.999813 | -0.043074 | 0.010521 | 0.068087 | -0.021231 | -0.066712 | 0.319879 | -0.028012 | . Barristan-Selmy 0.253308 | 0.999648 | 0.678025 | 0.284754 | 0.997530 | 0.295273 | 0.474458 | 0.190974 | 0.243811 | 0.199032 | ... | 0.282055 | 0.249855 | 0.965158 | 0.238700 | 0.290391 | 0.345014 | 0.259864 | 0.215645 | 0.572635 | 0.253308 | . Barsena 1.000000 | 0.278893 | 0.882815 | 0.999467 | 0.320632 | 0.999048 | 0.971752 | 0.997956 | 0.999952 | 0.998448 | ... | 0.999555 | 0.999994 | -0.008652 | 0.999886 | 0.999258 | 0.995381 | 0.999977 | 0.999249 | 0.938126 | 1.000000 | . Bartimus 0.999126 | 0.238517 | 0.862414 | 0.997230 | 0.280768 | 0.996352 | 0.961041 | 0.999755 | 0.999488 | 0.999903 | ... | 0.997435 | 0.999269 | -0.050433 | 0.999643 | 0.996774 | 0.990499 | 0.998820 | 0.999995 | 0.922835 | 0.999126 | . Belaquo 0.993139 | 0.389280 | 0.931688 | 0.996427 | 0.429199 | 0.997295 | 0.992683 | 0.983637 | 0.991945 | 0.985084 | ... | 0.996186 | 0.992715 | 0.108344 | 0.991264 | 0.996907 | 0.999778 | 0.993909 | 0.987864 | 0.972185 | 0.993139 | . Belwas 0.994771 | 0.375514 | 0.926172 | 0.997575 | 0.415695 | 0.998280 | 0.990774 | 0.986212 | 0.993722 | 0.987538 | ... | 0.997375 | 0.994400 | 0.093522 | 0.993119 | 0.997967 | 0.999981 | 0.995441 | 0.990068 | 0.968588 | 0.994771 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . Tywin-Lannister -0.454044 | 0.728998 | 0.017674 | -0.424716 | 0.698358 | -0.414739 | -0.230945 | -0.510050 | -0.462758 | -0.502966 | ... | -0.427261 | -0.457220 | 0.894874 | -0.467420 | -0.419380 | -0.366406 | -0.447990 | -0.488217 | -0.117410 | -0.454044 | . Ulmer 0.999995 | 0.281800 | 0.884234 | 0.999561 | 0.323499 | 0.999175 | 0.972463 | 0.997758 | 0.999918 | 0.998274 | ... | 0.999641 | 0.999978 | -0.005623 | 0.999836 | 0.999370 | 0.995667 | 0.999993 | 0.999128 | 0.939171 | 0.999995 | . Unella 0.992156 | 0.156657 | 0.817171 | 0.987546 | 0.199709 | 0.985757 | 0.934628 | 0.998116 | 0.993334 | 0.997578 | ... | 0.987985 | 0.992595 | -0.133587 | 0.993927 | 0.986603 | 0.975571 | 0.991285 | 0.996253 | 0.887478 | 0.992156 | . Val 0.392030 | 0.992785 | 0.778211 | 0.421853 | 0.997080 | 0.431793 | 0.598067 | 0.332444 | 0.382992 | 0.340181 | ... | 0.419301 | 0.388745 | 0.916526 | 0.378121 | 0.427183 | 0.478541 | 0.398261 | 0.356100 | 0.686348 | 0.392030 | . Varamyr -0.149098 | 0.908006 | 0.332844 | -0.116738 | 0.888811 | -0.105815 | 0.088478 | -0.211980 | -0.158786 | -0.203944 | ... | -0.119532 | -0.152626 | 0.990075 | -0.163983 | -0.110891 | -0.053476 | -0.142388 | -0.187290 | 0.202550 | -0.149098 | . Varys 0.377108 | 0.994594 | 0.767958 | 0.407143 | 0.998184 | 0.417157 | 0.585034 | 0.317155 | 0.368010 | 0.324936 | ... | 0.404571 | 0.373801 | 0.922872 | 0.363108 | 0.412511 | 0.464285 | 0.383382 | 0.340949 | 0.674502 | 0.377108 | . Victarion-Greyjoy 0.322654 | 0.998947 | 0.729443 | 0.353382 | 0.999998 | 0.363643 | 0.536921 | 0.261513 | 0.313359 | 0.269433 | ... | 0.350748 | 0.319275 | 0.943690 | 0.308353 | 0.358882 | 0.412037 | 0.329067 | 0.285748 | 0.630464 | 0.322654 | . Viserys-Targaryen 0.565611 | 0.949696 | 0.886696 | 0.592231 | 0.962486 | 0.601052 | 0.744259 | 0.511758 | 0.557498 | 0.518799 | ... | 0.589962 | 0.562665 | 0.819748 | 0.553119 | 0.596964 | 0.642173 | 0.571192 | 0.533242 | 0.816194 | 0.565611 | . Waif 0.999395 | 0.245321 | 0.865943 | 0.997727 | 0.287491 | 0.996926 | 0.962956 | 0.999575 | 0.999688 | 0.999781 | ... | 0.997912 | 0.999513 | -0.043428 | 0.999806 | 0.997313 | 0.991439 | 0.999136 | 0.999992 | 0.925513 | 0.999395 | . Walda-Frey-(daughter-of-Merrett) 0.981860 | 0.455916 | 0.955863 | 0.987527 | 0.494411 | 0.989198 | 0.998873 | 0.967738 | 0.979954 | 0.969775 | ... | 0.987080 | 0.981178 | 0.181104 | 0.978891 | 0.988436 | 0.995528 | 0.983124 | 0.973779 | 0.986768 | 0.981860 | . Walder-Frey-(son-of-Jammos) 0.997255 | 0.207021 | 0.845612 | 0.994306 | 0.249617 | 0.993075 | 0.951610 | 0.999948 | 0.997933 | 0.999831 | ... | 0.994602 | 0.997513 | -0.082669 | 0.998258 | 0.993662 | 0.985539 | 0.996730 | 0.999375 | 0.909910 | 0.997255 | . Walder-Frey-(son-of-Merrett) 0.999998 | 0.280636 | 0.883666 | 0.999525 | 0.322351 | 0.999125 | 0.972179 | 0.997839 | 0.999932 | 0.998345 | ... | 0.999607 | 0.999986 | -0.006836 | 0.999857 | 0.999326 | 0.995553 | 0.999988 | 0.999177 | 0.938753 | 0.999998 | . Weeper 0.644369 | 0.914082 | 0.928061 | 0.668990 | 0.930946 | 0.677119 | 0.806642 | 0.594187 | 0.636840 | 0.600775 | ... | 0.666896 | 0.641636 | 0.759111 | 0.632771 | 0.673353 | 0.714810 | 0.649541 | 0.614263 | 0.869316 | 0.644369 | . Wex-Pyke 1.000000 | 0.279155 | 0.882943 | 0.999476 | 0.320891 | 0.999060 | 0.971817 | 0.997939 | 0.999949 | 0.998432 | ... | 0.999563 | 0.999993 | -0.008379 | 0.999882 | 0.999268 | 0.995407 | 0.999979 | 0.999239 | 0.938221 | 1.000000 | . Wick-Whittlestick 0.997391 | 0.347496 | 0.914423 | 0.999216 | 0.388179 | 0.999591 | 0.986255 | 0.990739 | 0.996635 | 0.991821 | ... | 0.999100 | 0.997127 | 0.063563 | 0.996189 | 0.999432 | 0.999714 | 0.997857 | 0.993845 | 0.960679 | 0.997391 | . Widower 0.999793 | 0.298377 | 0.892191 | 0.999924 | 0.339840 | 0.999729 | 0.976354 | 0.996449 | 0.999545 | 0.997107 | ... | 0.999955 | 0.999714 | 0.011698 | 0.999373 | 0.999835 | 0.997128 | 0.999908 | 0.998254 | 0.944978 | 0.999793 | . Willam-Dustin -0.409763 | 0.761718 | 0.066731 | -0.379766 | 0.732649 | -0.369575 | -0.182908 | -0.467215 | -0.418687 | -0.459935 | ... | -0.382367 | -0.413015 | 0.915703 | -0.423464 | -0.374314 | -0.320293 | -0.403566 | -0.444790 | -0.068522 | -0.409763 | . William-Foxglove 1.000000 | 0.278072 | 0.882413 | 0.999439 | 0.319822 | 0.999010 | 0.971550 | 0.998011 | 0.999960 | 0.998495 | ... | 0.999529 | 0.999996 | -0.009507 | 0.999899 | 0.999224 | 0.995298 | 0.999971 | 0.999282 | 0.937830 | 1.000000 | . Willow-Witch-eye 0.999742 | 0.256999 | 0.871913 | 0.998467 | 0.299025 | 0.997798 | 0.966139 | 0.999151 | 0.999917 | 0.999455 | ... | 0.998619 | 0.999817 | -0.031372 | 0.999971 | 0.998124 | 0.992942 | 0.999565 | 0.999872 | 0.930015 | 0.999742 | . Wulfe 0.999190 | 0.240022 | 0.863198 | 0.997344 | 0.282255 | 0.996483 | 0.961468 | 0.999719 | 0.999536 | 0.999880 | ... | 0.997545 | 0.999327 | -0.048885 | 0.999683 | 0.996898 | 0.990711 | 0.998894 | 0.999999 | 0.923431 | 0.999190 | . Wun-Weg-Wun-Dar-Wun 0.999555 | 0.307418 | 0.896435 | 0.999996 | 0.348747 | 0.999905 | 0.978361 | 0.995606 | 0.999214 | 0.996342 | ... | 1.000000 | 0.999442 | 0.021184 | 0.998992 | 0.999962 | 0.997802 | 0.999734 | 0.997649 | 0.948039 | 0.999555 | . Wylis-Manderly 0.999994 | 0.275465 | 0.881133 | 0.999344 | 0.317250 | 0.998886 | 0.970904 | 0.998178 | 0.999981 | 0.998640 | ... | 0.999442 | 1.000000 | -0.012220 | 0.999934 | 0.999114 | 0.995032 | 0.999946 | 0.999381 | 0.936884 | 0.999994 | . Wyman-Manderly -0.008652 | 0.957873 | 0.462065 | 0.023997 | 0.944394 | 0.034984 | 0.227586 | -0.072532 | -0.018455 | -0.064336 | ... | 0.021184 | -0.012220 | 1.000000 | -0.023721 | 0.029881 | 0.087392 | -0.001869 | -0.047380 | 0.338165 | -0.008652 | . Xaro-Xhoan-Daxos 0.999886 | 0.264389 | 0.875636 | 0.998862 | 0.306321 | 0.998277 | 0.968085 | 0.998806 | 0.999986 | 0.999174 | ... | 0.998992 | 0.999934 | -0.023721 | 1.000000 | 0.998563 | 0.993821 | 0.999761 | 0.999720 | 0.932801 | 0.999886 | . Yandry 0.999258 | 0.315685 | 0.900257 | 0.999983 | 0.356887 | 0.999987 | 0.980124 | 0.994753 | 0.998832 | 0.995560 | ... | 0.999962 | 0.999114 | 0.029881 | 0.998563 | 1.000000 | 0.998341 | 0.999496 | 0.997015 | 0.950771 | 0.999258 | . Yellow-Dick 0.995381 | 0.369802 | 0.923834 | 0.997984 | 0.410089 | 0.998622 | 0.989921 | 0.987212 | 0.994392 | 0.988488 | ... | 0.997802 | 0.995032 | 0.087392 | 0.993821 | 0.998341 | 1.000000 | 0.996009 | 0.990915 | 0.967039 | 0.995381 | . Yezzan-zo-Qaggaz 0.999977 | 0.285400 | 0.885981 | 0.999665 | 0.327049 | 0.999321 | 0.973331 | 0.997500 | 0.999862 | 0.998047 | ... | 0.999734 | 0.999946 | -0.001869 | 0.999761 | 0.999496 | 0.996009 | 1.000000 | 0.998964 | 0.940453 | 0.999977 | . Ygritte 0.999249 | 0.241484 | 0.863957 | 0.997452 | 0.283700 | 0.996608 | 0.961881 | 0.999683 | 0.999581 | 0.999856 | ... | 0.997649 | 0.999381 | -0.047380 | 0.999720 | 0.997015 | 0.990915 | 0.998964 | 1.000000 | 0.924008 | 0.999249 | . Ysilla 0.938126 | 0.594191 | 0.990853 | 0.948931 | 0.628804 | 0.952341 | 0.993353 | 0.914080 | 0.934686 | 0.917381 | ... | 0.948039 | 0.936884 | 0.338165 | 0.932801 | 0.950771 | 0.967039 | 0.940453 | 0.924008 | 1.000000 | 0.938126 | . Yurkhaz-zo-Yunzak 1.000000 | 0.278893 | 0.882815 | 0.999467 | 0.320632 | 0.999048 | 0.971752 | 0.997956 | 0.999952 | 0.998448 | ... | 0.999555 | 0.999994 | -0.008652 | 0.999886 | 0.999258 | 0.995381 | 0.999977 | 0.999249 | 0.938126 | 1.000000 | . 317 rows × 317 columns . 9. Conclusion . We see a high correlation between these three measures for our character co-occurrence network. . So we&#39;ve been looking at different ways to find the important characters in the Game of Thrones co-occurrence network. According to degree centrality, Eddard Stark is the most important character initially in the books. But who is/are the most important character(s) in the fifth book according to these three measures? . # according to degree centrality, betweenness centrality and pagerank. p_rank, b_cent, d_cent = cor.idxmax(axis=1) # Printing out the top character accoding to the three measures print(p_rank) print(b_rank) print(d_rank) . Jon-Snow . NameError Traceback (most recent call last) &lt;ipython-input-255-a08ddd23025c&gt; in &lt;module&gt;() 5 # Printing out the top character accoding to the three measures 6 print(p_rank) -&gt; 7 print(b_rank) 8 print(d_rank) NameError: name &#39;b_rank&#39; is not defined .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/02/25/A-Network-Analysis-of-Game-of-Thrones.html",
            "relUrl": "/datacamp/projects/python/2020/02/25/A-Network-Analysis-of-Game-of-Thrones.html",
            "date": " • Feb 25, 2020"
        }
        
    
  
    
        ,"post32": {
            "title": "TV Halftime Shows and the Big Game",
            "content": "1. TV, halftime shows, and the Big Game . Whether or not you like football, the Super Bowl is a spectacle. There&#39;s a little something for everyone at your Super Bowl party. Drama in the form of blowouts, comebacks, and controversy for the sports fan. There are the ridiculously expensive ads, some hilarious, others gut-wrenching, thought-provoking, and weird. The half-time shows with the biggest musicians in the world, sometimes riding giant mechanical tigers or leaping from the roof of the stadium. It&#39;s a show, baby. And in this notebook, we&#39;re going to find out how some of the elements of this show interact with each other. After exploring and cleaning our data a little, we&#39;re going to answer questions like: . What are the most extreme game outcomes? | How does the game affect television viewership? | How have viewership, TV ratings, and ad cost evolved over time? | Who are the most prolific musicians in terms of halftime show performances? | . Left Shark Steals The Show. Katy Perry performing at halftime of Super Bowl XLIX. Photo by Huntley Paton. Attribution-ShareAlike 2.0 Generic (CC BY-SA 2.0). . The dataset we&#39;ll use was scraped and polished from Wikipedia. It is made up of three CSV files, one with game data, one with TV data, and one with halftime musician data for all 52 Super Bowls through 2018. Let&#39;s take a look, using display() instead of print() since its output is much prettier in Jupyter Notebooks. . import pandas as pd # Load the CSV data into DataFrames super_bowls = pd.read_csv(&#39;datasets/super_bowls.csv&#39;) tv = pd.read_csv(&#39;datasets/tv.csv&#39;) halftime_musicians = pd.read_csv(&#39;datasets/halftime_musicians.csv&#39;) # Display the first five rows of each DataFrame display(super_bowls.head()) display(tv.head()) display(halftime_musicians.head()) . date super_bowl venue city state attendance team_winner winning_pts qb_winner_1 qb_winner_2 coach_winner team_loser losing_pts qb_loser_1 qb_loser_2 coach_loser combined_pts difference_pts . 0 2018-02-04 | 52 | U.S. Bank Stadium | Minneapolis | Minnesota | 67612 | Philadelphia Eagles | 41 | Nick Foles | NaN | Doug Pederson | New England Patriots | 33 | Tom Brady | NaN | Bill Belichick | 74 | 8 | . 1 2017-02-05 | 51 | NRG Stadium | Houston | Texas | 70807 | New England Patriots | 34 | Tom Brady | NaN | Bill Belichick | Atlanta Falcons | 28 | Matt Ryan | NaN | Dan Quinn | 62 | 6 | . 2 2016-02-07 | 50 | Levi&#39;s Stadium | Santa Clara | California | 71088 | Denver Broncos | 24 | Peyton Manning | NaN | Gary Kubiak | Carolina Panthers | 10 | Cam Newton | NaN | Ron Rivera | 34 | 14 | . 3 2015-02-01 | 49 | University of Phoenix Stadium | Glendale | Arizona | 70288 | New England Patriots | 28 | Tom Brady | NaN | Bill Belichick | Seattle Seahawks | 24 | Russell Wilson | NaN | Pete Carroll | 52 | 4 | . 4 2014-02-02 | 48 | MetLife Stadium | East Rutherford | New Jersey | 82529 | Seattle Seahawks | 43 | Russell Wilson | NaN | Pete Carroll | Denver Broncos | 8 | Peyton Manning | NaN | John Fox | 51 | 35 | . super_bowl network avg_us_viewers total_us_viewers rating_household share_household rating_18_49 share_18_49 ad_cost . 0 52 | NBC | 103390000 | NaN | 43.1 | 68 | 33.4 | 78.0 | 5000000 | . 1 51 | Fox | 111319000 | 172000000.0 | 45.3 | 73 | 37.1 | 79.0 | 5000000 | . 2 50 | CBS | 111864000 | 167000000.0 | 46.6 | 72 | 37.7 | 79.0 | 5000000 | . 3 49 | NBC | 114442000 | 168000000.0 | 47.5 | 71 | 39.1 | 79.0 | 4500000 | . 4 48 | Fox | 112191000 | 167000000.0 | 46.7 | 69 | 39.3 | 77.0 | 4000000 | . super_bowl musician num_songs . 0 52 | Justin Timberlake | 11.0 | . 1 52 | University of Minnesota Marching Band | 1.0 | . 2 51 | Lady Gaga | 7.0 | . 3 50 | Coldplay | 6.0 | . 4 50 | Beyoncé | 3.0 | . 2. Taking note of dataset issues . For the Super Bowl game data, we can see the dataset appears whole except for missing values in the backup quarterback columns (qb_winner_2 and qb_loser_2), which make sense given most starting QBs in the Super Bowl (qb_winner_1 and qb_loser_1) play the entire game. . From the visual inspection of TV and halftime musicians data, there is only one missing value displayed, but I&#39;ve got a hunch there are more. The Super Bowl goes all the way back to 1967, and the more granular columns (e.g. the number of songs for halftime musicians) probably weren&#39;t tracked reliably over time. Wikipedia is great but not perfect. . An inspection of the .info() output for tv and halftime_musicians shows us that there are multiple columns with null values. . tv.info() print(&#39; n&#39;) # Summary of the halftime musician data to inspect halftime_musicians.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 53 entries, 0 to 52 Data columns (total 9 columns): super_bowl 53 non-null int64 network 53 non-null object avg_us_viewers 53 non-null int64 total_us_viewers 15 non-null float64 rating_household 53 non-null float64 share_household 53 non-null int64 rating_18_49 15 non-null float64 share_18_49 6 non-null float64 ad_cost 53 non-null int64 dtypes: float64(4), int64(4), object(1) memory usage: 3.8+ KB &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 134 entries, 0 to 133 Data columns (total 3 columns): super_bowl 134 non-null int64 musician 134 non-null object num_songs 88 non-null float64 dtypes: float64(1), int64(1), object(1) memory usage: 3.2+ KB . 3. Combined points distribution . For the TV data, the following columns have missing values and a lot of them: . total_us_viewers (amount of U.S. viewers who watched at least some part of the broadcast) | rating_18_49 (average % of U.S. adults 18-49 who live in a household with a TV that were watching for the entire broadcast) | share_18_49 (average % of U.S. adults 18-49 who live in a household with a TV in use that were watching for the entire broadcast) | . For the halftime musician data, there are missing numbers of songs performed (num_songs) for about a third of the performances. . There are a lot of potential reasons for these missing values. Was the data ever tracked? Was it lost in history? Is the research effort to make this data whole worth it? Maybe. Watching every Super Bowl halftime show to get song counts would be pretty fun. But we don&#39;t have the time to do that kind of stuff now! Let&#39;s take note of where the dataset isn&#39;t perfect and start uncovering some insights. . Let&#39;s start by looking at combined points for each Super Bowl by visualizing the distribution. Let&#39;s also pinpoint the Super Bowls with the highest and lowest scores. . from matplotlib import pyplot as plt %matplotlib inline plt.style.use(&#39;seaborn&#39;) # Plot a histogram of combined points # ... YOUR CODE FOR TASK 3 ... plt.xlabel(&#39;Combined Points&#39;) plt.ylabel(&#39;Number of Super Bowls&#39;) plt.hist(super_bowls[&#39;combined_pts&#39;]) plt.show() # Display the Super Bowls with the highest and lowest combined scores display(super_bowls[super_bowls[&#39;combined_pts&#39;] &gt; 70]) display(super_bowls[super_bowls[&#39;combined_pts&#39;] &lt; 25]) . date super_bowl venue city state attendance team_winner winning_pts qb_winner_1 qb_winner_2 coach_winner team_loser losing_pts qb_loser_1 qb_loser_2 coach_loser combined_pts difference_pts . 0 2018-02-04 | 52 | U.S. Bank Stadium | Minneapolis | Minnesota | 67612 | Philadelphia Eagles | 41 | Nick Foles | NaN | Doug Pederson | New England Patriots | 33 | Tom Brady | NaN | Bill Belichick | 74 | 8 | . 23 1995-01-29 | 29 | Joe Robbie Stadium | Miami Gardens | Florida | 74107 | San Francisco 49ers | 49 | Steve Young | NaN | George Seifert | San Diego Chargers | 26 | Stan Humphreys | NaN | Bobby Ross | 75 | 23 | . date super_bowl venue city state attendance team_winner winning_pts qb_winner_1 qb_winner_2 coach_winner team_loser losing_pts qb_loser_1 qb_loser_2 coach_loser combined_pts difference_pts . 43 1975-01-12 | 9 | Tulane Stadium | New Orleans | Louisiana | 80997 | Pittsburgh Steelers | 16 | Terry Bradshaw | NaN | Chuck Noll | Minnesota Vikings | 6 | Fran Tarkenton | NaN | Bud Grant | 22 | 10 | . 45 1973-01-14 | 7 | Memorial Coliseum | Los Angeles | California | 90182 | Miami Dolphins | 14 | Bob Griese | NaN | Don Shula | Washington Redskins | 7 | Bill Kilmer | NaN | George Allen | 21 | 7 | . 49 1969-01-12 | 3 | Orange Bowl | Miami | Florida | 75389 | New York Jets | 16 | Joe Namath | NaN | Weeb Ewbank | Baltimore Colts | 7 | Earl Morrall | Johnny Unitas | Don Shula | 23 | 9 | . 4. Point difference distribution . Most combined scores are around 40-50 points, with the extremes being roughly equal distance away in opposite directions. Going up to the highest combined scores at 74 and 75, we find two games featuring dominant quarterback performances. One even happened recently in 2018&#39;s Super Bowl LII where Tom Brady&#39;s Patriots lost to Nick Foles&#39; underdog Eagles 41-33 for a combined score of 74. . Going down to the lowest combined scores, we have Super Bowl III and VII, which featured tough defenses that dominated. We also have Super Bowl IX in New Orleans in 1975, whose 16-6 score can be attributed to inclement weather. The field was slick from overnight rain, and it was cold at 46 °F (8 °C), making it hard for the Steelers and Vikings to do much offensively. This was the second-coldest Super Bowl ever and the last to be played in inclement weather for over 30 years. The NFL realized people like points, I guess. . UPDATE: In Super Bowl LIII in 2019, the Patriots and Rams broke the record for the lowest-scoring Super Bowl with a combined score of 16 points (13-3 for the Patriots). . Let&#39;s take a look at point difference now. . plt.hist(super_bowls.difference_pts) plt.xlabel(&#39;Point Difference&#39;) plt.ylabel(&#39;Number of Super Bowls&#39;) plt.hist(super_bowls[&#39;difference_pts&#39;]) plt.show() # Display the closest game(s) and biggest blowouts display(super_bowls[super_bowls[&#39;difference_pts&#39;] == min(super_bowls[&#39;difference_pts&#39;])]) display(super_bowls[super_bowls[&#39;difference_pts&#39;] &gt;= 35]) . date super_bowl venue city state attendance team_winner winning_pts qb_winner_1 qb_winner_2 coach_winner team_loser losing_pts qb_loser_1 qb_loser_2 coach_loser combined_pts difference_pts . 27 1991-01-27 | 25 | Tampa Stadium | Tampa | Florida | 73813 | New York Giants | 20 | Jeff Hostetler | NaN | Bill Parcells | Buffalo Bills | 19 | Jim Kelly | NaN | Marv Levy | 39 | 1 | . date super_bowl venue city state attendance team_winner winning_pts qb_winner_1 qb_winner_2 coach_winner team_loser losing_pts qb_loser_1 qb_loser_2 coach_loser combined_pts difference_pts . 4 2014-02-02 | 48 | MetLife Stadium | East Rutherford | New Jersey | 82529 | Seattle Seahawks | 43 | Russell Wilson | NaN | Pete Carroll | Denver Broncos | 8 | Peyton Manning | NaN | John Fox | 51 | 35 | . 25 1993-01-31 | 27 | Rose Bowl | Pasadena | California | 98374 | Dallas Cowboys | 52 | Troy Aikman | NaN | Jimmy Johnson | Buffalo Bills | 17 | Jim Kelly | Frank Reich | Marv Levy | 69 | 35 | . 28 1990-01-28 | 24 | Louisiana Superdome | New Orleans | Louisiana | 72919 | San Francisco 49ers | 55 | Joe Montana | NaN | George Seifert | Denver Broncos | 10 | John Elway | NaN | Dan Reeves | 65 | 45 | . 32 1986-01-26 | 20 | Louisiana Superdome | New Orleans | Louisiana | 73818 | Chicago Bears | 46 | Jim McMahon | NaN | Mike Ditka | New England Patriots | 10 | Tony Eason | Steve Grogan | Raymond Berry | 56 | 36 | . 5. Do blowouts translate to lost viewers? . The vast majority of Super Bowls are close games. Makes sense. Both teams are likely to be deserving if they&#39;ve made it this far. The closest game ever was when the Buffalo Bills lost to the New York Giants by 1 point in 1991, which was best remembered for Scott Norwood&#39;s last-second missed field goal attempt that went wide right, kicking off four Bills Super Bowl losses in a row. Poor Scott. The biggest point discrepancy ever was 45 points (!) where Hall of Famer Joe Montana&#39;s led the San Francisco 49ers to victory in 1990, one year before the closest game ever. . I remember watching the Seahawks crush the Broncos by 35 points (43-8) in 2014, which was a boring experience in my opinion. The game was never really close. I&#39;m pretty sure we changed the channel at the end of the third quarter. Let&#39;s combine our game data and TV to see if this is a universal phenomenon. Do large point differences translate to lost viewers? We can plot household share (average percentage of U.S. households with a TV in use that were watching for the entire broadcast) vs. point difference to find out. . games_tv = pd.merge(tv[tv[&#39;super_bowl&#39;] &gt; 1], super_bowls, on=&#39;super_bowl&#39;) # Import seaborn import seaborn as sns # Create a scatter plot with a linear regression model fit sns.regplot(x=games_tv[&#39;difference_pts&#39;], y=games_tv[&#39;share_household&#39;], data=games_tv) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fea282df470&gt; . 6. Viewership and the ad industry over time . The downward sloping regression line and the 95% confidence interval for that regression suggest that bailing on the game if it is a blowout is common. Though it matches our intuition, we must take it with a grain of salt because the linear relationship in the data is weak due to our small sample size of 52 games. . Regardless of the score though, I bet most people stick it out for the halftime show, which is good news for the TV networks and advertisers. A 30-second spot costs a pretty $5 million now, but has it always been that way? And how have number of viewers and household ratings trended alongside ad cost? We can find out using line plots that share a &quot;Super Bowl&quot; x-axis. . plt.subplot(3, 1, 1) plt.plot(tv[&#39;super_bowl&#39;], tv[&#39;avg_us_viewers&#39;], color=&#39;#648FFF&#39;) plt.title(&#39;Average Number of US Viewers&#39;) # Activate the middle subplot plt.subplot(3, 1, 2) plt.plot(tv[&#39;super_bowl&#39;], tv[&#39;rating_household&#39;], color=&#39;#DC267F&#39;) plt.title(&#39;Household Rating&#39;) # Activate the bottom subplot plt.subplot(3, 1, 3) plt.plot(tv[&#39;super_bowl&#39;], tv[&#39;ad_cost&#39;], color=&#39;#FFB000&#39;) plt.title(&#39;Ad Cost&#39;) plt.xlabel(&#39;SUPER BOWL&#39;) # Improve the spacing between subplots plt.tight_layout() . 7. Halftime shows weren&#39;t always this great . We can see viewers increased before ad costs did. Maybe the networks weren&#39;t very data savvy and were slow to react? Makes sense since DataCamp didn&#39;t exist back then. . Another hypothesis: maybe halftime shows weren&#39;t that good in the earlier years? The modern spectacle of the Super Bowl has a lot to do with the cultural prestige of big halftime acts. I went down a YouTube rabbit hole and it turns out the old ones weren&#39;t up to today&#39;s standards. Some offenders: . Super Bowl XXVI in 1992: A Frosty The Snowman rap performed by children. | Super Bowl XXIII in 1989: An Elvis impersonator that did magic tricks and didn&#39;t even sing one Elvis song. | Super Bowl XXI in 1987: Tap dancing ponies. (Okay, that&#39;s pretty awesome actually.) | . It turns out Michael Jackson&#39;s Super Bowl XXVII performance, one of the most watched events in American TV history, was when the NFL realized the value of Super Bowl airtime and decided they needed to sign big name acts from then on out. The halftime shows before MJ indeed weren&#39;t that impressive, which we can see by filtering our halftime_musician data. . halftime_musicians[halftime_musicians[&#39;super_bowl&#39;] &lt;= 27] . super_bowl musician num_songs . 80 27 | Michael Jackson | 5.0 | . 81 26 | Gloria Estefan | 2.0 | . 82 26 | University of Minnesota Marching Band | NaN | . 83 25 | New Kids on the Block | 2.0 | . 84 24 | Pete Fountain | 1.0 | . 85 24 | Doug Kershaw | 1.0 | . 86 24 | Irma Thomas | 1.0 | . 87 24 | Pride of Nicholls Marching Band | NaN | . 88 24 | The Human Jukebox | NaN | . 89 24 | Pride of Acadiana | NaN | . 90 23 | Elvis Presto | 7.0 | . 91 22 | Chubby Checker | 2.0 | . 92 22 | San Diego State University Marching Aztecs | NaN | . 93 22 | Spirit of Troy | NaN | . 94 21 | Grambling State University Tiger Marching Band | 8.0 | . 95 21 | Spirit of Troy | 8.0 | . 96 20 | Up with People | NaN | . 97 19 | Tops In Blue | NaN | . 98 18 | The University of Florida Fightin&#39; Gator March... | 7.0 | . 99 18 | The Florida State University Marching Chiefs | 7.0 | . 100 17 | Los Angeles Unified School District All City H... | NaN | . 101 16 | Up with People | NaN | . 102 15 | The Human Jukebox | NaN | . 103 15 | Helen O&#39;Connell | NaN | . 104 14 | Up with People | NaN | . 105 14 | Grambling State University Tiger Marching Band | NaN | . 106 13 | Ken Hamilton | NaN | . 107 13 | Gramacks | NaN | . 108 12 | Tyler Junior College Apache Band | NaN | . 109 12 | Pete Fountain | NaN | . 110 12 | Al Hirt | NaN | . 111 11 | Los Angeles Unified School District All City H... | NaN | . 112 10 | Up with People | NaN | . 113 9 | Mercer Ellington | NaN | . 114 9 | Grambling State University Tiger Marching Band | NaN | . 115 8 | University of Texas Longhorn Band | NaN | . 116 8 | Judy Mallett | NaN | . 117 7 | University of Michigan Marching Band | NaN | . 118 7 | Woody Herman | NaN | . 119 7 | Andy Williams | NaN | . 120 6 | Ella Fitzgerald | NaN | . 121 6 | Carol Channing | NaN | . 122 6 | Al Hirt | NaN | . 123 6 | United States Air Force Academy Cadet Chorale | NaN | . 124 5 | Southeast Missouri State Marching Band | NaN | . 125 4 | Marguerite Piazza | NaN | . 126 4 | Doc Severinsen | NaN | . 127 4 | Al Hirt | NaN | . 128 4 | The Human Jukebox | NaN | . 129 3 | Florida A&amp;M University Marching 100 Band | NaN | . 130 2 | Grambling State University Tiger Marching Band | NaN | . 131 1 | University of Arizona Symphonic Marching Band | NaN | . 132 1 | Grambling State University Tiger Marching Band | NaN | . 133 1 | Al Hirt | NaN | . 8. Who has the most halftime show appearances? . Lots of marching bands. American jazz clarinetist Pete Fountain. Miss Texas 1973 playing a violin. Nothing against those performers, they&#39;re just simply not Beyoncé. To be fair, no one is. . Let&#39;s see all of the musicians that have done more than one halftime show, including their performance counts. . halftime_appearances = halftime_musicians.groupby(&#39;musician&#39;).count()[&#39;super_bowl&#39;].reset_index() halftime_appearances = halftime_appearances.sort_values(&#39;super_bowl&#39;, ascending=False) # Display musicians with more than one halftime show appearance display(halftime_appearances[halftime_appearances.super_bowl &gt; 1]) . musician super_bowl . 28 Grambling State University Tiger Marching Band | 6 | . 104 Up with People | 4 | . 1 Al Hirt | 4 | . 83 The Human Jukebox | 3 | . 76 Spirit of Troy | 2 | . 25 Florida A&amp;M University Marching 100 Band | 2 | . 26 Gloria Estefan | 2 | . 102 University of Minnesota Marching Band | 2 | . 10 Bruno Mars | 2 | . 64 Pete Fountain | 2 | . 5 Beyoncé | 2 | . 36 Justin Timberlake | 2 | . 57 Nelly | 2 | . 44 Los Angeles Unified School District All City H... | 2 | . 9. Who performed the most songs in a halftime show? . The world famous Grambling State University Tiger Marching Band takes the crown with six appearances. Beyoncé, Justin Timberlake, Nelly, and Bruno Mars are the only post-Y2K musicians with multiple appearances (two each). . From our previous inspections, the num_songs column has lots of missing values: . A lot of the marching bands don&#39;t have num_songs entries. | For non-marching bands, missing data starts occurring at Super Bowl XX. | . Let&#39;s filter out marching bands by filtering out musicians with the word &quot;Marching&quot; in them and the word &quot;Spirit&quot; (a common naming convention for marching bands is &quot;Spirit of [something]&quot;). Then we&#39;ll filter for Super Bowls after Super Bowl XX to address the missing data issue, then let&#39;s see who has the most number of songs. . no_bands = halftime_musicians[~halftime_musicians.musician.str.contains(&#39;Marching&#39;)] no_bands = no_bands[~no_bands.musician.str.contains(&#39;Spirit&#39;)] # Plot a histogram of number of songs per performance most_songs = int(max(no_bands[&#39;num_songs&#39;].values)) plt.hist(no_bands.num_songs.dropna(), bins=most_songs) plt.xlabel(&#39;Number of Songs Per Halftime Show Performance&#39;) plt.ylabel(&#39;Number of Musicians&#39;) plt.show() # Sort the non-band musicians by number of songs per appearance... no_bands = no_bands.sort_values(&#39;num_songs&#39;, ascending=False) # ...and display the top 15 display(no_bands.head(15)) . super_bowl musician num_songs . 0 52 | Justin Timberlake | 11.0 | . 70 30 | Diana Ross | 10.0 | . 10 49 | Katy Perry | 8.0 | . 2 51 | Lady Gaga | 7.0 | . 90 23 | Elvis Presto | 7.0 | . 33 41 | Prince | 7.0 | . 16 47 | Beyoncé | 7.0 | . 14 48 | Bruno Mars | 6.0 | . 3 50 | Coldplay | 6.0 | . 25 45 | The Black Eyed Peas | 6.0 | . 20 46 | Madonna | 5.0 | . 30 44 | The Who | 5.0 | . 80 27 | Michael Jackson | 5.0 | . 64 32 | The Temptations | 4.0 | . 36 39 | Paul McCartney | 4.0 | . 10. Conclusion . So most non-band musicians do 1-3 songs per halftime show. It&#39;s important to note that the duration of the halftime show is fixed (roughly 12 minutes) so songs per performance is more a measure of how many hit songs you have. JT went off in 2018, wow. 11 songs! Diana Ross comes in second with 10 in her medley in 1996. . In this notebook, we loaded, cleaned, then explored Super Bowl game, television, and halftime show data. We visualized the distributions of combined points, point differences, and halftime show performances using histograms. We used line plots to see how ad cost increases lagged behind viewership increases. And we discovered that blowouts do appear to lead to a drop in viewers. . This year&#39;s Big Game will be here before you know it. Who do you think will win Super Bowl LIII? . UPDATE: Spoiler alert. . patriots = &#39;New England Patriots&#39; rams = &#39;Los Angeles Rams&#39; # Who will win Super Bowl LIII? super_bowl_LIII_winner = patriots print(&#39;The winner of Super Bowl LIII will be the&#39;, super_bowl_LIII_winner) . The winner of Super Bowl LIII will be the New England Patriots .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/01/29/TV,-Halftime-Shows-and-the-Big-Game.html",
            "relUrl": "/datacamp/projects/python/2020/01/29/TV,-Halftime-Shows-and-the-Big-Game.html",
            "date": " • Jan 29, 2020"
        }
        
    
  
    
        ,"post33": {
            "title": "Risk and Returns: The Sharpe Ratio",
            "content": "1. Meet Professor William Sharpe . An investment may make sense if we expect it to return more money than it costs. But returns are only part of the story because they are risky - there may be a range of possible outcomes. How does one compare different investments that may deliver similar results on average, but exhibit different levels of risks? . . Enter William Sharpe. He introduced the reward-to-variability ratio in 1966 that soon came to be called the Sharpe Ratio. It compares the expected returns for two investment opportunities and calculates the additional return per unit of risk an investor could obtain by choosing one over the other. In particular, it looks at the difference in returns for two investments and compares the average difference to the standard deviation (as a measure of risk) of this difference. A higher Sharpe ratio means that the reward will be higher for a given amount of risk. It is common to compare a specific opportunity against a benchmark that represents an entire category of investments. . The Sharpe ratio has been one of the most popular risk/return measures in finance, not least because it&#39;s so simple to use. It also helped that Professor Sharpe won a Nobel Memorial Prize in Economics in 1990 for his work on the capital asset pricing model (CAPM). . The Sharpe ratio is usually calculated for a portfolio and uses the risk-free interest rate as benchmark. We will simplify our example and use stocks instead of a portfolio. We will also use a stock index as benchmark rather than the risk-free interest rate because both are readily available at daily frequencies and we do not have to get into converting interest rates from annual to daily frequency. Just keep in mind that you would run the same calculation with portfolio returns and your risk-free rate of choice, e.g, the 3-month Treasury Bill Rate. . So let&#39;s learn about the Sharpe ratio by calculating it for the stocks of the two tech giants Facebook and Amazon. As benchmark we&#39;ll use the S&amp;P 500 that measures the performance of the 500 largest stocks in the US. When we use a stock index instead of the risk-free rate, the result is called the Information Ratio and is used to benchmark the return on active portfolio management because it tells you how much more return for a given unit of risk your portfolio manager earned relative to just putting your money into a low-cost index fund. . import pandas as pd import numpy as np import matplotlib.pyplot as plt # Settings to produce nice plots in a Jupyter notebook plt.style.use(&#39;fivethirtyeight&#39;) %matplotlib inline # Reading in the data stock_data = pd.read_csv(&#39;datasets/stock_data.csv&#39;, parse_dates=[&#39;Date&#39;], index_col=&#39;Date&#39;) benchmark_data = pd.read_csv(&#39;datasets/benchmark_data.csv&#39;, parse_dates=[&#39;Date&#39;], index_col=&#39;Date&#39;).dropna() . 2. A first glance at the data . Let&#39;s take a look the data to find out how many observations and variables we have at our disposal. . print(&#39;Stocks n&#39;) stock_data.info() stock_data.head() # Display summary for benchmark_data print(&#39; nBenchmarks n&#39;) benchmark_data.info() benchmark_data.head() . Stocks &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; DatetimeIndex: 252 entries, 2016-01-04 to 2016-12-30 Data columns (total 2 columns): Amazon 252 non-null float64 Facebook 252 non-null float64 dtypes: float64(2) memory usage: 5.9 KB Benchmarks &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; DatetimeIndex: 252 entries, 2016-01-04 to 2016-12-30 Data columns (total 1 columns): S&amp;P 500 252 non-null float64 dtypes: float64(1) memory usage: 3.9 KB . S&amp;P 500 . Date . 2016-01-04 2012.66 | . 2016-01-05 2016.71 | . 2016-01-06 1990.26 | . 2016-01-07 1943.09 | . 2016-01-08 1922.03 | . 3. Plot &amp; summarize daily prices for Amazon and Facebook . Before we compare an investment in either Facebook or Amazon with the index of the 500 largest companies in the US, let&#39;s visualize the data, so we better understand what we&#39;re dealing with. . stock_data.plot(kind=&#39;line&#39;, subplots=True, title=&#39;Stock Data&#39;) # summarize the stock_data stock_data.describe() . Amazon Facebook . count 252.000000 | 252.000000 | . mean 699.523135 | 117.035873 | . std 92.362312 | 8.899858 | . min 482.070007 | 94.160004 | . 25% 606.929993 | 112.202499 | . 50% 727.875000 | 117.765000 | . 75% 767.882492 | 123.902503 | . max 844.359985 | 133.279999 | . 4. Visualize &amp; summarize daily values for the S&amp;P 500 . Let&#39;s also take a closer look at the value of the S&amp;P 500, our benchmark. . benchmark_data.plot(kind=&#39;line&#39;, title=&#39;S&amp;P 500&#39;) # summarize the benchmark_data benchmark_data.describe() . S&amp;P 500 . count 252.000000 | . mean 2094.651310 | . std 101.427615 | . min 1829.080000 | . 25% 2047.060000 | . 50% 2104.105000 | . 75% 2169.075000 | . max 2271.720000 | . 5. The inputs for the Sharpe Ratio: Starting with Daily Stock Returns . The Sharpe Ratio uses the difference in returns between the two investment opportunities under consideration. . However, our data show the historical value of each investment, not the return. To calculate the return, we need to calculate the percentage change in value from one day to the next. We&#39;ll also take a look at the summary statistics because these will become our inputs as we calculate the Sharpe Ratio. Can you already guess the result? . stock_returns = stock_data.pct_change() # plot the daily returns stock_returns.plot(kind=&#39;line&#39;) # summarize the daily returns stock_returns.describe() . Amazon Facebook . count 251.000000 | 251.000000 | . mean 0.000818 | 0.000626 | . std 0.018383 | 0.017840 | . min -0.076100 | -0.058105 | . 25% -0.007211 | -0.007220 | . 50% 0.000857 | 0.000879 | . 75% 0.009224 | 0.008108 | . max 0.095664 | 0.155214 | . 6. Daily S&amp;P 500 returns . For the S&amp;P 500, calculating daily returns works just the same way, we just need to make sure we select it as a Series using single brackets [] and not as a DataFrame to facilitate the calculations in the next step. . sp_returns = benchmark_data.pct_change() # plot the daily returns benchmark_data.plot(kind=&#39;line&#39;) # summarize the daily returns benchmark_data.describe() . S&amp;P 500 . count 252.000000 | . mean 2094.651310 | . std 101.427615 | . min 1829.080000 | . 25% 2047.060000 | . 50% 2104.105000 | . 75% 2169.075000 | . max 2271.720000 | . 7. Calculating Excess Returns for Amazon and Facebook vs. S&amp;P 500 . Next, we need to calculate the relative performance of stocks vs. the S&amp;P 500 benchmark. This is calculated as the difference in returns between stock_returns and sp_returns for each day. . excess_returns = stock_returns.sub(sp_returns, axis=0) # plot the excess_returns excess_returns.plot(kind=&#39;line&#39;) # summarize the excess_returns excess_returns.describe() . Amazon Facebook S&amp;P 500 . count 0.0 | 0.0 | 0.0 | . mean NaN | NaN | NaN | . std NaN | NaN | NaN | . min NaN | NaN | NaN | . 25% NaN | NaN | NaN | . 50% NaN | NaN | NaN | . 75% NaN | NaN | NaN | . max NaN | NaN | NaN | . 8. The Sharpe Ratio, Step 1: The Average Difference in Daily Returns Stocks vs S&amp;P 500 . Now we can finally start computing the Sharpe Ratio. First we need to calculate the average of the excess_returns. This tells us how much more or less the investment yields per day compared to the benchmark. . # ... YOUR CODE FOR TASK 8 HERE ... avg_excess_return = excess_returns.mean() # plot avg_excess_returns avg_excess_return.plot.bar(title=&#39;Mean of the Return Difference&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f04d305b5f8&gt; . 9. The Sharpe Ratio, Step 2: Standard Deviation of the Return Difference . It looks like there was quite a bit of a difference between average daily returns for Amazon and Facebook. . Next, we calculate the standard deviation of the excess_returns. This shows us the amount of risk an investment in the stocks implies as compared to an investment in the S&amp;P 500. . sd_excess_return = excess_returns.std() # plot the standard deviations sd_excess_return.plot.bar(title=&#39;Standard Deviation of the Return Difference&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f04d30e19e8&gt; . 10. Putting it all together . Now we just need to compute the ratio of avg_excess_returns and sd_excess_returns. The result is now finally the Sharpe ratio and indicates how much more (or less) return the investment opportunity under consideration yields per unit of risk. . The Sharpe Ratio is often annualized by multiplying it by the square root of the number of periods. We have used daily data as input, so we&#39;ll use the square root of the number of trading days (5 days, 52 weeks, minus a few holidays): √252 . daily_sharpe_ratio = avg_excess_return.div(sd_excess_return, axis=0) # annualize the sharpe ratio annual_factor = np.sqrt(252) annual_sharpe_ratio = daily_sharpe_ratio.mul(annual_factor) # plot the annualized sharpe ratio annual_sharpe_ratio.plot.bar(title=&#39;Annualized Sharpe Ratio: Stocks vs S&amp;P 500&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f04d2fad2e8&gt; . 11. Conclusion . Given the two Sharpe ratios, which investment should we go for? In 2016, Amazon had a Sharpe ratio twice as high as Facebook. This means that an investment in Amazon returned twice as much compared to the S&amp;P 500 for each unit of risk an investor would have assumed. In other words, in risk-adjusted terms, the investment in Amazon would have been more attractive. . This difference was mostly driven by differences in return rather than risk between Amazon and Facebook. The risk of choosing Amazon over FB (as measured by the standard deviation) was only slightly higher so that the higher Sharpe ratio for Amazon ends up higher mainly due to the higher average daily returns for Amazon. . When faced with investment alternatives that offer both different returns and risks, the Sharpe Ratio helps to make a decision by adjusting the returns by the differences in risk and allows an investor to compare investment opportunities on equal terms, that is, on an &#39;apples-to-apples&#39; basis. . buy_amazon = True buy_facebook = True .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/01/29/Risk-and-Returns-The-Sharpe-Ratio.html",
            "relUrl": "/datacamp/projects/python/2020/01/29/Risk-and-Returns-The-Sharpe-Ratio.html",
            "date": " • Jan 29, 2020"
        }
        
    
  
    
        ,"post34": {
            "title": "Introduction to DataCamp Projects (Python)",
            "content": "1. This is a Jupyter notebook! . A Jupyter notebook is a document that contains text cells (what you&#39;re reading right now) and code cells. What is special with a notebook is that it&#39;s interactive: You can change or add code cells, and then run a cell by first selecting it and then clicking the run cell button above ( ▶| Run ) or hitting ctrl + enter. . . The result will be displayed directly in the notebook. You could use a notebook as a simple calculator. For example, it&#39;s estimated that on average 256 children were born every minute in 2016. The code cell below calculates how many children were born on average on a day. . 256 * 60 * 24 # Children × minutes × hours . 368640 . 2. Put any code in code cells . But a code cell can contain much more than a simple one-liner! This is a notebook running python and you can put any python code in a code cell (but notebooks can run other languages too, like R). Below is a code cell where we define a whole new function (greet). To show the output of greet we run it last in the code cell as the last value is always printed out. . def greet(first_name, last_name): greeting = &#39;My name is &#39; + last_name + &#39;, &#39; + first_name + &#39; &#39; + last_name + &#39;!&#39; return greeting # Replace with your first and last name. # That is, unless your name is already James Bond. greet(&#39;Anurag&#39;, &#39;Peddi&#39;) . &#39;My name is Peddi, Anurag Peddi!&#39; . 3. Jupyter notebooks &#9825; data . We&#39;ve seen that notebooks can display basic objects such as numbers and strings. But notebooks also support the objects used in data science, which makes them great for interactive data analysis! . For example, below we create a pandas DataFrame by reading in a csv-file with the average global temperature for the years 1850 to 2016. If we look at the head of this DataFrame the notebook will render it as a nice-looking table. . import pandas as pd # Reading in the global temperature data global_temp = pd.read_csv(&#39;datasets/global_temperature.csv&#39;) # Take a look at the first datapoints # ... YOUR CODE FOR TASK 3 ... print(global_temp.head()) . year degrees_celsius 0 1850 7.74 1 1851 8.09 2 1852 7.97 3 1853 7.93 4 1854 8.19 . 4. Jupyter notebooks &#9825; plots . Tables are nice but — as the saying goes — &quot;a plot can show a thousand data points&quot;. Notebooks handle plots as well, but it requires a bit of magic. Here magic does not refer to any arcane rituals but to so-called &quot;magic commands&quot; that affect how the Jupyter notebook works. Magic commands start with either % or %% and the command we need to nicely display plots inline is %matplotlib inline. With this magic in place, all plots created in code cells will automatically be displayed inline. . Let&#39;s take a look at the global temperature for the last 150 years. . %matplotlib inline import matplotlib.pyplot as plt # Plotting global temperature in degrees celsius by year plt.plot(global_temp[&#39;year&#39;], global_temp[&#39;degrees_celsius&#39;]) # Adding some nice labels plt.xlabel(&#39;Year&#39;) plt.ylabel(&#39;Degree Celsius&#39;) . &lt;matplotlib.text.Text at 0x7fc6bdfd1d30&gt; . 5. Jupyter notebooks &#9825; a lot more . Tables and plots are the most common outputs when doing data analysis, but Jupyter notebooks can render many more types of outputs such as sound, animation, video, etc. Yes, almost anything that can be shown in a modern web browser. This also makes it possible to include interactive widgets directly in the notebook! . For example, this (slightly complicated) code will create an interactive map showing the locations of the three largest smartphone companies in 2016. You can move and zoom the map, and you can click the markers for more info! . import folium phone_map = folium.Map() # Top three smart phone companies by market share in 2016 companies = [ {&#39;loc&#39;: [37.4970, 127.0266], &#39;label&#39;: &#39;Samsung: ...%&#39;}, {&#39;loc&#39;: [37.3318, -122.0311], &#39;label&#39;: &#39;Apple: ...%&#39;}, {&#39;loc&#39;: [22.5431, 114.0579], &#39;label&#39;: &#39;Huawei: ...%&#39;}] # Adding markers to the map for company in companies: marker = folium.Marker(location=company[&#39;loc&#39;], popup=company[&#39;label&#39;]) marker.add_to(phone_map) # The last object in the cell always gets shown in the notebook phone_map . 6. Goodbye for now! . This was just a short introduction to Jupyter notebooks, an open source technology that is increasingly used for data science and analysis. I hope you enjoyed it! :) . I_am_ready = False # Ps. # Feel free to try out any other stuff in this notebook. # It&#39;s all yours! .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/01/29/Introduction-to-DataCamp-Projects.html",
            "relUrl": "/datacamp/projects/python/2020/01/29/Introduction-to-DataCamp-Projects.html",
            "date": " • Jan 29, 2020"
        }
        
    
  
    
        ,"post35": {
            "title": "Exploring the Bitcoin Cryptocurrency Market",
            "content": "1. Bitcoin. Cryptocurrencies. So hot right now. . Since the launch of Bitcoin in 2008, hundreds of similar projects based on the blockchain technology have emerged. We call these cryptocurrencies (also coins or cryptos in the Internet slang). Some are extremely valuable nowadays, and others may have the potential to become extremely valuable in the future1. In fact, on the 6th of December of 2017, Bitcoin has a market capitalization above $200 billion. . The astonishing increase of Bitcoin market capitalization in 2017. . *1 WARNING: The cryptocurrency market is exceptionally volatile and any money you put in might disappear into thin air. Cryptocurrencies mentioned here might be scams similar to Ponzi Schemes or have many other issues (overvaluation, technical, etc.). Please do not mistake this for investment advice. * . That said, let&#39;s get to business. As a first task, we will load the current data from the coinmarketcap API and display it in the output. . import requests # Importing pandas import pandas as pd # Importing matplotlib and setting aesthetics for plotting later. import matplotlib.pyplot as plt %matplotlib inline %config InlineBackend.figure_format = &#39;svg&#39; plt.style.use(&#39;fivethirtyeight&#39;) # Getting the data data = requests.get(&quot;https://api.coinmarketcap.com/v1/ticker/&quot;) # Reading in current data from coinmarketcap.com current = pd.DataFrame(data.json()) # Printing out the first few lines # ... YOUR CODE FOR TASK 1 ... current.head() . 24h_volume_usd available_supply id last_updated market_cap_usd max_supply name percent_change_1h percent_change_24h percent_change_7d price_btc price_usd rank symbol total_supply . 0 21766312573.7 | 18180900.0 | bitcoin | 1579958614 | 151521615980 | 21000000.0 | Bitcoin | 0.03 | -1.13 | -6.29 | 1.0 | 8334.10975142 | 1 | BTC | 18180900.0 | . 1 9129485280.35 | 109423844.0 | ethereum | 1579958601 | 17547851782.0 | None | Ethereum | 0.37 | -0.59 | -6.89 | 0.01924797 | 160.365886634 | 2 | ETH | 109423844.0 | . 2 1481529835.06 | 43675903665.0 | xrp | 1579958645 | 9612916998.0 | 100000000000 | XRP | 0.23 | -1.39 | -7.94 | 0.00002642 | 0.2200965794 | 3 | XRP | 99991104396.0 | . 3 2448790511.0 | 18242200.0 | bitcoin-cash | 1579958648 | 5650036276.0 | 21000000.0 | Bitcoin Cash | -0.01 | -3.55 | -13.5 | 0.03717499 | 309.723403741 | 4 | BCH | 18242200.0 | . 4 2131454629.84 | 18222577.0 | bitcoin-sv | 1579958651 | 4722454400.0 | 21000000.0 | Bitcoin SV | -1.01 | -6.5 | -0.88 | 0.03110533 | 259.154035229 | 5 | BSV | 18222577.0 | . 2. Full dataset, filtering, and reproducibility . The previous API call returns only the first 100 coins, and we want to explore as many coins as possible. Moreover, we can&#39;t produce reproducible analysis with live online data. To solve these problems, we will load a CSV we conveniently saved on the 6th of December of 2017 using the API call https://api.coinmarketcap.com/v1/ticker/?limit=0 named datasets/coinmarketcap_06122017.csv. . dec6 = pd.read_csv(&#39;datasets/coinmarketcap_06122017.csv&#39;) # Selecting the &#39;id&#39; and the &#39;market_cap_usd&#39; columns market_cap_raw = dec6[[&#39;id&#39;, &#39;market_cap_usd&#39;]] # Counting the number of values # ... YOUR CODE FOR TASK 2 ... print(market_cap_raw.count()) . id 1326 market_cap_usd 1031 dtype: int64 . 3. Discard the cryptocurrencies without a market capitalization . Why do the count() for id and market_cap_usd differ above? It is because some cryptocurrencies listed in coinmarketcap.com have no known market capitalization, this is represented by NaN in the data, and NaNs are not counted by count(). These cryptocurrencies are of little interest to us in this analysis, so they are safe to remove. . cap = market_cap_raw.query(&#39;market_cap_usd &gt; 0&#39;) # Counting the number of values again # ... YOUR CODE FOR TASK 3 ... print(cap.count()) . id 1031 market_cap_usd 1031 dtype: int64 . 4. How big is Bitcoin compared with the rest of the cryptocurrencies? . At the time of writing, Bitcoin is under serious competition from other projects, but it is still dominant in market capitalization. Let&#39;s plot the market capitalization for the top 10 coins as a barplot to better visualize this. . TOP_CAP_TITLE = &#39;Top 10 market capitalization&#39; TOP_CAP_YLABEL = &#39;% of total cap&#39; # Selecting the first 10 rows and setting the index cap10 = cap.iloc[:10, :] cap10 = cap10.set_index([&#39;id&#39;], drop=True) # Calculating market_cap_perc cap10 = cap10.assign(market_cap_perc=lambda x: 100 * x[&#39;market_cap_usd&#39;] / cap[&#39;market_cap_usd&#39;].sum()) # Plotting the barplot with the title defined above ax = cap10.plot.bar(title=TOP_CAP_TITLE) # Annotating the y axis with the label defined above # ... YOUR CODE FOR TASK 4 ... ax.set_ylabel(TOP_CAP_YLABEL) . Text(0,0.5,&#39;% of total cap&#39;) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 5. Making the plot easier to read and more informative . While the plot above is informative enough, it can be improved. Bitcoin is too big, and the other coins are hard to distinguish because of this. Instead of the percentage, let&#39;s use a log10 scale of the &quot;raw&quot; capitalization. Plus, let&#39;s use color to group similar coins and make the plot more informative1. . For the colors rationale: bitcoin-cash and bitcoin-gold are forks of the bitcoin blockchain2. Ethereum and Cardano both offer Turing Complete smart contracts. Iota and Ripple are not minable. Dash, Litecoin, and Monero get their own color. . 1 This coloring is a simplification. There are more differences and similarities that are not being represented here. . 2 The bitcoin forks are actually very different, but it is out of scope to talk about them here. Please see the warning above and do your own research. . COLORS = [&#39;orange&#39;, &#39;green&#39;, &#39;orange&#39;, &#39;cyan&#39;, &#39;cyan&#39;, &#39;blue&#39;, &#39;silver&#39;, &#39;orange&#39;, &#39;red&#39;, &#39;green&#39;] # Plotting market_cap_usd as before but adding the colors and scaling the y-axis ax = cap.plot(kind=&#39;bar&#39;, title=&#39;Top 10 market capitalization&#39;, logy=True) # Annotating the y axis with &#39;USD&#39; # ... YOUR CODE FOR TASK 5 ... ax.set_ylabel(&#39;USD&#39;) # Final touch! Removing the xlabel as it is not very informative # ... YOUR CODE FOR TASK 5 ... ax.get_xaxis().set_visible(False) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 6. What is going on?! Volatility in cryptocurrencies . The cryptocurrencies market has been spectacularly volatile since the first exchange opened. This notebook didn&#39;t start with a big, bold warning for nothing. Let&#39;s explore this volatility a bit more! We will begin by selecting and plotting the 24 hours and 7 days percentage change, which we already have available. . volatility = dec6[[&#39;id&#39;, &#39;percent_change_24h&#39;, &#39;percent_change_7d&#39;]] # Setting the index to &#39;id&#39; and dropping all NaN rows volatility = volatility.set_index(&#39;id&#39;).dropna() # Sorting the DataFrame by percent_change_24h in ascending order volatility = volatility.sort_values(&#39;percent_change_24h&#39;) # Checking the first few rows # ... YOUR CODE FOR TASK 6 ... print(volatility.head()) . percent_change_24h percent_change_7d id flappycoin -95.85 -96.61 credence-coin -94.22 -95.31 coupecoin -93.93 -61.24 tyrocoin -79.02 -87.43 petrodollar -76.55 542.96 . 7. Well, we can already see that things are a bit crazy . It seems you can lose a lot of money quickly on cryptocurrencies. Let&#39;s plot the top 10 biggest gainers and top 10 losers in market capitalization. . def top10_subplot(volatility_series, title): # Making the subplot and the figure for two side by side plots fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 6)) # Plotting with pandas the barchart for the top 10 losers volatility_series.head(10).plot(kind=&#39;bar&#39;, ax=axes[0]) # Setting the figure&#39;s main title to the text passed as parameter # ... YOUR CODE FOR TASK 7 ... fig.suptitle(title) # Setting the ylabel to &#39;% change&#39; # ... YOUR CODE FOR TASK 7 ... axes[0].set_ylabel(&#39;% change&#39;) axes[1].set_ylabel(&#39;% change&#39;) # Same as above, but for the top 10 winners volatility_series[-10:].plot(kind=&#39;bar&#39;, ax=axes[1]) # Returning this for good practice, might use later return fig, ax DTITLE = &quot;24 hours top losers and winners&quot; # Calling the function above with the 24 hours period series and title DTITLE fig, ax = top10_subplot(volatility, DTITLE) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 8. Ok, those are... interesting. Let&#39;s check the weekly Series too. . 800% daily increase?! Why are we doing this tutorial and not buying random coins?1 . After calming down, let&#39;s reuse the function defined above to see what is going weekly instead of daily. . 1 Please take a moment to understand the implications of the red plots on how much value some cryptocurrencies lose in such short periods of time . volatility7d = volatility.sort_values(&#39;percent_change_7d&#39;) WTITLE = &quot;Weekly top losers and winners&quot; # Calling the top10_subplot function fig, ax = top10_subplot(volatility7d[&#39;percent_change_7d&#39;], WTITLE) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 9. How small is small? . The names of the cryptocurrencies above are quite unknown, and there is a considerable fluctuation between the 1 and 7 days percentage changes. As with stocks, and many other financial products, the smaller the capitalization, the bigger the risk and reward. Smaller cryptocurrencies are less stable projects in general, and therefore even riskier investments than the bigger ones1. Let&#39;s classify our dataset based on Investopedia&#39;s capitalization definitions for company stocks. . 1 Cryptocurrencies are a new asset class, so they are not directly comparable to stocks. Furthermore, there are no limits set in stone for what a &quot;small&quot; or &quot;large&quot; stock is. Finally, some investors argue that bitcoin is similar to gold, this would make them more comparable to a commodity instead. . largecaps = cap.query(&#39;market_cap_usd &gt; 10**10&#39;) # Printing out largecaps # ... YOUR CODE FOR TASK 9 ... print(largecaps) . id market_cap_usd 0 bitcoin 2.130493e+11 1 ethereum 4.352945e+10 2 bitcoin-cash 2.529585e+10 3 iota 1.475225e+10 . 10. Most coins are tiny . Note that many coins are not comparable to large companies in market cap, so let&#39;s divert from the original Investopedia definition by merging categories. . This is all for now. Thanks for completing this project! . # &quot;cap&quot; DataFrame. Returns an int. # INSTRUCTORS NOTE: Since you made it to the end, consider it a gift :D def capcount(query_string): return cap.query(query_string).count().id # Labels for the plot LABELS = [&quot;biggish&quot;, &quot;micro&quot;, &quot;nano&quot;] # Using capcount count the biggish cryptos biggish = capcount(&#39;market_cap_usd &gt; 3*10**8&#39;) # Same as above for micro ... micro = capcount(&#39;market_cap_usd &lt; 3*10**8 and market_cap_usd &gt; 5*10**7&#39;) # ... and for nano nano = capcount(&#39;market_cap_usd &lt; 5*10**7&#39;) # Making a list with the 3 counts values = [biggish, micro, nano] # Plotting them with matplotlib # ... YOUR CODE FOR TASK 10 ... plt.bar(values) . TypeError Traceback (most recent call last) &lt;ipython-input-83-c482fdf68251&gt; in &lt;module&gt;() 22 # Plotting them with matplotlib 23 # ... YOUR CODE FOR TASK 10 ... &gt; 24 plt.bar(values) /usr/local/lib/python3.5/dist-packages/matplotlib/pyplot.py in bar(*args, **kwargs) 2646 mplDeprecation) 2647 try: -&gt; 2648 ret = ax.bar(*args, **kwargs) 2649 finally: 2650 ax._hold = washold /usr/local/lib/python3.5/dist-packages/matplotlib/__init__.py in inner(ax, *args, **kwargs) 1715 warnings.warn(msg % (label_namer, func.__name__), 1716 RuntimeWarning, stacklevel=2) -&gt; 1717 return func(ax, *args, **kwargs) 1718 pre_doc = inner.__doc__ 1719 if pre_doc is None: /usr/local/lib/python3.5/dist-packages/matplotlib/axes/_axes.py in bar(self, *args, **kwargs) 1963 break 1964 else: -&gt; 1965 raise exps[0] 1966 # if we matched the second-case, then the user passed in 1967 # left=val as a kwarg which we want to deprecate /usr/local/lib/python3.5/dist-packages/matplotlib/axes/_axes.py in bar(self, *args, **kwargs) 1955 for matcher in matchers: 1956 try: -&gt; 1957 dp, x, height, width, y, kwargs = matcher(*args, **kwargs) 1958 except TypeError as e: 1959 # This can only come from a no-match as there is TypeError: &lt;lambda&gt;() missing 1 required positional argument: &#39;height&#39; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/01/29/Exploring-the-Bitcoin-Cryptocurrency-Market.html",
            "relUrl": "/datacamp/projects/python/2020/01/29/Exploring-the-Bitcoin-Cryptocurrency-Market.html",
            "date": " • Jan 29, 2020"
        }
        
    
  
    
        ,"post36": {
            "title": "Exploring 67 years of LEGO",
            "content": "1. Introduction . Everyone loves Lego (unless you ever stepped on one). Did you know by the way that &quot;Lego&quot; was derived from the Danish phrase leg godt, which means &quot;play well&quot;? Unless you speak Danish, probably not. . In this project, we will analyze a fascinating dataset on every single lego block that has ever been built! . . . 2. Reading Data . A comprehensive database of lego blocks is provided by Rebrickable. The data is available as csv files and the schema is shown below. . . Let us start by reading in the colors data to get a sense of the diversity of lego sets! . import pandas as pd # Read colors data colors = pd.read_csv(&#39;datasets/colors.csv&#39;) # Print the first few rows colors.head() . id name rgb is_trans . 0 -1 | Unknown | 0033B2 | f | . 1 0 | Black | 05131D | f | . 2 1 | Blue | 0055BF | f | . 3 2 | Green | 237841 | f | . 4 3 | Dark Turquoise | 008F9B | f | . 3. Exploring Colors . Now that we have read the colors data, we can start exploring it! Let us start by understanding the number of colors available. . # -- YOUR CODE FOR TASK 3 -- num_colors = len(pd.unique(colors[&#39;name&#39;])) . 4. Transparent Colors in Lego Sets . The colors data has a column named is_trans that indicates whether a color is transparent or not. It would be interesting to explore the distribution of transparent vs. non-transparent colors. . # -- YOUR CODE FOR TASK 4 -- colors_summary = colors.groupby(&#39;is_trans&#39;).count() print(colors_summary) . id name rgb is_trans f 107 107 107 t 28 28 28 . 5. Explore Lego Sets . Another interesting dataset available in this database is the sets data. It contains a comprehensive list of sets over the years and the number of parts that each of these sets contained. . . Let us use this data to explore how the average number of parts in Lego sets has varied over the years. . %matplotlib inline import matplotlib.pyplot as plt sets = pd.read_csv(&#39;datasets/sets.csv&#39;) # Create a summary of average number of parts by year: `parts_by_year` parts_by_year = sets[[&#39;year&#39;, &#39;num_parts&#39;]].groupby(&#39;year&#39;).mean() # print(parts_by_year) # Plot trends in average number of parts by year plt.plot(parts_by_year.index, parts_by_year[&#39;num_parts&#39;]) . [&lt;matplotlib.lines.Line2D at 0x7eff4d91aa90&gt;] . 6. Lego Themes Over Years . Lego blocks ship under multiple themes. Let us try to get a sense of how the number of themes shipped has varied over the years. . # -- YOUR CODE HERE -- tmp = sets[[&#39;year&#39;, &#39;theme_id&#39;]].groupby(&#39;year&#39;).count() c1 = tmp.index c2 = pd.Series(tmp[&#39;theme_id&#39;]).tolist() themes_by_year = pd.DataFrame({&#39;year&#39;:c1}) themes_by_year[&#39;theme_id&#39;] = c2 print(themes_by_year) . year theme_id 0 1950 7 1 1953 4 2 1954 14 3 1955 28 4 1956 12 5 1957 21 6 1958 42 7 1959 4 8 1960 3 9 1961 17 10 1962 40 11 1963 18 12 1964 11 13 1965 10 14 1966 89 15 1967 21 16 1968 25 17 1969 69 18 1970 29 19 1971 45 20 1972 38 21 1973 68 22 1974 39 23 1975 31 24 1976 68 25 1977 92 26 1978 73 27 1979 82 28 1980 88 29 1981 79 .. ... ... 36 1988 68 37 1989 114 38 1990 85 39 1991 106 40 1992 115 41 1993 111 42 1994 128 43 1995 128 44 1996 144 45 1997 194 46 1998 325 47 1999 300 48 2000 327 49 2001 339 50 2002 447 51 2003 415 52 2004 371 53 2005 330 54 2006 283 55 2007 319 56 2008 349 57 2009 403 58 2010 444 59 2011 502 60 2012 615 61 2013 593 62 2014 715 63 2015 670 64 2016 609 65 2017 470 [66 rows x 2 columns] . 7. Wrapping It All Up! . Lego blocks offer an unlimited amount of fun across ages. We explored some interesting trends around colors, parts, and themes. . .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/01/29/Exploring-67-years-of-LEGO.html",
            "relUrl": "/datacamp/projects/python/2020/01/29/Exploring-67-years-of-LEGO.html",
            "date": " • Jan 29, 2020"
        }
        
    
  
    
        ,"post37": {
            "title": "Dr. Semmelweis and the Discovery of Handwashing",
            "content": "1. Meet Dr. Ignaz Semmelweis . This is Dr. Ignaz Semmelweis, a Hungarian physician born in 1818 and active at the Vienna General Hospital. If Dr. Semmelweis looks troubled it&#39;s probably because he&#39;s thinking about childbed fever: A deadly disease affecting women that just have given birth. He is thinking about it because in the early 1840s at the Vienna General Hospital as many as 10% of the women giving birth die from it. He is thinking about it because he knows the cause of childbed fever: It&#39;s the contaminated hands of the doctors delivering the babies. And they won&#39;t listen to him and wash their hands! . In this notebook, we&#39;re going to reanalyze the data that made Semmelweis discover the importance of handwashing. Let&#39;s start by looking at the data that made Semmelweis realize that something was wrong with the procedures at Vienna General Hospital. . # ... YOUR CODE FOR TASK 1 ... import pandas as pd from pandas import Series, DataFrame # Read datasets/yearly_deaths_by_clinic.csv into yearly yearly = pd.read_csv(&#39;datasets/yearly_deaths_by_clinic.csv&#39;) # Print out yearly # ... YOUR CODE FOR TASK 1 ... print(yearly) . year births deaths clinic 0 1841 3036 237 clinic 1 1 1842 3287 518 clinic 1 2 1843 3060 274 clinic 1 3 1844 3157 260 clinic 1 4 1845 3492 241 clinic 1 5 1846 4010 459 clinic 1 6 1841 2442 86 clinic 2 7 1842 2659 202 clinic 2 8 1843 2739 164 clinic 2 9 1844 2956 68 clinic 2 10 1845 3241 66 clinic 2 11 1846 3754 105 clinic 2 . 2. The alarming number of deaths . The table above shows the number of women giving birth at the two clinics at the Vienna General Hospital for the years 1841 to 1846. You&#39;ll notice that giving birth was very dangerous; an alarming number of women died as the result of childbirth, most of them from childbed fever. . We see this more clearly if we look at the proportion of deaths out of the number of women giving birth. Let&#39;s zoom in on the proportion of deaths at Clinic 1. . # ... YOUR CODE FOR TASK 2 ... yearly[&#39;proportion_deaths&#39;] = yearly[&#39;deaths&#39;]/yearly[&#39;births&#39;] # Extract clinic 1 data into yearly1 and clinic 2 data into yearly2 yearly1 = yearly[(yearly[&#39;clinic&#39;] == &#39;clinic 1&#39;)] yearly2 = yearly[(yearly[&#39;clinic&#39;] == &#39;clinic 2&#39;)] # Print out yearly1 # ... YOUR CODE FOR TASK 2 ... print(yearly1) . year births deaths clinic proportion_deaths 0 1841 3036 237 clinic 1 0.078063 1 1842 3287 518 clinic 1 0.157591 2 1843 3060 274 clinic 1 0.089542 3 1844 3157 260 clinic 1 0.082357 4 1845 3492 241 clinic 1 0.069015 5 1846 4010 459 clinic 1 0.114464 . 3. Death at the clinics . If we now plot the proportion of deaths at both clinic 1 and clinic 2 we&#39;ll see a curious pattern... . %matplotlib inline # Plot yearly proportion of deaths at the two clinics # ... YOUR CODE FOR TASK 3 ... ax = yearly1.plot(x=&#39;year&#39;, y=&#39;proportion_deaths&#39;, label=&#39;yearly1&#39;) yearly2.plot(x=&#39;year&#39;, y=&#39;proportion_deaths&#39;, label=&#39;yearly2&#39;, ax=ax) # ax = yearly[[&#39;proportion_deaths&#39;, &#39;year&#39;]].plot(label=&#39;label&#39;) ax.set_ylabel(&#39;Proportion deaths&#39;) . &lt;matplotlib.text.Text at 0x7fead1fa8f28&gt; . 4. The handwashing begins . Why is the proportion of deaths constantly so much higher in Clinic 1? Semmelweis saw the same pattern and was puzzled and distressed. The only difference between the clinics was that many medical students served at Clinic 1, while mostly midwife students served at Clinic 2. While the midwives only tended to the women giving birth, the medical students also spent time in the autopsy rooms examining corpses. . Semmelweis started to suspect that something on the corpses, spread from the hands of the medical students, caused childbed fever. So in a desperate attempt to stop the high mortality rates, he decreed: Wash your hands! This was an unorthodox and controversial request, nobody in Vienna knew about bacteria at this point in time. . Let&#39;s load in monthly data from Clinic 1 to see if the handwashing had any effect. . monthly = pd.read_csv(&#39;datasets/monthly_deaths.csv&#39;, parse_dates=[&#39;date&#39;]) # monthly[&#39;date&#39;] = pd.to_datetime(monthly[&#39;date&#39;]) # Amother method # Calculate proportion of deaths per no. births # ... YOUR CODE FOR TASK 4 ... monthly[&#39;proportion_deaths&#39;] = monthly[&#39;deaths&#39;]/monthly[&#39;births&#39;] # Print out the first rows in monthly # ... YOUR CODE FOR TASK 4 ... monthly.head() . date births deaths proportion_deaths . 0 1841-01-01 | 254 | 37 | 0.145669 | . 1 1841-02-01 | 239 | 18 | 0.075314 | . 2 1841-03-01 | 277 | 12 | 0.043321 | . 3 1841-04-01 | 255 | 4 | 0.015686 | . 4 1841-05-01 | 255 | 2 | 0.007843 | . 5. The effect of handwashing . With the data loaded we can now look at the proportion of deaths over time. In the plot below we haven&#39;t marked where obligatory handwashing started, but it reduced the proportion of deaths to such a degree that you should be able to spot it! . # ... YOUR CODE FOR TASK 5 ... ax = monthly.plot(x=&#39;date&#39;, y=&#39;proportion_deaths&#39;) ax.set_ylabel(&#39;Proportion_deaths&#39;) . &lt;matplotlib.text.Text at 0x7fead1f5dc50&gt; . 6. The effect of handwashing highlighted . Starting from the summer of 1847 the proportion of deaths is drastically reduced and, yes, this was when Semmelweis made handwashing obligatory. . The effect of handwashing is made even more clear if we highlight this in the graph. . import pandas as pd handwashing_start = pd.to_datetime(&#39;1847-06-01&#39;) # Split monthly into before and after handwashing_start before_washing = monthly[(monthly[&#39;date&#39;] &lt; handwashing_start)] after_washing = monthly[(monthly[&#39;date&#39;] &gt;= handwashing_start)] # Plot monthly proportion of deaths before and after handwashing # ... YOUR CODE FOR TASK 6 ... ax = before_washing.plot(x=&#39;date&#39;, y=&#39;proportion_deaths&#39;, label=&#39;before_washing&#39;) after_washing.plot(x=&#39;date&#39;, y=&#39;proportion_deaths&#39;, label=&#39;after_washing&#39;, ax=ax) ax.set_ylabel(&#39;Proportion deaths&#39;) . &lt;matplotlib.text.Text at 0x7fead1882f28&gt; . 7. More handwashing, fewer deaths? . Again, the graph shows that handwashing had a huge effect. How much did it reduce the monthly proportion of deaths on average? . before_proportion = before_washing[&#39;proportion_deaths&#39;] after_proportion = after_washing[&#39;proportion_deaths&#39;] mean_diff = pd.np.mean(after_proportion) - pd.np.mean(before_proportion) mean_diff . -0.08395660751183336 . 8. A Bootstrap analysis of Semmelweis handwashing data . It reduced the proportion of deaths by around 8 percentage points! From 10% on average to just 2% (which is still a high number by modern standards). . To get a feeling for the uncertainty around how much handwashing reduces mortalities we could look at a confidence interval (here calculated using the bootstrap method). . boot_mean_diff = [] for i in range(3000): boot_before = before_proportion.sample(frac=1, replace=True) boot_after = after_proportion.sample(frac=1, replace=True) boot_mean_diff.append(pd.np.mean(boot_after) - pd.np.mean(boot_before) ) # Calculating a 95% confidence interval from boot_mean_diff confidence_interval = ... confidence_interval . Ellipsis . 9. The fate of Dr. Semmelweis . So handwashing reduced the proportion of deaths by between 6.7 and 10 percentage points, according to a 95% confidence interval. All in all, it would seem that Semmelweis had solid evidence that handwashing was a simple but highly effective procedure that could save many lives. . The tragedy is that, despite the evidence, Semmelweis&#39; theory — that childbed fever was caused by some &quot;substance&quot; (what we today know as bacteria) from autopsy room corpses — was ridiculed by contemporary scientists. The medical community largely rejected his discovery and in 1849 he was forced to leave the Vienna General Hospital for good. . One reason for this was that statistics and statistical arguments were uncommon in medical science in the 1800s. Semmelweis only published his data as long tables of raw data, but he didn&#39;t show any graphs nor confidence intervals. If he would have had access to the analysis we&#39;ve just put together he might have been more successful in getting the Viennese doctors to wash their hands. . doctors_should_wash_their_hands = True .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/python/2020/01/29/Dr.-Semmelweis-and-the-Discovery-of-Handwashing.html",
            "relUrl": "/datacamp/projects/python/2020/01/29/Dr.-Semmelweis-and-the-Discovery-of-Handwashing.html",
            "date": " • Jan 29, 2020"
        }
        
    
  
    
        ,"post38": {
            "title": "Introduction to DataCamp Projects(SQL)",
            "content": "1. This is a Jupyter Notebook! . A Jupyter Notebook is a document that contains text cells (what you&#39;re reading right now) and code cells. What is special with a notebook is that it&#39;s interactive: You can change or add code cells, and then run a cell by first selecting it and then clicking the run cell button above ( ▶| Run ) or hitting Ctrl + Enter. . . The result will be displayed directly in the notebook. You could use a notebook as a simple calculator. For example, it&#39;s estimated that on average 256 children were born every minute in 2016. The code cell below calculates how many children were born on average on a day. . 256 * 60 * 24 # Children × minutes × hours . 368640 . 2. Put any code in code cells . But a code cell can contain much more than a simple one-liner! This is a notebook running Python and you can put any Python code in a code cell (but notebooks can run other languages too, like R). Below is a code cell where we define a whole new function (greet). To show the output of greet we run it last in the code cell as the last value is always printed out. . def greet(first_name, last_name): greeting = &#39;My name is &#39; + last_name + &#39;, &#39; + first_name + &#39; &#39; + last_name + &#39;!&#39; return greeting # Replace with your first and last name. # That is, unless your name is already Jane Bond. greet(&#39;Anurag&#39;, &#39;Peddi&#39;) . &#39;My name is Peddi, Anurag Peddi!&#39; . 3. Jupyter Notebooks &#9825; SQL (part i) . We&#39;ve seen that notebooks can display basic objects such as numbers and strings. But notebooks also support and display the outputs of SQL commands! Using an open source Jupyter extension called ipython-sql, we can connect to a database and issue SQL commands within our notebook. For example, we can connect to a PostgreSQL database that has a table that contains country data, then inspect the first three rows of the table by putting %%sql ahead of the SQL commands (more on the meaning of %% later). . %%sql postgresql:///countries SELECT * FROM countries LIMIT 3; . 3 rows affected. . code name continent region surface_area indep_year local_name gov_form capital cap_long cap_lat . AFG | Afghanistan | Asia | Southern and Central Asia | 652090.0 | 1919 | Afganistan/Afqanestan | Islamic Emirate | Kabul | 69.1761 | 34.5228 | . NLD | Netherlands | Europe | Western Europe | 41526.0 | 1581 | Nederland | Constitutional Monarchy | Amsterdam | 4.89095 | 52.3738 | . ALB | Albania | Europe | Southern Europe | 28748.0 | 1912 | Shqiperia | Republic | Tirane | 19.8172 | 41.3317 | . 4. Jupyter Notebooks &#9825; SQL (part ii) . And after the first connection to the database, the connection code (postgresql:///countries) can be omitted. Let&#39;s do a different query this time and select the row in the countries table for Belgium. Note the single % this time. Again, more on that later. . %sql SELECT * FROM countries where name = &#39;Belgium&#39;; . * postgresql:///countries 1 rows affected. . code name continent region surface_area indep_year local_name gov_form capital cap_long cap_lat . BEL | Belgium | Europe | Western Europe | 30518.0 | 1830 | Belgie/Belgique | Constitutional Monarchy, Federation | Brussels | 4.36761 | 50.8371 | . 5. Jupyter Notebooks &#9825; SQL (part iii) . We can even convert our SQL results to a pandas DataFrame! Let&#39;s convert the entire countries table. . result = %sql SELECT * FROM countries; # To pandas DataFrame df = result.DataFrame() df.info() . * postgresql:///countries 206 rows affected. &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 206 entries, 0 to 205 Data columns (total 11 columns): code 206 non-null object name 206 non-null object continent 206 non-null object region 206 non-null object surface_area 206 non-null float64 indep_year 188 non-null float64 local_name 206 non-null object gov_form 206 non-null object capital 201 non-null object cap_long 204 non-null float64 cap_lat 204 non-null float64 dtypes: float64(4), object(7) memory usage: 17.8+ KB . 6. Jupyter Notebooks &#9825; SQLAlchemy . If SQLAlchemy is your thing, you can do that in this notebook, too! Jupyter Notebooks love everything, apparently... . What&#39;s SQLAlchemy, you ask? SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL. Next, we&#39;ll run the last query we just ran except after connecting to and querying the database using SQLAlchemy. . from sqlalchemy import create_engine engine = create_engine(&quot;postgresql:///countries&quot;); # Query database result = engine.execute(&quot;SELECT * FROM countries;&quot;) # Display column names result.keys() . [&#39;code&#39;, &#39;name&#39;, &#39;continent&#39;, &#39;region&#39;, &#39;surface_area&#39;, &#39;indep_year&#39;, &#39;local_name&#39;, &#39;gov_form&#39;, &#39;capital&#39;, &#39;cap_long&#39;, &#39;cap_lat&#39;] . 7. Jupyter Notebooks &#9825; plots . Tables are nice but — as the saying goes — &quot;a plot can show a thousand data points.&quot; Notebooks handle plots as well, but it requires some more magic. Here magic does not refer to any arcane rituals but to so-called &quot;magic commands&quot; that affect how the Jupyter Notebook works. Magic commands start with either % or %% (just like we saw with %sql and %%sql) and the command we need to nicely display plots inline is %matplotlib inline. With this magic in place, all plots created in code cells will automatically be displayed inline. . Using the previously created pandas DataFrame that we named df, let&#39;s plot the number of countries in each continent as a bar chart using the plot() method of pandas DataFrames. . Now, for the difference between %%sql and %sql: ordinary assignment works for single-line %sql queries while %%sql is for multi-line queries. See the Assignment ipython-sql documentation section for more info. . %matplotlib inline # Plotting number of countries in each continent df.continent.value_counts().plot(kind=&#39;bar&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7ff916880668&gt; . 8. Goodbye for now! . Tables and plots are the most common outputs when doing data analysis, but Jupyter Notebooks can render many more types of outputs such as sound, animation, video, etc. Yes, almost anything that can be shown in a modern web browser. This also makes it possible to include interactive widgets directly in the notebook! Everything in this collection of Jupyter Widgets can be displayed in this notebook. . But that&#39;s enough for now! This was just a short introduction to Jupyter Notebooks, an open source technology that is increasingly used for data science and analysis. We hope you enjoyed it! :) . I_am_ready = True # P.S. Feel free to try out any other stuff in this notebook. # It&#39;s all yours! .",
            "url": "https://anuraganalog.github.io/blog/datacamp/projects/sql/2020/01/25/Introduction-to-DataCamp-Projects.html",
            "relUrl": "/datacamp/projects/sql/2020/01/25/Introduction-to-DataCamp-Projects.html",
            "date": " • Jan 25, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://anuraganalog.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  

  

  
  

  
      ,"page13": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://anuraganalog.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}